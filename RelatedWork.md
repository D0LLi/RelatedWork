---
author: Alastair D. Reid
title: Related Work
toc: true

---

# A framework for microprocessor correctness statements {#papers-aagaard-charme-2001}


Mark D. Aagaard, Byron Cook, Nancy A. Day, Robert B. Jones
Correct Hardware Design and Verification Methods: 11th IFIP WG 10.5 Advanced Research Working Conference, CHARME 2001 Livingston, Scotland, UK, September 4-7, 2001 Proceedings
Springer
Berlin, Heidelberg
Pages 433-448
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20framework%20for%20microprocessor%20correctness%20statements)
[[DBLP]](https://dblp.org/search?q=A%20framework%20for%20microprocessor%20correctness%20statements)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20framework%20for%20microprocessor%20correctness%20statements)
[[doi]](https://doi.org/10.1007/3-540-44798-9_33)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-44798-6)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# A methodology for large-scale hardware verification {#papers-aagaard-fmcad-2000}


Mark D. Aagaard, Robert B. Jones, Thomas F. Melham, John W. O'Leary, Carl-Johan H. Seger
Formal Methods in Computer-Aided Design: Third International Conference, FMCAD 2000 Austin, TX, USA, November 1-3, 2000 Proceedings
Springer
Berlin, Heidelberg
Pages 300-319
2000
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20methodology%20for%20large-scale%20hardware%20verification)
[[DBLP]](https://dblp.org/search?q=A%20methodology%20for%20large-scale%20hardware%20verification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20methodology%20for%20large-scale%20hardware%20verification)
[[doi]](https://doi.org/10.1007/3-540-40922-X_17)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-40922-9)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# The existence of refinement mappings {#papers-abadi-tcs-1991}


Martín Abadi, Leslie Lamport
Elsevier
Pages 253-284
1991
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20existence%20of%20refinement%20mappings)
[[DBLP]](https://dblp.org/search?q=The%20existence%20of%20refinement%20mappings)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20existence%20of%20refinement%20mappings)
[[doi]](https://doi.org/10.1016/0304-3975(91)90224-P)



Theoretical paper justifying the practice of adding auxiliary variables (ghost
state) to an implementation to enable refinement proof by providing
a completeness proof that a refinement mapping from an implementation S1 to
a specification S2 exists if S1 refines S2 and three conditions hold

- S1 is "machine closed",
- S2 has "finite invisible nondeterminism", and
- S2 is "internally continuous".

A refinement mapping is a function from the implementation state (including
auxiliary variables) to the specification state.
The auxiliary variables can be either "history variables" or "prophecy
variables".



# Testing the FM9001 microprocessor {#papers-albin-cli-1995}


Kenneth L. Albin, Bishop C. Brock, Warren A. Hunt Jr., Lawrence M. Smith
Report
Computational Logic, Inc
January
1995
[[Google Scholar]](https://scholar.google.com/scholar?q=Testing%20the%20FM9001%20microprocessor)
[[DBLP]](https://dblp.org/search?q=Testing%20the%20FM9001%20microprocessor)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Testing%20the%20FM9001%20microprocessor)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# Herding cats: Modelling, simulation, testing, and data mining for weak memory {#papers-alglave-toplas-2014}


Jade Alglave, Luc Maranget, Michael Tautschnig
Pages 7:1-7:74
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=Herding%20cats%3A%20Modelling%2C%20simulation%2C%20testing%2C%20and%20data%20mining%20for%20weak%20memory)
[[DBLP]](https://dblp.org/search?q=Herding%20cats%3A%20Modelling%2C%20simulation%2C%20testing%2C%20and%20data%20mining%20for%20weak%20memory)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Herding%20cats%3A%20Modelling%2C%20simulation%2C%20testing%2C%20and%20data%20mining%20for%20weak%20memory)
[[doi]](https://doi.org/10.1145/2627752)

Notes: 
[Weak memory](#Weak memory)\



[Weak memory]: #notes-weak-memory
# Automated verification of a small hypervisor {#papers-alkassar-vstte-2010}


Eyad Alkassar, Mark A. Hillebrand, Wolfgang J. Paul, Elena Petrova
International Conference on Verified Software: Theories, Tools, and Experiments
Springer
Pages 40-54
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=Automated%20verification%20of%20a%20small%20hypervisor)
[[DBLP]](https://dblp.org/search?q=Automated%20verification%20of%20a%20small%20hypervisor)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automated%20verification%20of%20a%20small%20hypervisor)
[[doi]](https://doi.org/10.1007/978-3-642-15057-9_3)





# Verification of TLB virtualization implemented in C {#papers-alkassar-vstte-2012}


Eyad Alkassar, Ernie Cohen, Mikhail Kovalev, Wolfgang J. Paul
International Conference on Verified Software: Tools, Theories, Experiments
Springer
Pages 209-224
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=Verification%20of%20TLB%20virtualization%20implemented%20in%20C)
[[DBLP]](https://dblp.org/search?q=Verification%20of%20TLB%20virtualization%20implemented%20in%20C)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Verification%20of%20TLB%20virtualization%20implemented%20in%20C)
[[doi]](https://doi.org/10.1007/978-3-642-27705-4_17)





# Verifying constant-time implementations {#papers-almeida-security-2016}


José Bacelar Almeida, Manuel Barbosa, Gilles Barthe, François Dupressoir, Michael Emmi
25th USENIX Security Symposium (USENIX Security 16)
Pages 53-70
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Verifying%20constant-time%20implementations)
[[DBLP]](https://dblp.org/search?q=Verifying%20constant-time%20implementations)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Verifying%20constant-time%20implementations)

Notes: 
[information flow](#information flow),
[self composition](#self composition),
[Boogie verifier](#Boogie verifier),
[SMACK verifier](#SMACK verifier)\
Papers: 
[barnett:fmco:2005](#barnett-fmco-2005),
[rakamaric:cav:2014](#rakamaric-cav-2014)\


Tool for verifying constant time behaviour of C code based on self composition preprocessing then using [SMACK][rakamaric:cav:2014] and [Boogie][barnett:fmco:2005].
Parameterized by whether leakage is just PC divergence or also memory access divergence.
Correctness of a reduced/simplified version of analysis is proved in Coq and full algorithm "should not present any additional difficulty".
Demonstrated on a very broad range of crypto code, fixed-time fixed-point code.
Key idea is to reduce security property (2-safety) to 1-safety property using a product construction exploiting the requirement that, if the code is constant time then there should be no PC divergence between the two runs.
A key strength is the ability to be output insensitive: it is ok to leak information that will be leaked anyway.  E.g., if the size is part of the intended output, then it is ok for runtime to depend on size even though size may depend on the secret input.  This distinguishes it from approaches that use some form of tainting of inputs.



[information flow]: #notes-information-flow
[self composition]: #notes-self-composition
[Boogie verifier]: #notes-boogie-verifier
[SMACK verifier]: #notes-smack-verifier
[barnett:fmco:2005]: #papers-barnett-fmco-2005
[rakamaric:cav:2014]: #papers-rakamaric-cav-2014
# Cogent: Verifying high-assurance file system implementations {#papers-amani-asplos-2016}


Sidney Amani, Alex Hixon, Zilin Chen, Christine Rizkallah, Peter Chubb, Liam O'Connor, Joel Beeren, Yutaka Nagashima, Japheth Lim, Thomas Arthur Leck Sewell, Joseph Tuong, Gabriele Keller, Toby Murray, Gerwin Klein, Gernot Heiser
Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems
ASPLOS'16
Atlanta, Georgia, USA
Association for Computing Machinery
New York, NY, USA
Pages 175–188
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Cogent%3A%20Verifying%20high-assurance%20file%20system%20implementations)
[[DBLP]](https://dblp.org/search?q=Cogent%3A%20Verifying%20high-assurance%20file%20system%20implementations)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Cogent%3A%20Verifying%20high-assurance%20file%20system%20implementations)
[[doi]](https://doi.org/10.1145/2872362.2872404)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450340915)
[[url]](https://doi.org/10.1145/2872362.2872404)





# A survey of asynchronous remote procedure calls {#papers-ananda-osr-1992}


Akkihebbal L. Ananda, Boon Hwa Tay, Eng Kiat Koh
ACM
New York, NY, USA
Pages 92-109
April
1992
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20survey%20of%20asynchronous%20remote%20procedure%20calls)
[[DBLP]](https://dblp.org/search?q=A%20survey%20of%20asynchronous%20remote%20procedure%20calls)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20survey%20of%20asynchronous%20remote%20procedure%20calls)
[[doi]](https://doi.org/10.1145/142111.142121)

Notes: 
[remote procedure call](#remote procedure call),
[survey](#survey)\
Referenced by: 
[notes/remote-procedure-call](#notes-remote-procedure-call)\



[remote procedure call]: #notes-remote-procedure-call
[survey]: #notes-survey
# Large-scale formal verification in practice: A process perspective {#papers-andronick-icse-2012}


June Andronick, Ross Jeffery, Gerwin Klein, Rafal Kolanski, Mark Staples, He Zhang, Liming Zhu
Proceedings of the 34th International Conference on Software Engineering
ICSE'12
Zurich, Switzerland
IEEE Press
Piscataway, NJ, USA
Pages 1002-1011
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=Large-scale%20formal%20verification%20in%20practice%3A%20A%20process%20perspective)
[[DBLP]](https://dblp.org/search?q=Large-scale%20formal%20verification%20in%20practice%3A%20A%20process%20perspective)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Large-scale%20formal%20verification%20in%20practice%3A%20A%20process%20perspective)
[[doi]](https://doi.org/10.1109/ICSE.2012.6227120)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4673-1067-3)





# Detailed models of instruction set architectures: From pseudocode to formal semantics {#papers-armstrong-arw-2018}


Alasdair Armstrong, Thomas Bauereiss, Brian Campbell, Shaked Flur, Kathryn E. Gray, Prashanth Mundkur, Robert M. Norton, Christopher Pulte, Alastair D. Reid, Peter Sewell, Ian Stark, Mark Wassell
Automated Reasoning Workshop 2018
Cambridge, UK
April
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=Detailed%20models%20of%20instruction%20set%20architectures%3A%20From%20pseudocode%20to%20formal%20semantics)
[[DBLP]](https://dblp.org/search?q=Detailed%20models%20of%20instruction%20set%20architectures%3A%20From%20pseudocode%20to%20formal%20semantics)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Detailed%20models%20of%20instruction%20set%20architectures%3A%20From%20pseudocode%20to%20formal%20semantics)

Notes: 
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture),
[dependent type](#dependent type),
[SAIL language](#SAIL language)\




[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
[dependent type]: #notes-dependent-type
[SAIL language]: #notes-sail-language
# ISA semantics for ARMv8-A, RISC-V, and CHERI-MIPS {#papers-armstrong-popl19-2019}


Alasdair Armstrong, Thomas Bauereiss, Brian Campbell, Alastair D. Reid, Kathryn E. Gray, Robert M. Norton, Prashanth Mundkur, Mark Wassell, Jon French, Christopher Pulte, Shaked Flur, Ian Stark, Neel R. Krishnaswami, Peter Sewell
Proc. 46th ACM SIGPLAN Symposium on Principles of Programming Languages
Cascais/Lisbon, Portugal
ACM
New York, NY, USA
Pages 71:1-71:31
13-19
January
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=ISA%20semantics%20for%20ARMv8-A%2C%20RISC-V%2C%20and%20CHERI-MIPS)
[[DBLP]](https://dblp.org/search?q=ISA%20semantics%20for%20ARMv8-A%2C%20RISC-V%2C%20and%20CHERI-MIPS)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=ISA%20semantics%20for%20ARMv8-A%2C%20RISC-V%2C%20and%20CHERI-MIPS)
[[doi]](https://doi.org/10.1145/3290384)

Notes: 
[Arm architecture](#Arm architecture),
[RISCV architecture](#RISCV architecture),
[CHERI architecture](#CHERI architecture),
[MIPS architecture](#MIPS architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture),
[dependent type](#dependent type),
[ASL](#ASL),
[SAIL language](#SAIL language)\




[Arm architecture]: #notes-arm-architecture
[RISCV architecture]: #notes-riscv-architecture
[CHERI architecture]: #notes-cheri-architecture
[MIPS architecture]: #notes-mips-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
[dependent type]: #notes-dependent-type
[ASL]: #notes-asl
[SAIL language]: #notes-sail-language
# The state of Sail {#papers-armstrong-spisa-2019}


Alasdair Armstrong, Thomas Bauereiss, Brian Campbell, Alastair D. Reid, Kathryn E. Gray, Robert M. Norton, Prashanth Mundkur, Mark Wassell, Jon French, Christopher Pulte, Shaked Flur, Ian Stark, Neel R. Krishnaswami, Peter Sewell
SpISA 2019: Workshop on Instruction Set Architecture Specification
Portland, Oregon, USA
September
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20state%20of%20Sail)
[[DBLP]](https://dblp.org/search?q=The%20state%20of%20Sail)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20state%20of%20Sail)

Notes: 
[Arm architecture](#Arm architecture),
[RISCV architecture](#RISCV architecture),
[cheri-architecture](#cheri-architecture),
[mips-architecture](#mips-architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture),
[dependent type](#dependent type),
[SAIL language](#SAIL language)\




[Arm architecture]: #notes-arm-architecture
[RISCV architecture]: #notes-riscv-architecture
[cheri-architecture]: #notes-cheri-architecture
[mips-architecture]: #notes-mips-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
[dependent type]: #notes-dependent-type
[SAIL language]: #notes-sail-language
# Vector microprocessors {#papers-asanovic-phd-1998}


Krste Asanović
Ph.D. thesis
University of California, Berkeley
May
1998
[[Google Scholar]](https://scholar.google.com/scholar?q=Vector%20microprocessors)
[[DBLP]](https://dblp.org/search?q=Vector%20microprocessors)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Vector%20microprocessors)

Notes: 
[vector architecture](#vector architecture),
[instruction set architecture](#instruction set architecture),
[microarchitecture](#microarchitecture)\



[vector architecture]: #notes-vector-architecture
[instruction set architecture]: #notes-instruction-set-architecture
[microarchitecture]: #notes-microarchitecture
# Leveraging Rust types for modular specification and verification {#papers-astrauskas-oopsla-2019}


Vytautas Astrauskas, Peter Müller, Federico Poli, Alexander J. Summers
Association for Computing Machinery
New York, NY, USA
October
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Leveraging%20Rust%20types%20for%20modular%20specification%20and%20verification)
[[DBLP]](https://dblp.org/search?q=Leveraging%20Rust%20types%20for%20modular%20specification%20and%20verification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Leveraging%20Rust%20types%20for%20modular%20specification%20and%20verification)
[[doi]](https://doi.org/10.1145/3360573)
[[url]](https://doi.org/10.1145/3360573)

Notes: 
[permission logic](#permission logic),
[Rust language](#Rust language),
[viper-verifier](#viper-verifier),
[permission accounting](#permission accounting),
[cactus-plot](#cactus-plot)\
Papers: 
[ohearn:cacm:2019](#ohearn-cacm-2019),
[muller:vmcai:2016](#muller-vmcai-2016),
[jacobs:nfm:2011](#jacobs-nfm-2011)\
Referenced by: 
[papers/matsushita:esop:2020](#papers-matsushita-esop-2020),
[notes/magic-wand](#notes-magic-wand),
[notes/ownership-types](#notes-ownership-types),
[notes/prusti-verifier](#notes-prusti-verifier),
[notes/rust-language](#notes-rust-language)\


This paper exploits the close similarity between
Rust's type system
and
permission based reasoning approaches such as
[separation logic][ohearn:cacm:2019]
and
implicit dynamic frames logic.
Specifically, they describe the embedding of Rust programs
into the [Viper intermediate verification language][muller:vmcai:2016]
in a way that exploits the properties of Rust's
borrow-based type system.
This embedding is (partially?) implemented in the _Prusti_
verification tool that translates Rust to Viper
and translates any errors back from Viper to Rust.
Their focus at the moment is on "safe" code: code that
obeys the Rust type system.

Prusti is a plugin into rustc (the Rust compiler) and
it is able to use some of the type information available
inside the Rust typechecker although some of the internal
detail is hard to obtain and must be reconstructed
and some of the detail is only expressed as negative facts
instead of as positive witnesses.
Their goal is to construct Viper annotated with enough
annotations that no human intervention is required for
type-level proofs so Prusti has to reconstruct any
missing information.

One of the challenges with Rust's type system is the
notion of mutable reborrows.
This makes it hard for them to express some post-conditions
in the standard way and they propose a system of
"pledges" that talk not just about "old" values
(from before a function was called)
and the current values (from immediately after
when a function was called) but, when a function
returns a mutable reference, they must also talk about
the value that reference has after the reference's
lifetime ends.
This was a bit hard for me to get my head around because I
was still thinking of the reference as "just a pointer"
which may be how it is implemented but it is not how
the semantics works.

Another interesting detail is how they model immutable
references.
It seems that they really want to use
[counting permissions][bornat:popl:2005]
but, instead, they model them as fractional
permissions (an approach they attribute to [Heule][heule:ftfjp:2011]).

Their evaluation is in two parts

1. Verifying functions for undefined behaviour such as
   panics, assert failures, etc. – without adding
   specifications of the functions under test.
   They harvested 11,791 functions
   from 500 Rust crates (after discarding functions that
   use unimplemented features and very large functions
   that cause their translation to blow up.
   They report the time taken to verify functions (with the
   usual cactus plot)
   and the number of potential/actual errors found.
   It is not clear to me how many of these are confirmed
   bugs and have been reported/fixed.
   They also had problems with timeouts (mostly in non-linear
   arithmetic).
   Average verification time was 1 second but there was
   significant variation (median time was 0.16 seconds).


2. Verifying functional correctness of functions for
   which they added specifications.
   For this, they gathered code from [Rosetta
   Code](http://www.rosettacode.org/wiki/Rosetta_Code)
   and from [Matsakis' blog](http://smallcultfollowing.com/babysteps/),
   rewrote the examples to
   avoid unimplemented syntax, added functional
   specifications.
   Average verification time was over 30 seconds per
   function with a median time of around 20 seconds.
   (They don't report the average/median so those
   numbers come from me eyeballing the tables.)
   This is a bit slow (especially since I have recently been
   using the "very fast"
   [VeriFast][jacobs:nfm:2011]
   tool), but this is clearly early days in the tool
   development and they say there is a lot of opportunity
   for optimisation.
   
   



[permission logic]: #notes-permission-logic
[Rust language]: #notes-rust-language
[viper-verifier]: #notes-viper-verifier
[permission accounting]: #notes-permission-accounting
[cactus-plot]: #notes-cactus-plot
[ohearn:cacm:2019]: #papers-ohearn-cacm-2019
[muller:vmcai:2016]: #papers-muller-vmcai-2016
[jacobs:nfm:2011]: #papers-jacobs-nfm-2011
# Enhancing symbolic execution with veritesting {#papers-avgerinos-icse-2014}


Thanassis Avgerinos, Alexandre Rebert, Sang Kil Cha, David Brumley
Proceedings of the 36th International Conference on Software Engineering
ICSE 2014
Hyderabad, India
Association for Computing Machinery
New York, NY, USA
Pages 1083-1094
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=Enhancing%20symbolic%20execution%20with%20veritesting)
[[DBLP]](https://dblp.org/search?q=Enhancing%20symbolic%20execution%20with%20veritesting)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Enhancing%20symbolic%20execution%20with%20veritesting)
[[doi]](https://doi.org/10.1145/2568225.2568293)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450327565)
[[url]](https://doi.org/10.1145/2568225.2568293)

Notes: 
[symbolic execution](#symbolic execution),
[BAP tool](#BAP tool),
[PIN tool](#PIN tool),
[Z3 solver](#Z3 solver)\
Referenced by: 
[notes/bap-tool](#notes-bap-tool),
[notes/symbolic-execution](#notes-symbolic-execution)\


This paper attacks the path explosion problem of [symbolic execution] by using
a hybrid of dynamic symbolic execution (DSE) and static symbolic execution
(SSE) that they call "veritesting".  Their tool "MergePoint" starts with
concolic execution (a form of DSE) from some seed but opportunistically
switches to SSE whenever the paths ahead contain straightforward code that SSE
can cope with.  They find that the additional cost due to having larger, more
complex SMT queries is compensated for by the exponentially smaller number of
paths

The tool is based on converting x86 machine code to CFGs (using the Binary
Analysis Platform (BAP)), introducing transition points where execution
should switch from SSE back to DSE and merging paths that do not include
transitions.
This is built on top of the Mayhem symbolic execution tool, the [BAP tool],
the [PIN tool] and the [Z3 solver] and they are able to turn SSE on or off
allowing a very clear measurement of the benefit of their hybrid mode.

The evaluation is a particularly impressive demonstration of their ability
to scale: they take all binaries from Debian
(that do not access hardcoded file paths) and symbolically execute them all.
They measure several coverage-related
metrics and report a large number of bugs.  In fact, their tool scales so well
that the bottleneck becomes bug reporting: finding who to report the bugs to,
writing the bug report, etc.  Within the timelimit they use, SSE does not cover
every single line or find every single bug found without SSE but SSE covers
more code and finds more bugs.

They also analyze coreutils (the traditional benchmark for symbolic execution
tools) and, despite this suite having been analyzed many times before, they are
able to find a new family of bugs.

An interesting new statistic reported in this paper is the (estimated) cost of
bug discovery: $0.28 per bug on Amazon's EC2 instances.  This metric is
imperfect because costs will change over time, and because crash triage is an
approximate and inconsistent technique. But, it is probably one of the key
metrics that would be used to decide when and for how long to use a tool like
this.




[symbolic execution]: #notes-symbolic-execution
[BAP tool]: #notes-bap-tool
[PIN tool]: #notes-pin-tool
[Z3 solver]: #notes-z3-solver
# FUDGE: Fuzz driver generation at scale {#papers-babic-fse-2019}


Domagoj Babić, Stefan Bucur, Yaohui Chen, Franjo Ivančić, Tim King, Markus Kusano, Caroline Lemieux, László Szekeres, Wei Wang
Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering
ESEC/FSE 2019
Tallinn, Estonia
Association for Computing Machinery
New York, NY, USA
Pages 975-985
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=FUDGE%3A%20Fuzz%20driver%20generation%20at%20scale)
[[DBLP]](https://dblp.org/search?q=FUDGE%3A%20Fuzz%20driver%20generation%20at%20scale)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=FUDGE%3A%20Fuzz%20driver%20generation%20at%20scale)
[[doi]](https://doi.org/10.1145/3338906.3340456)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450355728)
[[url]](https://doi.org/10.1145/3338906.3340456)

Notes: 
[fuzz testing](#fuzz testing),
[test generation](#test generation)\


Addresses the problem of generating fuzzing test harnesses for libraries by
automatically generating harnesses based on example uses in existing clients.
The goal is to increase the productivity of users and
it is expected that a human will examine the generated harnesses for legality,
etc. before they are used to report bugs.

The approach has three stages: slicing, synthesis and evaluation.

- Slicing analyzes functions and extracts code related to the library under test
  using the ClangMR frontend hook.

- Synthesis turns slices into runnable code.
  Results of calls to other libraries are replaced with placeholders and
  several candidate test harnesses are generated with different combinations
  of concrete and fuzzable values.

- Evaluation weeds out candidates that fail within a time bound since they
  are considered low-value.
  The remainder are passed to users who can rank them, observe increase in
  coverage, modify them (e.g., to choose better variable names and other
  readability improvements), etc.

This tooling is embedded in a flow that

- uses heuristics to try to identify APIs
  worth fuzzing (e.g., it looks for names like "parse", "load",
  "open", ...).

- ranks APIs by number of uses within Google's internal codebase

- presents generated harnesses as "code findings" next to the code
  that they test.

The paper reports several case studies with open-source (non-Google) code
and they report several lessons learned.

1. Choosing a suitable fuzz target (still) requires a human.

2. API call sites present good locality.
   (This allows the use of an intraprocedural analysis most of the time.)

3. Analyzing C++ is challenging due to a long tail of language features.

4. Randomized algorithms have a good cost-value tradeoff for program synthesis.

5. Program synthesis artifacts can be presented as code findings to developers.

A lot of the previous tools in this space were for Java.



[fuzz testing]: #notes-fuzz-testing
[test generation]: #notes-test-generation
# System programming in Rust: Beyond safety {#papers-balasubramanium-hotos-2017}


Abhiram Balasubramanian, Marek S. Baranowski, Anton Burtsev, Aurojit Panda, Zvonimir Rakamarić, Leonid Ryzhyk
Association for Computing Machinery
New York, NY, USA
Pages 94–99
September
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=System%20programming%20in%20Rust%3A%20Beyond%20safety)
[[DBLP]](https://dblp.org/search?q=System%20programming%20in%20Rust%3A%20Beyond%20safety)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=System%20programming%20in%20Rust%3A%20Beyond%20safety)
[[doi]](https://doi.org/10.1145/3139645.3139660)
[[url]](https://doi.org/10.1145/3139645.3139660)

Notes: 
[Rust language](#Rust language)\


See also: [the morning paper](https://blog.acolyer.org/2017/06/14/system-programming-in-rust-beyond-safety/)



[Rust language]: #notes-rust-language
# A survey of symbolic execution techniques {#papers-baldoni-compsurv-2018}


Roberto Baldoni, Emilio Coppa, Daniele Cono D'elia, Camil Demetrescu, Irene Finocchi
Association for Computing Machinery
New York, NY, USA
May
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20survey%20of%20symbolic%20execution%20techniques)
[[DBLP]](https://dblp.org/search?q=A%20survey%20of%20symbolic%20execution%20techniques)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20survey%20of%20symbolic%20execution%20techniques)
[[doi]](https://doi.org/10.1145/3182657)
[[url]](https://doi.org/10.1145/3182657)

Notes: 
[symbolic execution](#symbolic execution),
[KLEE verifier](#KLEE verifier),
[survey](#survey)\
Referenced by: 
[papers/cadar:cacm:2013](#papers-cadar-cacm-2013),
[notes/smt-solver](#notes-smt-solver),
[notes/symbolic-execution](#notes-symbolic-execution)\


This [survey] reinforces my impression that [symbolic execution] is
a beautifully simple idea that, like most beautifully simple ideas, requires
a lot of optimizations to make it scale.
As the structure of the paper shows, most of the survey is concerned with the optimizations.

- Introduction
    - Challenges in Symbolic Execution
    - Related Work
    - Organization of the Article
- Symbolic Execution Engines
    - Mixing Symbolic and Concrete Execution
        - Dynamic Symbolic Execution
        - Selective Symbolic Execution
    - Path Selection

      Can use depth-first, breadth-first, random, buggy-path-first
      or other schedules such as prioritizing symbolic memory accesses.
      (Depth and breadth-first lend themselves to particular optimizations.)

    - Caching
    - Symbolic Backward Execution
    - Design Principles of Symbolic Executors

      Principles include: "ensuring progress", avoiding "work repetition" and
      "analysis reuse".

      "Online" executors explore multiple paths in one run;
      "offline" executors explore one path and then stop;
      "hybrid" executors such as MAYHEM do both.

- Memory model
    - Fully Symbolic Memory
    - Address Concretization
    - Theory of Arrays
    - Partial Memory Modeling
    - Complex Objects
    - Lazy Initialization
        - Verifying Client Code Only
- Interaction with the environment
        - System Environment
        - Application Environment
- Path explosion
    - Pruning Unrealizable Paths

      Path constraints can be "eagerly" evaluated,
      or "lazily" evaluated.

    - Function and Loop Summarization
        - Function Summaries
        - Loop Summaries
    - Path Subsumption and Equivalence
        - Interpolation
        - Subsumption with Interpolation
        - Unbounded Loops
        - Subsumption with Abstraction
        - Path Partitioning
    - Under-constrained Symbolic Execution

      To avoid false positives when a function is evaluated in isolation,
      under-constrained variables (e.g., symbolic inputs) to the function are marked and
      errors based on under-constrained variables are suppressed.

    - Exploiting Preconditions and Input Features
    - Controlled Loop Exploration
    - Dynamic symbolic execution
    - State Merging
        - Tradeoffs: to Merge or Not to Merge?
        - Merging Heuristics
        - Dynamic State Merging
    - Leveraging Program Analysis and Optimization Techniques
        - Program Slicing
        - Taint Analysis
        - Fuzzing
        - Branch Predication
        - Type Checking
        - Compiler Optimizations
- Constraint solving
    - Optimization Techniques
        - Constraint Reduction
        - Reuse of Constraint Solutions
    - Unburdening the Constraint Solver
        - Reuse of Constraint Solutions
    - Other Optimizations in Symbolic Executors
    - Reducing the Symbolic Executor's Pressure on Constraint Solvers
        - Lazy Constraints
        - Concretization
        - Handling Problematic Constraints
- Further Directions
    - Separation Logic
    - Invariants
    - Function Summaries
    - Program Analysis and Optimization
    - Symbolic Computation
- Conclusions




[symbolic execution]: #notes-symbolic-execution
[KLEE verifier]: #notes-klee-verifier
[survey]: #notes-survey
# Deconstructing dynamic symbolic execution {#papers-ball-dsse-2015}


Thomas Ball, Jakub Daniel
Report
The 2014 Marktober Summer School on Deop
IOS Press
January
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=Deconstructing%20dynamic%20symbolic%20execution)
[[DBLP]](https://dblp.org/search?q=Deconstructing%20dynamic%20symbolic%20execution)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Deconstructing%20dynamic%20symbolic%20execution)
[[url]](https://www.microsoft.com/en-us/research/publication/deconstructing-dynamic-symbolic-execution/)

Notes: 
[symbolic execution](#symbolic execution)\



[symbolic execution]: #notes-symbolic-execution
# Automatic predicate abstraction of C programs {#papers-ball-pldi-2001}


Thomas Ball, Rupak Majumdar, Todd Millstein, Sriram K. Rajamani
Proceedings of the ACM SIGPLAN 2001 Conference on Programming Language Design and Implementation
PLDI '01
Snowbird, Utah, USA
Association for Computing Machinery
New York, NY, USA
Pages 203-213
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=Automatic%20predicate%20abstraction%20of%20C%20programs)
[[DBLP]](https://dblp.org/search?q=Automatic%20predicate%20abstraction%20of%20C%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automatic%20predicate%20abstraction%20of%20C%20programs)
[[doi]](https://doi.org/10.1145/378795.378846)
[[ISBN]](http://books.google.com/books?vid=ISBN1581134142)
[[url]](https://doi.org/10.1145/378795.378846)

Notes: 
[CEGAR](#CEGAR),
[model checking](#model checking)\
Papers: 
[henzinger:spin:2003](#henzinger-spin-2003)\
Referenced by: 
[papers/henzinger:spin:2003](#papers-henzinger-spin-2003)\



[CEGAR]: #notes-cegar
[model checking]: #notes-model-checking
[henzinger:spin:2003]: #papers-henzinger-spin-2003
# Automatic generation of peephole superoptimizers {#papers-bansal-asplos-2006}


Sorav Bansal, Alex Aiken
Proceedings of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems
ASPLOS XII
San Jose, California, USA
ACM
New York, NY, USA
Pages 394-403
2006
[[Google Scholar]](https://scholar.google.com/scholar?q=Automatic%20generation%20of%20peephole%20superoptimizers)
[[DBLP]](https://dblp.org/search?q=Automatic%20generation%20of%20peephole%20superoptimizers)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automatic%20generation%20of%20peephole%20superoptimizers)
[[doi]](https://doi.org/10.1145/1168857.1168906)
[[ISBN]](http://books.google.com/books?vid=ISBN1-59593-451-0)

Notes: 
[superoptimizer](#superoptimizer),
[ISA specification](#ISA specification)\
Referenced by: 
[notes/superoptimizer](#notes-superoptimizer)\




[superoptimizer]: #notes-superoptimizer
[ISA specification]: #notes-isa-specification
# Binary translation using peephole superoptimizers {#papers-bansal-osdi-2008}


Sorav Bansal, Alex Aiken
Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation
OSDI'08
San Diego, California
USENIX Association
Berkeley, CA, USA
Pages 177-192
2008
[[Google Scholar]](https://scholar.google.com/scholar?q=Binary%20translation%20using%20peephole%20superoptimizers)
[[DBLP]](https://dblp.org/search?q=Binary%20translation%20using%20peephole%20superoptimizers)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Binary%20translation%20using%20peephole%20superoptimizers)
[[url]](https://www.usenix.org/legacy/event/osdi08/tech/full_papers/bansal/bansal.pdf)

Notes: 
[ISA specification](#ISA specification),
[superoptimizer](#superoptimizer)\
Referenced by: 
[notes/superoptimizer](#notes-superoptimizer)\




[ISA specification]: #notes-isa-specification
[superoptimizer]: #notes-superoptimizer
# Verifying Rust programs with SMACK {#papers-baranowski-atva-2018}


Marek S. Baranowski, Shaobo He, Zvonimir Rakamarić
Automated Technology for Verification and Analysis
Springer International Publishing
Cham
Pages 528-535
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=Verifying%20Rust%20programs%20with%20SMACK)
[[DBLP]](https://dblp.org/search?q=Verifying%20Rust%20programs%20with%20SMACK)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Verifying%20Rust%20programs%20with%20SMACK)
[[doi]](https://doi.org/10.1007/978-3-030-01090-4_32)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-030-01090-4)

Notes: 
[Boogie verifier](#Boogie verifier),
[Corral verifier](#Corral verifier),
[intermediate verification language](#intermediate verification language),
[Rust language](#Rust language),
[SMACK verifier](#SMACK verifier),
[LLVM compiler](#LLVM compiler)\
Papers: 
[rakamaric:cav:2014](#rakamaric-cav-2014),
[barnett:fmco:2005](#barnett-fmco-2005),
[lal:fse:2014](#lal-fse-2014),
[demoura:tacas:2008](#demoura-tacas-2008)\
Referenced by: 
[papers/matsushita:esop:2020](#papers-matsushita-esop-2020),
[notes/rust-language](#notes-rust-language),
[notes/smack-verifier](#notes-smack-verifier)\


The Rust programming language promises a balance between safety
and control that makes it an interesting target for
formal verification work.
Unfortunately, some of the earliest verification tools supporting
Rust are not maintained.
[SMACK][rakamaric:cav:2014]
is an LLVM-based verification toolchain that translates LLVM IR
into verification conditions.
In principle, it should be able to cope with any language that
can be translated to LLVM IR but every language has its quirks
and this paper describes additional features and analyses required
to support the Rust language well.
An interesting aspect of basing this on LLVM is that
it allows verification of programs that combine Rust and C
(or any other language that LLVM supports).

This toolchain uses rustc to convert Rust code to LLVM IR;
SMACK converts LLVM IR code
into [Boogie][barnett:fmco:2005]
[intermediate verification language]
and then into [Corral][lal:fse:2014]
and the [Z3 SMT solver][demoura:tacas:2008]
In this paper, this is used for bounded verification: unrolling loops and recursion up to some bound.



Some of the problems they solved in this paper are:

- detecting arithmetic overflow
- adding new macros 'assume' and 'assert'
- use of "i1" to represent booleans (instead of "i8" in C)
- better support for structures (which are used far more 
  extensively in idiomatic C code)
- rustc optimizations such as combining two 32-bit loads into
  a single 64-bit load
- rustc specific intrinsics such as "llvm.expect" that are
  used in Rust to provide branch hints
- creating models of standard libraries that replace Rust's
  highly optimized libraries with libraries more suited for
  verification
  
To drive development, they created some microbenchmarks
and to judge the quality of their implementation, they
verified three small (80–140 loc) real world applications.
(They had to slightly simplify all three applications
to simplify verification.)
In the process, they found a bug in one of the applications
and they realized that an overflow panic in one of the
other applications corresponded to a bug in a C implementation
of the same application.

Future work includes

- modelling more of the standard library
- checking unsafe pointer usage in Rust - especially those
  from external functions
- concurrency



[Boogie verifier]: #notes-boogie-verifier
[Corral verifier]: #notes-corral-verifier
[intermediate verification language]: #notes-intermediate-verification-language
[Rust language]: #notes-rust-language
[SMACK verifier]: #notes-smack-verifier
[LLVM compiler]: #notes-llvm-compiler
[rakamaric:cav:2014]: #papers-rakamaric-cav-2014
[barnett:fmco:2005]: #papers-barnett-fmco-2005
[lal:fse:2014]: #papers-lal-fse-2014
[demoura:tacas:2008]: #papers-demoura-tacas-2008
# ISP: A notation to describe a computer's instruction sets {#papers-barbacci2-computer-1973}


Mario R. Barbacci, C. Gordon Bell, Daniel P. Siewiorek
Pages 22-24
1973
[[Google Scholar]](https://scholar.google.com/scholar?q=ISP%3A%20A%20notation%20to%20describe%20a%20computer%27s%20instruction%20sets)
[[DBLP]](https://dblp.org/search?q=ISP%3A%20A%20notation%20to%20describe%20a%20computer%27s%20instruction%20sets)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=ISP%3A%20A%20notation%20to%20describe%20a%20computer%27s%20instruction%20sets)
[[doi]](https://doi.org/10.1109/C-M.1973.217035)
[[url]](https://doi.org/10.1109/C-M.1973.217035)

Notes: 
[ISPS](#ISPS)\



[ISPS]: #notes-isps
# An architectural research facility: ISP descriptions, simulation, data collection {#papers-barbacci-afips-1977}


Mario R. Barbacci, Daniel P. Siewiorek, Robert L. Gordon, Rosemary Howbrigg, Susan Zuckerman
American Federation of Information Processing Societies: 1977 National Computer Conference, June 13-16, 1977, Dallas, Texas, USA
AFIPS Conference Proceedings, volume 46
AFIPS Press
Pages 161-173
1977
[[Google Scholar]](https://scholar.google.com/scholar?q=An%20architectural%20research%20facility%3A%20ISP%20descriptions%2C%20simulation%2C%20data%20collection)
[[DBLP]](https://dblp.org/search?q=An%20architectural%20research%20facility%3A%20ISP%20descriptions%2C%20simulation%2C%20data%20collection)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=An%20architectural%20research%20facility%3A%20ISP%20descriptions%2C%20simulation%2C%20data%20collection)
[[doi]](https://doi.org/10.1145/1499402.1499435)
[[url]](https://doi.org/10.1145/1499402.1499435)

Notes: 
[ISPS](#ISPS)\



[ISPS]: #notes-isps
# ISP: A language to describe instruction sets and other register transfer systems {#papers-barbacci-cmu-1972}


Mario R. Barbacci, C. Gordon Bell, Allen C. Newell
Report
Carnegie Mellon University
January
1972
[[Google Scholar]](https://scholar.google.com/scholar?q=ISP%3A%20A%20language%20to%20describe%20instruction%20sets%20and%20other%20register%20transfer%20systems)
[[DBLP]](https://dblp.org/search?q=ISP%3A%20A%20language%20to%20describe%20instruction%20sets%20and%20other%20register%20transfer%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=ISP%3A%20A%20language%20to%20describe%20instruction%20sets%20and%20other%20register%20transfer%20systems)
[[url]](http://digitalcollections.library.cmu.edu/awweb/awarchive?type=file&item=360601)

Notes: 
[ISA specification](#ISA specification),
[ISPS](#ISPS)\
Papers: 
[bell:afips:1970](#bell-afips-1970)\
Referenced by: 
[papers/bell:afips:1970](#papers-bell-afips-1970),
[papers/bell:book:1971](#papers-bell-book-1971),
[notes/isps](#notes-isps)\




[ISA specification]: #notes-isa-specification
[ISPS]: #notes-isps
[bell:afips:1970]: #papers-bell-afips-1970
# PMS: A notation to describe computer structures {#papers-barbacci-computer-1973}


Mario R. Barbacci, C. Gordon Bell, Daniel P. Siewiorek
Pages 19-21
1973
[[Google Scholar]](https://scholar.google.com/scholar?q=PMS%3A%20A%20notation%20to%20describe%20computer%20structures)
[[DBLP]](https://dblp.org/search?q=PMS%3A%20A%20notation%20to%20describe%20computer%20structures)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=PMS%3A%20A%20notation%20to%20describe%20computer%20structures)
[[doi]](https://doi.org/10.1109/C-M.1973.217034)
[[url]](https://doi.org/10.1109/C-M.1973.217034)

Notes: 
[ISPS](#ISPS)\



[ISPS]: #notes-isps
# Evaluation of the CFA test programs via formal computer descriptions {#papers-barbacci-computer-1977}


Mario R. Barbacci, Daniel P. Siewiorek
Pages 36-43
1977
[[Google Scholar]](https://scholar.google.com/scholar?q=Evaluation%20of%20the%20CFA%20test%20programs%20via%20formal%20computer%20descriptions)
[[DBLP]](https://dblp.org/search?q=Evaluation%20of%20the%20CFA%20test%20programs%20via%20formal%20computer%20descriptions)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Evaluation%20of%20the%20CFA%20test%20programs%20via%20formal%20computer%20descriptions)
[[doi]](https://doi.org/10.1109/C-M.1977.217524)
[[url]](https://doi.org/10.1109/C-M.1977.217524)

Notes: 
[ISPS](#ISPS)\



[ISPS]: #notes-isps
# Using emulation to verify formal architecture descriptions {#papers-barbacci-computer-1978}


Mario R. Barbacci, Alan Parker
Pages 51-56
1978
[[Google Scholar]](https://scholar.google.com/scholar?q=Using%20emulation%20to%20verify%20formal%20architecture%20descriptions)
[[DBLP]](https://dblp.org/search?q=Using%20emulation%20to%20verify%20formal%20architecture%20descriptions)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Using%20emulation%20to%20verify%20formal%20architecture%20descriptions)
[[doi]](https://doi.org/10.1109/C-M.1978.218183)
[[url]](https://doi.org/10.1109/C-M.1978.218183)

Notes: 
[ISPS](#ISPS)\



[ISPS]: #notes-isps
# Instruction set processor specifications for simulation, evaluation, and synthesis {#papers-barbacci-dac-1979}


Mario R. Barbacci
Proceedings of the 16th Design Automation Conference, DAC '79, San Diego, California, USA, June 25-27, 1979
ACM
Pages 64-72
1979
[[Google Scholar]](https://scholar.google.com/scholar?q=Instruction%20set%20processor%20specifications%20for%20simulation%2C%20evaluation%2C%20and%20synthesis)
[[DBLP]](https://dblp.org/search?q=Instruction%20set%20processor%20specifications%20for%20simulation%2C%20evaluation%2C%20and%20synthesis)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Instruction%20set%20processor%20specifications%20for%20simulation%2C%20evaluation%2C%20and%20synthesis)
[[doi]](https://doi.org/10.1109/DAC.1979.1600090)
[[url]](http://dl.acm.org/citation.cfm?id=811693)

Notes: 
[ISPS](#ISPS)\



[ISPS]: #notes-isps
# Programming at the Processor-Memory-Switch level {#papers-barbacci-icse-1988}


Mario R. Barbacci, Charles B. Weinstock, Jeannette M. Wing
Proceedings, 10th International Conference on Software Engineering, Singapore, Singapore, April 11-15, 1988
IEEE Computer Society
Pages 19-29
1988
[[Google Scholar]](https://scholar.google.com/scholar?q=Programming%20at%20the%20Processor-Memory-Switch%20level)
[[DBLP]](https://dblp.org/search?q=Programming%20at%20the%20Processor-Memory-Switch%20level)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Programming%20at%20the%20Processor-Memory-Switch%20level)
[[doi]](https://doi.org/10.1109/ICSE.1988.93684)
[[url]](http://dl.acm.org/citation.cfm?id=55826)

Notes: 
[ISPS](#ISPS)\



[ISPS]: #notes-isps
# Instruction set processor specifications (ISPS): The notation and its applications {#papers-barbacci-ieee-1981}


Mario R. Barbacci
Pages 24-40
January
1981
[[Google Scholar]](https://scholar.google.com/scholar?q=Instruction%20set%20processor%20specifications%20%28ISPS%29%3A%20The%20notation%20and%20its%20applications)
[[DBLP]](https://dblp.org/search?q=Instruction%20set%20processor%20specifications%20%28ISPS%29%3A%20The%20notation%20and%20its%20applications)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Instruction%20set%20processor%20specifications%20%28ISPS%29%3A%20The%20notation%20and%20its%20applications)
[[doi]](https://doi.org/10.1109/TC.1981.6312154)

Notes: 
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture),
[ISPS](#ISPS)\
Papers: 
[bell:afips:1970](#bell-afips-1970)\
Referenced by: 
[papers/bell:afips:1970](#papers-bell-afips-1970),
[papers/bell:book:1971](#papers-bell-book-1971),
[notes/isps](#notes-isps)\




[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
[ISPS]: #notes-isps
[bell:afips:1970]: #papers-bell-afips-1970
# A comparison of register transfer languages for describing computers and digital systems {#papers-barbacci-ieeetc-1975}


Mario R. Barbacci
Pages 137-150
1975
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20comparison%20of%20register%20transfer%20languages%20for%20describing%20computers%20and%20digital%20systems)
[[DBLP]](https://dblp.org/search?q=A%20comparison%20of%20register%20transfer%20languages%20for%20describing%20computers%20and%20digital%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20comparison%20of%20register%20transfer%20languages%20for%20describing%20computers%20and%20digital%20systems)
[[doi]](https://doi.org/10.1109/T-C.1975.224181)
[[url]](https://doi.org/10.1109/T-C.1975.224181)

Notes: 
[ISPS](#ISPS)\



[ISPS]: #notes-isps
# Instruction set processor specifications (ISPS): The notation and its applications {#papers-barbacci-ieeetc-1981}


Mario R. Barbacci
Pages 24-40
1981
[[Google Scholar]](https://scholar.google.com/scholar?q=Instruction%20set%20processor%20specifications%20%28ISPS%29%3A%20The%20notation%20and%20its%20applications)
[[DBLP]](https://dblp.org/search?q=Instruction%20set%20processor%20specifications%20%28ISPS%29%3A%20The%20notation%20and%20its%20applications)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Instruction%20set%20processor%20specifications%20%28ISPS%29%3A%20The%20notation%20and%20its%20applications)
[[doi]](https://doi.org/10.1109/TC.1981.6312154)
[[url]](https://doi.org/10.1109/TC.1981.6312154)

Notes: 
[ISPS](#ISPS)\



[ISPS]: #notes-isps
# Automated exploration of the design space for register transfer (RT) systems {#papers-barbacci-isca-1973}


Mario R. Barbacci, Daniel P. Siewiorek
Proceedings of the 1st Annual Symposium on Computer Architecture, Gainesville, FL, USA, December 1973
ACM
Pages 101-106
1973
[[Google Scholar]](https://scholar.google.com/scholar?q=Automated%20exploration%20of%20the%20design%20space%20for%20register%20transfer%20%28RT%29%20systems)
[[DBLP]](https://dblp.org/search?q=Automated%20exploration%20of%20the%20design%20space%20for%20register%20transfer%20%28RT%29%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automated%20exploration%20of%20the%20design%20space%20for%20register%20transfer%20%28RT%29%20systems)
[[doi]](https://doi.org/10.1145/800123.803975)
[[url]](https://doi.org/10.1145/800123.803975)

Notes: 
[ISPS](#ISPS)\



[ISPS]: #notes-isps
# Specification and verification: The Spec# experience {#papers-barnett-cacm-2011}


Mike Barnett, Manuel Fähndrich, K. Rustan M. Leino, Peter Müller, Wolfram Schulte, Herman Venter
Association for Computing Machinery
New York, NY, USA
Pages 81-91
June
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=Specification%20and%20verification%3A%20The%20Spec%23%20experience)
[[DBLP]](https://dblp.org/search?q=Specification%20and%20verification%3A%20The%20Spec%23%20experience)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Specification%20and%20verification%3A%20The%20Spec%23%20experience)
[[doi]](https://doi.org/10.1145/1953122.1953145)
[[url]](https://doi.org/10.1145/1953122.1953145)

Notes: 
[spec-sharp-project](#spec-sharp-project),
[Boogie verifier](#Boogie verifier),
[contract driven development](#contract driven development)\
Papers: 
[barnett:cassis:2004](#barnett-cassis-2004),
[chatterjee:tacas:2007](#chatterjee-tacas-2007),
[fahndrich:foveoos:2010](#fahndrich-foveoos-2010),
[logozzo:vmcai:2011](#logozzo-vmcai-2011),
[barnett:fmco:2005](#barnett-fmco-2005),
[leino:tacas:2010](#leino-tacas-2010),
[demoura:tacas:2008](#demoura-tacas-2008)\
Referenced by: 
[papers/legoues:sefm:2011](#papers-legoues-sefm-2011)\


[Spec#][barnett:cassis:2004]
was a Microsoft Research project that added automated verification
to C# through the addition of method contracts, class invariants and
loop invariants.
This was all integrated into the Visual Studio IDE to make for a very
different user experience from normal verification: they wanted verification
to be integrated into the development flow.
This paper gives a retrospective on the project with a particular focus
on efforts to get the techniques adopted.

Spec# was an ambitious project with many different parts:

- Frontend: Visual Studio integration so that verification errors
  show up as "squigglies" under the offending code.

- Language: it was a superset of C# which brought advantages of a large
  codebase and userbase to try things on but tracking a large language
  as it evolves is hard and the language brings several problems of its
  own.

  ([HAVOC][chatterjee:tacas:2007]
  was a spinoff that applied some Spec# ideas to low-level C code.)

- Platform: their work built on Microsoft's .NET framework which gave
  them even more potential impact but also meant that Spec# code could
  be linked against programs written in other languages that did not
  have contracts.
  This lead to the development of a
  [language-neutral contract library][fahndrich:foveoos:2010],
  [see also logozzo:vmcai:2011][logozzo:vmcai:2011].

- Contracts that could be used for dynamic checking or static verification.
  An early goal was to integrate with established programming practice
  so a subset of their contract language can be checked dynamically.

  (Although different, this reminds me of [Executable
  ACSL](http://www.open-do.org/wp-content/uploads/2011/05/e-acsl.pdf).)

- One of the most frequent things stated in function contracts is whether
  a pointer can be null or not.
  So, by default, object references in Spec# are non-null and you have
  to explicitly request a nullable type.
  They strongly urge language designers to follow this model.

- Compiler integration: instead of extending the parser for C#, they
  verify the MSIL bytecode.  This requires them to reverse engineer
  some of the transformations that the compiler made and they would
  have benefited from having the compiler provide extra information
  to make this easier.

- Verification backend: the
  [Boogie Intermediate Verification Language][barnett:fmco:2005]
  was created to support Spec# but has been used in many other projects.
  (See also: [Boogie2][leino:tacas:2010].)
  And Boogie builds on [Z3][demoura:tacas:2008].

I have probably missed out a lot of important stuff – read the paper!



[spec-sharp-project]: #notes-spec-sharp-project
[Boogie verifier]: #notes-boogie-verifier
[contract driven development]: #notes-contract-driven-development
[barnett:cassis:2004]: #papers-barnett-cassis-2004
[chatterjee:tacas:2007]: #papers-chatterjee-tacas-2007
[fahndrich:foveoos:2010]: #papers-fahndrich-foveoos-2010
[logozzo:vmcai:2011]: #papers-logozzo-vmcai-2011
[barnett:fmco:2005]: #papers-barnett-fmco-2005
[leino:tacas:2010]: #papers-leino-tacas-2010
[demoura:tacas:2008]: #papers-demoura-tacas-2008
# The Spec# programming system: An overview {#papers-barnett-cassis-2004}


Mike Barnett, K. Rustan M. Leino, Wolfram Schulte
International Workshop on Construction and Analysis of Safe, Secure, and Interoperable Smart Devices
Springer
Pages 49-69
2004
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20Spec%23%20programming%20system%3A%20An%20overview)
[[DBLP]](https://dblp.org/search?q=The%20Spec%23%20programming%20system%3A%20An%20overview)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20Spec%23%20programming%20system%3A%20An%20overview)
[[doi]](https://doi.org/10.1007/978-3-540-30569-9_3)

Notes: 
[spec-sharp-project](#spec-sharp-project)\
Referenced by: 
[papers/barnett:cacm:2011](#papers-barnett-cacm-2011),
[papers/barnett:fmco:2005](#papers-barnett-fmco-2005)\




[spec-sharp-project]: #notes-spec-sharp-project
# Boogie: A modular reusable verifier for object-oriented programs {#papers-barnett-fmco-2005}


Mike Barnett, Bor-Yuh Evan Chang, Robert DeLine, Bart Jacobs, K. Rustan M. Leino
International Symposium on Formal Methods for Components and Objects
Springer
Pages 364-387
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=Boogie%3A%20A%20modular%20reusable%20verifier%20for%20object-oriented%20programs)
[[DBLP]](https://dblp.org/search?q=Boogie%3A%20A%20modular%20reusable%20verifier%20for%20object-oriented%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Boogie%3A%20A%20modular%20reusable%20verifier%20for%20object-oriented%20programs)
[[doi]](https://doi.org/10.1007/11804192_17)

Notes: 
[Boogie verifier](#Boogie verifier),
[Z3 solver](#Z3 solver),
[intermediate verification language](#intermediate verification language),
[verification condition generator](#verification condition generator),
[spec-sharp-project](#spec-sharp-project),
[modular verification](#modular verification),
[contract driven development](#contract driven development),
[SMACK verifier](#SMACK verifier),
[Corral verifier](#Corral verifier),
[abstract interpretation](#abstract interpretation)\
Papers: 
[rakamaric:cav:2014](#rakamaric-cav-2014),
[cohen:cav:2010](#cohen-cav-2010),
[leinenbach:fm:2009](#leinenbach-fm-2009),
[barnett:cassis:2004](#barnett-cassis-2004),
[filliatre:fem:2004](#filliatre-fem-2004)\
Referenced by: 
[papers/almeida:security:2016](#papers-almeida-security-2016),
[papers/baranowski:atva:2018](#papers-baranowski-atva-2018),
[papers/barnett:cacm:2011](#papers-barnett-cacm-2011),
[papers/legoues:sefm:2011](#papers-legoues-sefm-2011),
[papers/leino:lpair:2010](#papers-leino-lpair-2010),
[papers/muller:vmcai:2016](#papers-muller-vmcai-2016)\


Boogie factors verification of [Spec#][barnett:cassis:2004] programs into
- Generating the Intermediate Verification Language BoogiePL by encoding language semantics, using abstract interpretation and introducing ghost state.
- Verifying BoogiePL by generating Verification Conditions and proving them using "Simplify" (with plans of switch to "Zap").
This combination simplifies and separates the two tasks and allows use of abstract interpretation (good at calculating fixpoints) and theorem proving (good at handling quantification).

BoogiePL is a simple imperative language with fresh (unconstrained) variables, assume, assert, requires, ensures, function calls, heap and non-deterministic goto but no structured control.

A strength and a weakness is that functions calls are always verified by inserting the requires/ensures from the function spec not using the function definition itself. (The weakness is that this requires the creation of specs for every function.)

This builds on the authors' previous work on ESC Modula3/Java.
Simple loop invariants (especially those associated with object allocation/lifetime) are inferred to reduce need for trivial invariants.

The paper notes that separation of generation from proof is not always ideal because it leads to some duplication of reasoning support and it makes loop invariant generation harder.

Similar work is [Caduceus and its IVL "Why"][filliatre:fem:2004].
Used by
[SMACK][rakamaric:cav:2014]
[Hyper-V][cohen:cav:2010]
[VCC][leinenbach:fm:2009]
and others.



[Boogie verifier]: #notes-boogie-verifier
[Z3 solver]: #notes-z3-solver
[intermediate verification language]: #notes-intermediate-verification-language
[verification condition generator]: #notes-verification-condition-generator
[spec-sharp-project]: #notes-spec-sharp-project
[modular verification]: #notes-modular-verification
[contract driven development]: #notes-contract-driven-development
[SMACK verifier]: #notes-smack-verifier
[Corral verifier]: #notes-corral-verifier
[abstract interpretation]: #notes-abstract-interpretation
[rakamaric:cav:2014]: #papers-rakamaric-cav-2014
[cohen:cav:2010]: #papers-cohen-cav-2010
[leinenbach:fm:2009]: #papers-leinenbach-fm-2009
[barnett:cassis:2004]: #papers-barnett-cassis-2004
[filliatre:fem:2004]: #papers-filliatre-fem-2004
# The Spec# programming system: Challenges and directions {#papers-barnett-vstte-2005}


Mike Barnett, Robert DeLine, Manuel Fähndrich, Bart Jacobs, K. Rustan M. Leino, Wolfram Schulte, Herman Venter
Verified Software: Theories, Tools, Experiments: First IFIP TC 2/WG 2.3 Conference, VSTTE 2005, Zurich, Switzerland, October 10-13, 2005, Revised Selected Papers and Discussions
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 144-152
2008
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20Spec%23%20programming%20system%3A%20Challenges%20and%20directions)
[[DBLP]](https://dblp.org/search?q=The%20Spec%23%20programming%20system%3A%20Challenges%20and%20directions)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20Spec%23%20programming%20system%3A%20Challenges%20and%20directions)
[[doi]](https://doi.org/10.1007/978-3-540-69149-5\_16)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-69149-5)
[[url]](https://doi.org/10.1007/978-3-540-69149-5\_16)

Notes: 
[spec-sharp-project](#spec-sharp-project)\




[spec-sharp-project]: #notes-spec-sharp-project
# The oracle problem in software testing: A survey {#papers-barr-tse-2015}


Earl T. Barr, Mark Harman, Phil McMinn, Muzammil Shahbaz, Shin Yoo
Pages 507-525
May
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20oracle%20problem%20in%20software%20testing%3A%20A%20survey)
[[DBLP]](https://dblp.org/search?q=The%20oracle%20problem%20in%20software%20testing%3A%20A%20survey)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20oracle%20problem%20in%20software%20testing%3A%20A%20survey)
[[doi]](https://doi.org/10.1109/TSE.2014.2372785)

Notes: 
[survey](#survey)\



[survey]: #notes-survey
# A framework for cooperating decision procedures {#papers-barrett-cade-2000}


Clark W. Barrett, David L. Dill, Aaron Stump
International Conference on Automated Deduction
Springer
Pages 79-98
2000
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20framework%20for%20cooperating%20decision%20procedures)
[[DBLP]](https://dblp.org/search?q=A%20framework%20for%20cooperating%20decision%20procedures)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20framework%20for%20cooperating%20decision%20procedures)
[[doi]](https://doi.org/10.1007/10721959_6)

Notes: 
[SMT solver](#SMT solver)\
Referenced by: 
[notes/smt-solver](#notes-smt-solver)\




[SMT solver]: #notes-smt-solver
# CVC4 {#papers-barrett-cav-2011}


Clark W. Barrett, Christopher L. Conway, Morgan Deters, Liana Hadarean, Dejan Jovanović, Tim King, Andrew Reynolds, Cesare Tinelli
Proceedings of the 23rd International Conference on Computer Aided Verification (CAV '11)
Lecture Notes in Computer Science, volume 6806
Springer
Pages 171-177
July
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=CVC4)
[[DBLP]](https://dblp.org/search?q=CVC4)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=CVC4)
[[doi]](https://doi.org/10.1007/978-3-642-22110-1_14)

Notes: 
[CVC4 solver](#CVC4 solver),
[SMT solver](#SMT solver)\
Referenced by: 
[notes/cvc4-solver](#notes-cvc4-solver)\



[CVC4 solver]: #notes-cvc4-solver
[SMT solver]: #notes-smt-solver
# Proofs in satisfiability modulo theories {#papers-barrett-mlf-2015}


Clark W. Barrett, Leonardo de Moura, Pascal Fontaine
All about Proofs, Proofs for All
Mathematical Logic and Foundations, volume 55
College Publications
London, UK
Pages 23-44
January
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=Proofs%20in%20satisfiability%20modulo%20theories)
[[DBLP]](https://dblp.org/search?q=Proofs%20in%20satisfiability%20modulo%20theories)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Proofs%20in%20satisfiability%20modulo%20theories)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-84890-166-7)
[[url]](http://www.cs.stanford.edu/~barrett/pubs/BdMF15.pdf)

Notes: 
[SMT solver](#SMT solver)\
Papers: 
[stump:fmsd:2013](#stump-fmsd-2013),
[brummayer:sat:2010](#brummayer-sat-2010),
[mansur:arxiv:2020](#mansur-arxiv-2020)\
Referenced by: 
[papers/stump:fmsd:2013](#papers-stump-fmsd-2013),
[notes/smt-solver](#notes-smt-solver)\



[SMT solver]: #notes-smt-solver
[stump:fmsd:2013]: #papers-stump-fmsd-2013
[brummayer:sat:2010]: #papers-brummayer-sat-2010
[mansur:arxiv:2020]: #papers-mansur-arxiv-2020
# The Satisfiability Modulo Theories Library (SMT-LIB) {#papers-barrett-smtlib-2016}


Clark W. Barrett, Pascal Fontaine, Cesare Tinelli
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20Satisfiability%20Modulo%20Theories%20Library%20%28SMT-LIB%29)
[[DBLP]](https://dblp.org/search?q=The%20Satisfiability%20Modulo%20Theories%20Library%20%28SMT-LIB%29)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20Satisfiability%20Modulo%20Theories%20Library%20%28SMT-LIB%29)

Notes: 
[SMT solver](#SMT solver)\




[SMT solver]: #notes-smt-solver
# Secure information flow by self composition {#papers-barthe-csfw-2004}


Gilles Barthe, Pedro R. D'Argenio, Tamara Rezk
17th IEEE Computer Security Foundations Workshop, (CSFW-17 2004)
Pages 100-114
2004
[[Google Scholar]](https://scholar.google.com/scholar?q=Secure%20information%20flow%20by%20self%20composition)
[[DBLP]](https://dblp.org/search?q=Secure%20information%20flow%20by%20self%20composition)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Secure%20information%20flow%20by%20self%20composition)
[[doi]](https://doi.org/10.1109/CSFW.2004.17)

Notes: 
[information flow](#information flow),
[self composition](#self composition)\


This paper is a counter to the popular type-based approaches to information flow control.  They point out that type-based approaches are sound but not complete and fail on things like "output := secret; output := 0;".  Their solution is a more semantic approach that is based more closely on the basic definitions of non-interference and is sound and complete (but, unlike type-based approaches, is often undecidable and not obviously compositional).

"Self-composition" consists of proving 2-safety properties of a program "P" by reasoning about the program "P; P'" where "P'" is a copy of P with all variables renamed from x to x'.
(They make explicit the assumption that renaming a variable, adding a new variable, etc. does not affect the meaning — note that this may not be true if your program or language is not memory-safe.)

This approach can be used to enable Hoare-logic reasoning about pointer free programs, separation logic reasoning about programs with pointers, and model checking about non-deterministic programs.  (Other papers seem to have used similar definitions — the distinguishing feature of this paper seems to be the generality of their approach.)

Good paper for citation/discussion of related work.



[information flow]: #notes-information-flow
[self composition]: #notes-self-composition
# Provably secure compilation of side-channel countermeasures. {#papers-barthe-iacr-2007}


Gilles Barthe, Benjamin Grégoire, Vincent Laporte
Pages 38
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=Provably%20secure%20compilation%20of%20side-channel%20countermeasures.)
[[DBLP]](https://dblp.org/search?q=Provably%20secure%20compilation%20of%20side-channel%20countermeasures.)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Provably%20secure%20compilation%20of%20side-channel%20countermeasures.)

Notes: 
[information flow](#information flow),
[self-composition](#self-composition)\




[information flow]: #notes-information-flow
[self-composition]: #notes-self-composition
# Secure information flow by self-composition {#papers-barthe-mscs-2011}


Gilles Barthe, Pedro R. D'Argenio, Tamara Rezk
Cambridge University Press
Pages 1207-1252
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=Secure%20information%20flow%20by%20self-composition)
[[DBLP]](https://dblp.org/search?q=Secure%20information%20flow%20by%20self-composition)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Secure%20information%20flow%20by%20self-composition)
[[doi]](https://doi.org/10.1017/S0960129511000193)

Notes: 
[information flow](#information flow),
[self composition](#self composition)\



[information flow]: #notes-information-flow
[self composition]: #notes-self-composition
# Reliable and fast DWARF-based stack unwinding {#papers-bastian-oopsla-2019}


Théophile Bastian, Stephen Kell, Francesco Zappa Nardelli
ACM
Pages 146
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Reliable%20and%20fast%20DWARF-based%20stack%20unwinding)
[[DBLP]](https://dblp.org/search?q=Reliable%20and%20fast%20DWARF-based%20stack%20unwinding)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Reliable%20and%20fast%20DWARF-based%20stack%20unwinding)
[[doi]](https://doi.org/10.1145/3360572)





# Hardware is the new software {#papers-baumann-hotos-2017}


Andrew Baumann
Proceedings of the 16th Workshop on Hot Topics in Operating Systems
HotOS '17
Whistler, BC, Canada
ACM
New York, NY, USA
Pages 132-137
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=Hardware%20is%20the%20new%20software)
[[DBLP]](https://dblp.org/search?q=Hardware%20is%20the%20new%20software)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Hardware%20is%20the%20new%20software)
[[doi]](https://doi.org/10.1145/3102980.3103002)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-5068-6)

Notes: 
[instruction set architecture](#instruction set architecture),
[microarchitecture](#microarchitecture),
[security](#security),
[side channel](#side channel)\



[instruction set architecture]: #notes-instruction-set-architecture
[microarchitecture]: #notes-microarchitecture
[security]: #notes-security
[side channel]: #notes-side-channel
# Combining mechanized proofs and model-based testing in the formal analysis of a hypervisor {#papers-becker-fm-2016}


Hanno Becker, Juan Manuel Crespo, Jacek Galowicz, Ulrich Hensel, Yoichi Hirai, César Kunz, Keiko Nakata, Jorge Luis Sacchini, Hendrik Tews, Thomas Tuerk
International Symposium on Formal Methods
Springer
Pages 69-84
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Combining%20mechanized%20proofs%20and%20model-based%20testing%20in%20the%20formal%20analysis%20of%20a%20hypervisor)
[[DBLP]](https://dblp.org/search?q=Combining%20mechanized%20proofs%20and%20model-based%20testing%20in%20the%20formal%20analysis%20of%20a%20hypervisor)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Combining%20mechanized%20proofs%20and%20model-based%20testing%20in%20the%20formal%20analysis%20of%20a%20hypervisor)
[[doi]](https://doi.org/10.1007/978-3-319-48989-6_5)

Notes: 
[Coq theorem prover](#Coq theorem prover),
[NOVA hypervisor](#NOVA hypervisor)\
Referenced by: 
[papers/claessen:icfp:2000](#papers-claessen-icfp-2000),
[notes/nova-hypervisor](#notes-nova-hypervisor)\


Describes formal verification in Coq of a model of the commercial NOVA micro-hypervisor.
NOVA is a hypervisor in the L4 family that supports DMA access (protected
by IOMMU).
Very extensive testing is used to compare the model against the actual
implementation using over 12 million conformance tests.

The main properties proved are security properties: authority confinement, memory confinement.
To support this, they prove invariants:
a consistency invariant,
no dangling-pointers, 
semaphore consistency relating thread state to semaphore state,
...

This process found around 2 dozen bugs in the hypervisor source code.
Half were found during code review as part of the model construction process.
Half were found while debugging the model against the implementation.
In addition, they found roughly as many bugs in their model.
_It is not clear whether the construction of proofs found any bugs so I wonder
if N-version programming would have most of the same benefit (assuming that
the second version is written in an expressive high-level language)._

Not mentioned in the paper is that the project was cancelled due to a change in company plans.
Unusually, the affiliation on the paper says that the authors' employers wish to remain anonymous.



[Coq theorem prover]: #notes-coq-theorem-prover
[NOVA hypervisor]: #notes-nova-hypervisor
# The PMS and ISP descriptive systems for computer structures {#papers-bell-afips-1970}


C. Gordon Bell, Allen C. Newell
Proceedings of the May 5-7, 1970, Spring Joint Computer Conference
AFIPS '70 (Spring)
Atlantic City, New Jersey
ACM
New York, NY, USA
Pages 351-374
1970
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20PMS%20and%20ISP%20descriptive%20systems%20for%20computer%20structures)
[[DBLP]](https://dblp.org/search?q=The%20PMS%20and%20ISP%20descriptive%20systems%20for%20computer%20structures)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20PMS%20and%20ISP%20descriptive%20systems%20for%20computer%20structures)
[[doi]](https://doi.org/10.1145/1476936.1476993)

Notes: 
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture),
[ISPS](#ISPS)\
Papers: 
[barbacci:ieee:1981](#barbacci-ieee-1981),
[barbacci:cmu:1972](#barbacci-cmu-1972)\
Referenced by: 
[papers/barbacci:cmu:1972](#papers-barbacci-cmu-1972),
[papers/barbacci:ieee:1981](#papers-barbacci-ieee-1981),
[papers/bell:book:1971](#papers-bell-book-1971),
[notes/isps](#notes-isps)\



[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
[ISPS]: #notes-isps
[barbacci:ieee:1981]: #papers-barbacci-ieee-1981
[barbacci:cmu:1972]: #papers-barbacci-cmu-1972
# Computer structures: Readings and examples {#papers-bell-book-1971}


C. Gordon Bell, Allen C. Newell
McGraw-Hill Pub. Co.
1971
[[Google Scholar]](https://scholar.google.com/scholar?q=Computer%20structures%3A%20Readings%20and%20examples)
[[DBLP]](https://dblp.org/search?q=Computer%20structures%3A%20Readings%20and%20examples)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Computer%20structures%3A%20Readings%20and%20examples)
[[ISBN]](http://books.google.com/books?vid=ISBN0070043574)

Notes: 
[microarchitecture](#microarchitecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture),
[ISPS](#ISPS)\
Papers: 
[bell:afips:1970](#bell-afips-1970),
[barbacci:cmu:1972](#barbacci-cmu-1972),
[barbacci:ieee:1981](#barbacci-ieee-1981)\
Referenced by: 
[notes/isps](#notes-isps)\



[microarchitecture]: #notes-microarchitecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
[ISPS]: #notes-isps
[bell:afips:1970]: #papers-bell-afips-1970
[barbacci:cmu:1972]: #papers-barbacci-cmu-1972
[barbacci:ieee:1981]: #papers-barbacci-ieee-1981
# Bell's law for the birth and death of computer classes {#papers-bell-cacm-2008}


C. Gordon Bell
Association for Computing Machinery
New York, NY, USA
Pages 86-94
January
2008
[[Google Scholar]](https://scholar.google.com/scholar?q=Bell%27s%20law%20for%20the%20birth%20and%20death%20of%20computer%20classes)
[[DBLP]](https://dblp.org/search?q=Bell%27s%20law%20for%20the%20birth%20and%20death%20of%20computer%20classes)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Bell%27s%20law%20for%20the%20birth%20and%20death%20of%20computer%20classes)
[[doi]](https://doi.org/10.1145/1327452.1327453)
[[url]](https://doi.org/10.1145/1327452.1327453)

Referenced by: 
[papers/bell:procieee:2014](#papers-bell-procieee-2014)\


This paper argues that "A new computer class forms and approximately doubles
each decade, establishing a new industry." and names this "Bell's Law".
This is a consequence of Moore's Law decreasing the price of computer
hardware and "intense, competitive entrepreneurial action."

This is illustrated by the history of
mainframes in the early '50s,
minicomputers in the late '50s,
supercomputers in the '60s,
home computers (initially based on 8-bit microprocessors) in the later '70s,
...



# STARS: Rise and fall of minicomputers [scanning our past] {#papers-bell-procieee-2014}


C. Gordon Bell
Pages 629-638
April
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=STARS%3A%20Rise%20and%20fall%20of%20minicomputers%20%5Bscanning%20our%20past%5D)
[[DBLP]](https://dblp.org/search?q=STARS%3A%20Rise%20and%20fall%20of%20minicomputers%20%5Bscanning%20our%20past%5D)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=STARS%3A%20Rise%20and%20fall%20of%20minicomputers%20%5Bscanning%20our%20past%5D)
[[doi]](https://doi.org/10.1109/JPROC.2014.2306257)

Notes: 
[survey](#survey)\
Papers: 
[bell:cacm:2008](#bell-cacm-2008)\


This describes the history of minicomputers from the late '50s through to the '80s.
One of the things I found fascinating (because I had not heard it before) is
that many minicomputers were sold to OEMs who incorporated the minis into
products where they were used for industrial control and things like that.
The paper argues that we should distinguish these "classic minicomputers"
from minicomputers that are defined more by their price relative to mainframes.




[survey]: #notes-survey
[bell:cacm:2008]: #papers-bell-cacm-2008
# Symbolic execution with separation logic {#papers-berdine-aplas-2005}


Josh Berdine, Cristiano Calcagno, Peter W. O'Hearn
Programming Languages and Systems
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 52-68
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=Symbolic%20execution%20with%20separation%20logic)
[[DBLP]](https://dblp.org/search?q=Symbolic%20execution%20with%20separation%20logic)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Symbolic%20execution%20with%20separation%20logic)
[[doi]](https://doi.org/10.1007/11575467_5)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-32247-4)

Notes: 
[permission logic](#permission logic),
[separation logic](#separation logic),
[smallfoot verifier](#smallfoot verifier),
[symbolic execution](#symbolic execution)\
Papers: 
[berdine:fmco:2005](#berdine-fmco-2005)\
Referenced by: 
[papers/berdine:fmco:2005](#papers-berdine-fmco-2005)\


This paper describes the proof-theoretic basis for the
Smallfoot verification tool described in a
[companion paper][berdine:fmco:2005].
See the other paper for a description.





[permission logic]: #notes-permission-logic
[separation logic]: #notes-separation-logic
[smallfoot verifier]: #notes-smallfoot-verifier
[symbolic execution]: #notes-symbolic-execution
[berdine:fmco:2005]: #papers-berdine-fmco-2005
# Smallfoot: Modular automatic assertion checking with separation logic {#papers-berdine-fmco-2005}


Josh Berdine, Cristiano Calcagno, Peter W. O'Hearn
Formal Methods for Components and Objects
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 115-137
2006
[[Google Scholar]](https://scholar.google.com/scholar?q=Smallfoot%3A%20Modular%20automatic%20assertion%20checking%20with%20separation%20logic)
[[DBLP]](https://dblp.org/search?q=Smallfoot%3A%20Modular%20automatic%20assertion%20checking%20with%20separation%20logic)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Smallfoot%3A%20Modular%20automatic%20assertion%20checking%20with%20separation%20logic)
[[doi]](https://doi.org/10.1007/11804192_6)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-36750-5)

Notes: 
[separation logic](#separation logic),
[permission logic](#permission logic),
[smallfoot verifier](#smallfoot verifier),
[symbolic execution](#symbolic execution),
[VeriFast verifier](#VeriFast verifier)\
Papers: 
[berdine:aplas:2005](#berdine-aplas-2005),
[jacobs:nfm:2011](#jacobs-nfm-2011),
[parkinson:popl:2005](#parkinson-popl-2005),
[bornat:popl:2005](#bornat-popl-2005)\
Referenced by: 
[papers/berdine:aplas:2005](#papers-berdine-aplas-2005),
[papers/calcagno:popl:2009](#papers-calcagno-popl-2009)\


Smallfoot is a tool for automatically verifying both sequential
and concurrent heap-manipulating programs
that is based on (concurrent) separation logic and symbolic
execution.
The proof theoretic foundations of the tool are described
in a
[companion paper][berdine:aplas:2005].

One of the key tricks in enabling automation is to greatly
simplify the expressive power of the logic so that the
symbolic state consists of a set of pure formulae
about non-heap values plus a list of spatial formulae
that describe the heap.

The paper explicitly avoids describing how conditionals are handled but,
I believe that it works like the later
[VeriFast][jacobs:nfm:2011]
by path splitting: separately exploring the path that
starts with the "then" branch and the path that starts with the "else" branch.
This seems to be necessary because there is no mention of what to do at join
points and because there seems to be no way to represent disjunctions of
spatial formulae.

The version of Smallfoot described here did not have support for

- [defining predicates][parkinson:popl:2005].
  Instead predicates for lists, trees and xor-lists were hardwired in the tool.
- [permission accounting][bornat:popl:2005]

And there seems to be no arithmetic in the examples so I suspect
that it was not using an SMT solver in the background.



[separation logic]: #notes-separation-logic
[permission logic]: #notes-permission-logic
[smallfoot verifier]: #notes-smallfoot-verifier
[symbolic execution]: #notes-symbolic-execution
[VeriFast verifier]: #notes-verifast-verifier
[berdine:aplas:2005]: #papers-berdine-aplas-2005
[jacobs:nfm:2011]: #papers-jacobs-nfm-2011
[parkinson:popl:2005]: #papers-parkinson-popl-2005
[bornat:popl:2005]: #papers-bornat-popl-2005
# The Midway distributed shared memory system {#papers-bershad-cmpcon-1993}


Brian N. Bershad, Matthew J. Zekauskas, Wayne A. Sawdon
Digest of Papers, Compcon Spring
1993
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20Midway%20distributed%20shared%20memory%20system)
[[DBLP]](https://dblp.org/search?q=The%20Midway%20distributed%20shared%20memory%20system)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20Midway%20distributed%20shared%20memory%20system)
[[doi]](https://doi.org/10.1109/CMPCON.1993.289730)

Notes: 
[distributed shared memory](#distributed shared memory)\



[distributed shared memory]: #notes-distributed-shared-memory
# An approach to systems verification {#papers-bevier-jar-1989}


William R. Bevier, Warren A. Hunt Jr., J. Strother Moore, William D. Young
Pages 411-428
01
December
1989
[[Google Scholar]](https://scholar.google.com/scholar?q=An%20approach%20to%20systems%20verification)
[[DBLP]](https://dblp.org/search?q=An%20approach%20to%20systems%20verification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=An%20approach%20to%20systems%20verification)
[[doi]](https://doi.org/10.1007/BF00243131)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# TestCov: Robust test-suite execution and coverage measurement {#papers-beyer-ase-2019}


Dirk Beyer, Thomas Lemberger
2019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)
Pages 1074-1077
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=TestCov%3A%20Robust%20test-suite%20execution%20and%20coverage%20measurement)
[[DBLP]](https://dblp.org/search?q=TestCov%3A%20Robust%20test-suite%20execution%20and%20coverage%20measurement)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=TestCov%3A%20Robust%20test-suite%20execution%20and%20coverage%20measurement)
[[doi]](https://doi.org/10.1109/ASE.2019.00105)

Notes: 
[Test competition](#Test competition),
[KLEE verifier](#KLEE verifier),
[Fuzz testing](#Fuzz testing),
[FQL](#FQL)\
Papers: 
[beyer:hvc:2017](#beyer-hvc-2017)\
Referenced by: 
[notes/test-competition](#notes-test-competition)\


TestCov is a tool that measures the coverage of a test suites
and generates a reduced test suite.
It is used in the [Test competition] and can work with
all the tools that compete in that competition.

The input is a test suite (in the test suite interchange format (XML)),
a program and a specification of the coverage criterion (in [FQL]).

The tool is based on BenchExec and provides containerization (like Docker)
using Cgroups, etc.
so that program runs are isolated from each other.
The containerization has another benefit: it uses an in-memory filesystem
that is faster than a standard filesystem and so speeds up program execution.

The [testcov](https://gitlab.com/sosy-lab/software/test-suite-validator)
tool inserts instrumentation to measure block, branch and condition
coverage as well as calls to an error function.



[Test competition]: #notes-test-competition
[KLEE verifier]: #notes-klee-verifier
[Fuzz testing]: #notes-fuzz-testing
[FQL]: #notes-fql
[beyer:hvc:2017]: #papers-beyer-hvc-2017
# CPAchecker: A tool for configurable software verification {#papers-beyer-cav-2011}


Dirk Beyer, M. Erkan Keremoglu
Proceedings of the 23rd International Conference on Computer Aided Verification (CAV 2011, Snowbird, UT, July 14-20)
LNCS 6806
Springer-Verlag, Heidelberg
Pages 184-190
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=CPAchecker%3A%20A%20tool%20for%20configurable%20software%20verification)
[[DBLP]](https://dblp.org/search?q=CPAchecker%3A%20A%20tool%20for%20configurable%20software%20verification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=CPAchecker%3A%20A%20tool%20for%20configurable%20software%20verification)
[[doi]](https://doi.org/10.1007/978-3-642-22110-1_16)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-22109-5)
[[url]](https://cpachecker.sosy-lab.org)

Notes: 
[model checking](#model checking),
[SV competition](#SV competition),
[extended static checking](#extended static checking),
[CPAchecker verifier](#CPAchecker verifier)\
Papers: 
[beyer:ijsttt:2007](#beyer-ijsttt-2007)\
Referenced by: 
[notes/cpachecker-verifier](#notes-cpachecker-verifier)\



[model checking]: #notes-model-checking
[SV competition]: #notes-sv-competition
[extended static checking]: #notes-extended-static-checking
[CPAchecker verifier]: #notes-cpachecker-verifier
[beyer:ijsttt:2007]: #papers-beyer-ijsttt-2007
# Software verification: Testing vs. model checking {#papers-beyer-hvc-2017}


Dirk Beyer, Thomas Lemberger
Hardware and Software: Verification and Testing
Springer International Publishing
Cham
Pages 99-114
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=Software%20verification%3A%20Testing%20vs.%20model%20checking)
[[DBLP]](https://dblp.org/search?q=Software%20verification%3A%20Testing%20vs.%20model%20checking)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Software%20verification%3A%20Testing%20vs.%20model%20checking)
[[doi]](https://doi.org/10.1007/978-3-319-70389-3_7)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-319-70389-3)

Notes: 
[FQL](#FQL),
[Fuzz testing](#Fuzz testing),
[Test Competition](#Test Competition),
[SV Competition](#SV Competition),
[KLEE Verifier](#KLEE Verifier),
[CBMC Verifier](#CBMC Verifier)\
Papers: 
[holzer:cav:2008](#holzer-cav-2008),
[holzer:hvc:2010](#holzer-hvc-2010),
[cadar:cacm:2013](#cadar-cacm-2013)\
Referenced by: 
[papers/beyer:ase:2019](#papers-beyer-ase-2019)\


Compare test generators against model checkers.
The test generators are AFL-Fuzz, CPATiger, CREST-PPC, FShell, [KLEE verifier] and PRTest.
The model checkers are [CBMC verifier], CPA-seq, ESBMC-incr, ESBMC-kInd.

The benchmarks are all from the [SV competition].
These consist of 1490 programs with exactly one bug and 4293 programs with no
bugs.
The model checkers were developed using this benchmark suite to evaluate them
and the suite was designed to evaluate model checkers so there is some bias
in the choice of benchmarks.
Of the programs with one bug, 375 of them have some symbolic stub functions
that make them unusable with test programs.

To enable the comparision, all the tools were given a common interface
to convert tests into a standard format and to generate witnesses.

The results are presented in a cactus plot (as in [SV competition])
and then broken down in more detail in a table.
The clear winners are the model checkers although [KLEE verifier] is
competitive.
Well regarded fuzz testers like AFL-Fuzz find less than 80% of the bugs
found by the works of the model checkers. (That is 80% after excluding
the benchmarks that include symbolic stub functions.)

The results also present the total number of bugs found by all testers,
by all model checkers and by all tools.

- All the testers find around 7% more bugs than the best tester ([KLEE
  verifier]).
- All the model checkers find about 12-15% more bugs than the best
  model checker (ESBMC-incr).
- All the tools find 20-25% more bugs than the best tool (ESBMC-incr).

The observation that all the tools are better than the best tools
is an argument for portfolio test generators and hybrid fuzzer/model-checkers.



[FQL]: #notes-fql
[Fuzz testing]: #notes-fuzz-testing
[Test Competition]: #notes-test-competition
[SV Competition]: #notes-sv-competition
[KLEE Verifier]: #notes-klee-verifier
[CBMC Verifier]: #notes-cbmc-verifier
[holzer:cav:2008]: #papers-holzer-cav-2008
[holzer:hvc:2010]: #papers-holzer-hvc-2010
[cadar:cacm:2013]: #papers-cadar-cacm-2013
# Putting it all together - Formal verification of the VAMP {#papers-beyer-ijsttt-2006}


Sven Beyer, Christian Jacobi, Daniel Kröning, Dirk Leinenbach, Wolfgang J. Paul
Pages 411-430
01
August
2006
[[Google Scholar]](https://scholar.google.com/scholar?q=Putting%20it%20all%20together%20-%20Formal%20verification%20of%20the%20VAMP)
[[DBLP]](https://dblp.org/search?q=Putting%20it%20all%20together%20-%20Formal%20verification%20of%20the%20VAMP)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Putting%20it%20all%20together%20-%20Formal%20verification%20of%20the%20VAMP)
[[doi]](https://doi.org/10.1007/s10009-006-0204-6)

Notes: 
[ISA specification](#ISA specification),
[CPU verification](#CPU verification),
[PVS theorem prover](#PVS theorem prover)\



[ISA specification]: #notes-isa-specification
[CPU verification]: #notes-cpu-verification
[PVS theorem prover]: #notes-pvs-theorem-prover
# The software model checker BLAST: Applications to software engineering {#papers-beyer-ijsttt-2007}


Dirk Beyer, Thomas A. Henzinger, Ranjit Jhala, Rupak Majumdar
Pages 505-525
2007
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20software%20model%20checker%20BLAST%3A%20Applications%20to%20software%20engineering)
[[DBLP]](https://dblp.org/search?q=The%20software%20model%20checker%20BLAST%3A%20Applications%20to%20software%20engineering)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20software%20model%20checker%20BLAST%3A%20Applications%20to%20software%20engineering)
[[doi]](https://doi.org/10.1007/s10009-007-0044-z)

Notes: 
[SV competition](#SV competition),
[extended static checking](#extended static checking),
[model checking](#model checking),
[BLAST verifier](#BLAST verifier)\
Papers: 
[beyer:sas:2004](#beyer-sas-2004)\
Referenced by: 
[papers/beyer:cav:2011](#papers-beyer-cav-2011),
[papers/beyer:sas:2004](#papers-beyer-sas-2004),
[notes/blast-verifier](#notes-blast-verifier)\



[SV competition]: #notes-sv-competition
[extended static checking]: #notes-extended-static-checking
[model checking]: #notes-model-checking
[BLAST verifier]: #notes-blast-verifier
[beyer:sas:2004]: #papers-beyer-sas-2004
# The BLAST query language for software verification {#papers-beyer-sas-2004}


Dirk Beyer, Adam J. Chlipala, Thomas A. Henzinger, Ranjit Jhala, Rupak Majumdar
Proceedings of the 11th International Static Analysis Symposium (SAS 2004, Verona, August 26-28)
LNCS 3148
Springer-Verlag, Heidelberg
Pages 2-18
2004
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20BLAST%20query%20language%20for%20software%20verification)
[[DBLP]](https://dblp.org/search?q=The%20BLAST%20query%20language%20for%20software%20verification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20BLAST%20query%20language%20for%20software%20verification)
[[ISBN]](http://books.google.com/books?vid=ISBN3-540-22791-1)

Notes: 
[model checking](#model checking),
[BLAST verifier](#BLAST verifier)\
Papers: 
[beyer:ijsttt:2007](#beyer-ijsttt-2007)\
Referenced by: 
[papers/beyer:ijsttt:2007](#papers-beyer-ijsttt-2007),
[notes/blast-verifier](#notes-blast-verifier)\



[model checking]: #notes-model-checking
[BLAST verifier]: #notes-blast-verifier
[beyer:ijsttt:2007]: #papers-beyer-ijsttt-2007
# Symbolic model checking without BDDs {#papers-biere-tacas-1999}


Armin Biere, Alessandro Cimatti, Edmund M. Clarke, Yunshan Zhu
Tools and Algorithms for the Construction and Analysis of Systems: 5th International Conference, TACAS'99 Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS'99 Amsterdam, The Netherlands, March 22-28, 1999 Proceedings
Springer
Berlin, Heidelberg
Pages 193-207
1999
[[Google Scholar]](https://scholar.google.com/scholar?q=Symbolic%20model%20checking%20without%20BDDs)
[[DBLP]](https://dblp.org/search?q=Symbolic%20model%20checking%20without%20BDDs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Symbolic%20model%20checking%20without%20BDDs)
[[doi]](https://doi.org/10.1007/3-540-49059-0_14)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-49059-3)

Notes: 
[model checking](#model checking),
[bounded model checking](#bounded model checking),
[bounded verification](#bounded verification)\




[model checking]: #notes-model-checking
[bounded model checking]: #notes-bounded-model-checking
[bounded verification]: #notes-bounded-verification
# The effectiveness of decoupling {#papers-bird-sc-1993}


Peter L. Bird, Alasdair Rawsthorne, Nigel P. Topham
International Conference on Supercomputing
Pages 47-56
1993
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20effectiveness%20of%20decoupling)
[[DBLP]](https://dblp.org/search?q=The%20effectiveness%20of%20decoupling)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20effectiveness%20of%20decoupling)
[[doi]](https://doi.org/10.1145/165939.165952)

Notes: 
[pipeline parallelism](#pipeline parallelism),
[decoupling](#decoupling),
[microarchitecture](#microarchitecture)\



[pipeline parallelism]: #notes-pipeline-parallelism
[decoupling]: #notes-decoupling
[microarchitecture]: #notes-microarchitecture
# Implementing remote procedure calls {#papers-birrell-tocs-1984}


Andrew D. Birrell, Bruce Jay Nelson
ACM Press
Pages 39-59
1984
[[Google Scholar]](https://scholar.google.com/scholar?q=Implementing%20remote%20procedure%20calls)
[[DBLP]](https://dblp.org/search?q=Implementing%20remote%20procedure%20calls)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Implementing%20remote%20procedure%20calls)
[[doi]](https://doi.org/10.1145/2080.357392)

Notes: 
[remote procedure call](#remote procedure call)\
Referenced by: 
[notes/remote-procedure-call](#notes-remote-procedure-call)\



[remote procedure call]: #notes-remote-procedure-call
# A case study on formal verification of the Anaxagoros hypervisor paging system with Frama-C {#papers-blanchard-fmics-2015}


Allan Blanchard, Nikolai Kosmatov, Matthieu Lemerre, Frédéric Loulergue
International Workshop on Formal Methods for Industrial Critical Systems
Springer
Pages 15-30
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20case%20study%20on%20formal%20verification%20of%20the%20Anaxagoros%20hypervisor%20paging%20system%20with%20Frama-C)
[[DBLP]](https://dblp.org/search?q=A%20case%20study%20on%20formal%20verification%20of%20the%20Anaxagoros%20hypervisor%20paging%20system%20with%20Frama-C)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20case%20study%20on%20formal%20verification%20of%20the%20Anaxagoros%20hypervisor%20paging%20system%20with%20Frama-C)
[[doi]](https://doi.org/10.1007/978-3-319-19458-5_2)

Notes: 
[Frama-C verifier](#Frama-C verifier)\




[Frama-C verifier]: #notes-frama-c-verifier
# Designing a CPU model: from a pseudo-formal document to fast code {#papers-blanqui-rapido-2011}


Frédéric Blanqui, Claude Helmstetter, Vania Joloboff, Jean-François Monin, Xiaomu Shi
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=Designing%20a%20CPU%20model%3A%20from%20a%20pseudo-formal%20document%20to%20fast%20code)
[[DBLP]](https://dblp.org/search?q=Designing%20a%20CPU%20model%3A%20from%20a%20pseudo-formal%20document%20to%20fast%20code)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Designing%20a%20CPU%20model%3A%20from%20a%20pseudo-formal%20document%20to%20fast%20code)
[[url]](http://arxiv.org/abs/1109.4351)

Notes: 
[ISA specification](#ISA specification)\



[ISA specification]: #notes-isa-specification
# Vector models for data-parallel computing {#papers-blelloch-book-1990}


Guy E. Blelloch
MIT Press
Cambridge, MA, USA
1990
[[Google Scholar]](https://scholar.google.com/scholar?q=Vector%20models%20for%20data-parallel%20computing)
[[DBLP]](https://dblp.org/search?q=Vector%20models%20for%20data-parallel%20computing)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Vector%20models%20for%20data-parallel%20computing)
[[ISBN]](http://books.google.com/books?vid=ISBN0-262-02313-X)

Notes: 
[vector architecture](#vector architecture),
[data parallelism](#data parallelism)\



[vector architecture]: #notes-vector-architecture
[data parallelism]: #notes-data-parallelism
# Witnessing the elimination of magic wands {#papers-blom-ijsttt-2015}


Stefan Blom, Marieke Huisman
Springer
Pages 757-781
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=Witnessing%20the%20elimination%20of%20magic%20wands)
[[DBLP]](https://dblp.org/search?q=Witnessing%20the%20elimination%20of%20magic%20wands)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Witnessing%20the%20elimination%20of%20magic%20wands)
[[doi]](https://doi.org/10.1007/s10009-015-0372-3)

Notes: 
[magic wand](#magic wand),
[permission logic](#permission logic),
[Prusti verifier](#Prusti verifier),
[Viper verifier](#Viper verifier)\
Referenced by: 
[notes/magic-wand](#notes-magic-wand)\


todo: summarize this paper

This support for [magic wand]s has subsequently been implemented in the [Viper verifier] (an
[intermediate verification language]) and is used in the [Prusti verifier].



[magic wand]: #notes-magic-wand
[permission logic]: #notes-permission-logic
[Prusti verifier]: #notes-prusti-verifier
[Viper verifier]: #notes-viper-verifier
# A trusted mechanised JavaScript specification {#papers-bodin-popl-2014}


Martin Bodin, Arthur Chargueraud, Daniele Filaretti, Philippa Gardner, Sergio Maffeis, Daiva Naudziuniene, Alan Schmitt, Gareth Smith
Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
POPL '14
San Diego, California, USA
ACM
New York, NY, USA
Pages 87-100
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20trusted%20mechanised%20JavaScript%20specification)
[[DBLP]](https://dblp.org/search?q=A%20trusted%20mechanised%20JavaScript%20specification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20trusted%20mechanised%20JavaScript%20specification)
[[doi]](https://doi.org/10.1145/2535838.2535876)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-2544-8)

Notes: 
[JavaScript](#JavaScript),
[formal specification](#formal specification)\
Referenced by: 
[notes/javascript](#notes-javascript)\



[JavaScript]: #notes-javascript
[formal specification]: #notes-formal-specification
# Advanced SIMD: Extending the reach of contemporary SIMD architectures {#papers-boettcher-date-2014}


Matthias Boettcher, Bashir M. Al-Hashimi, Mbou Eyole, Giacomo Gabrielli, Alastair D. Reid
Design, Automation & Test in Europe Conference & Exhibition (DATE 2014)
Dresden, Germany
European Design and Automation Association
Pages 1-4
24-28
March
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=Advanced%20SIMD%3A%20Extending%20the%20reach%20of%20contemporary%20SIMD%20architectures)
[[DBLP]](https://dblp.org/search?q=Advanced%20SIMD%3A%20Extending%20the%20reach%20of%20contemporary%20SIMD%20architectures)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Advanced%20SIMD%3A%20Extending%20the%20reach%20of%20contemporary%20SIMD%20architectures)
[[doi]](https://doi.org/10.7873/DATE.2014.037)

Notes: 
[Arm architecture](#Arm architecture),
[SIMD](#SIMD),
[vector architecture](#vector architecture),
[instruction set architecture](#instruction set architecture)\




[Arm architecture]: #notes-arm-architecture
[SIMD]: #notes-simd
[vector architecture]: #notes-vector-architecture
[instruction set architecture]: #notes-instruction-set-architecture
# Fuzzing: On the exponential cost of vulnerability discovery {#papers-bohme2-fse-2020}


Marcel Böhme, Brandon Falk
Proceedings of the 2020 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering
Pages 11
2020
[[Google Scholar]](https://scholar.google.com/scholar?q=Fuzzing%3A%20On%20the%20exponential%20cost%20of%20vulnerability%20discovery)
[[DBLP]](https://dblp.org/search?q=Fuzzing%3A%20On%20the%20exponential%20cost%20of%20vulnerability%20discovery)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Fuzzing%3A%20On%20the%20exponential%20cost%20of%20vulnerability%20discovery)

Notes: 
[fuzz testing](#fuzz testing)\


Using a large empirical study of fuzzing (using AFL and libFuzzer),
this paper explores the cost of finding vulnerabilities (or
increasing coverage).

They produce some empirical laws:

- Random fuzzers take exponentially more time to find each
  additional vulnerability.
  "Intuitively, when collecting baseball cards, the first
  couple of cards are easy to find, but collecting the next
  new card gets progressively more difficult."

- Finding the same vulnerabilities in half the time requires
  only half as many machines.
  "Intuitively, if each day you buy twice as many packs of
  baseball cards, you could have collected the same cards that
  you now have in half the time."

These both assume zero cost for synchronization across fuzzers
running in parallel.
In an experiment with greybox fuzzers where the fuzzers shared
their seeds as they discovered them and where they did
not share seeds, they found that sharing significantly improved
discovery rate.

They also produce mathematical models to help explain the patterns in their
empirical data.
A key part of those models is an assumption of a power-law distribution
of bugs/features.

Their models are for purely random (blackbox) fuzzers but they suggest that, in
the limit, graybox fuzzers turn into random fuzzers.




[fuzz testing]: #notes-fuzz-testing
# Boosting fuzzer efficiency: An information theoretic perspective {#papers-bohme-fse-2020}


Marcel Böhme, Valentin Manes, Sang Kil Cha
Proceedings of the 2020 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering
Pages 11
2020
[[Google Scholar]](https://scholar.google.com/scholar?q=Boosting%20fuzzer%20efficiency%3A%20An%20information%20theoretic%20perspective)
[[DBLP]](https://dblp.org/search?q=Boosting%20fuzzer%20efficiency%3A%20An%20information%20theoretic%20perspective)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Boosting%20fuzzer%20efficiency%3A%20An%20information%20theoretic%20perspective)

Notes: 
[fuzz testing](#fuzz testing),
[entropy](#entropy)\


Greybox fuzzers prioritise which seeds to explore in order to (hopefully)
maximise some metric such as coverage.
This paper proposes an information theoretic model (entropy) for evaluating the
effectiveness of each seed.
This forms the basis of an "entropy based power schedule" to assign more energy
to the seeds that elicit the most information.
The approach is inspired by "Active SLAM": an approach for autonomous robot
exploration of unknown terrain.

Some of the challenges they face are

- The theory best handles situations where each exploration learns zero
  or one facts at a time and needs normalization if a single exploration can
  discover multiple new things.
  (This deviates slightly from information theory?)

- When a new seed is introduced, we don't know its entropy so we should
  use an initial estimate that is too high (so that the seed gets scheduled)
  instead of too low (causing us never to schedule the seed which prevents
  us from learning the entropy).

- A few facts are superabundant (I think this is basically the first few
  branches in the program or maybe frequently called functions like printf?)
  and so whichever seed first runs will be credited
  with learning facts that any other seed could have found as easily.
  This is handled by introducing a "global abundance threshold": any facts
  that are more abundant than the threshold are ignored when calculating
  entropy.

The ideas in this paper were tried in Google's LibFuzzer and the small changes
(350 lines) are being merged into LibFuzzer.
The evaluation has four clearly stated research questions that are evaluated
on a large body of fuzzing benchmarks.



[fuzz testing]: #notes-fuzz-testing
[entropy]: #notes-entropy
# Permission accounting in separation logic {#papers-bornat-popl-2005}


Richard Bornat, Cristiano Calcagno, Peter W. O'Hearn, Matthew Parkinson
Proceedings of the 32nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
POPL '05
Long Beach, California, USA
Association for Computing Machinery
New York, NY, USA
Pages 259-270
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=Permission%20accounting%20in%20separation%20logic)
[[DBLP]](https://dblp.org/search?q=Permission%20accounting%20in%20separation%20logic)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Permission%20accounting%20in%20separation%20logic)
[[doi]](https://doi.org/10.1145/1040305.1040327)
[[ISBN]](http://books.google.com/books?vid=ISBN158113830X)
[[url]](https://doi.org/10.1145/1040305.1040327)

Notes: 
[permission logic](#permission logic),
[separation logic](#separation logic),
[permission accounting](#permission accounting),
[fractional permissions](#fractional permissions)\
Referenced by: 
[papers/berdine:fmco:2005](#papers-berdine-fmco-2005),
[papers/heule:ftfjp:2011](#papers-heule-ftfjp-2011),
[papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011),
[papers/muller:vmcai:2016](#papers-muller-vmcai-2016),
[notes/fractional-permissions](#notes-fractional-permissions),
[notes/permission-accounting](#notes-permission-accounting)\


Separation logic is about tracking ownership of objects
and, usually, this means full ownership: you either own
an object and can do anything you want with it or
you have no access at all.
This paper is about sharing ownership as in the reader-writer
pattern where an object can be shared between several readers
or ownership can be given to a single writer.

The paper explores two ways of doing this:

1. Using fractional permissions where ownership can be split
   into several parts and can be recombined later.
   (This seems to be best for recursive functions?)

2. Using counting permissions where the number of readers is
   tracked.

The main technical trick used in adding this to the logic is to
change from modelling the heap as a map from addresses to values
but, instead, as a map from addresses to pairs of values and
permissions and permissions are either a fraction or a count.

Besides the technical content, the writing style of the author
stands out. Beyond the innocent sounding fact that it is written
in the first person, the style is very hard to describe – you
need to read it for yourself.



[permission logic]: #notes-permission-logic
[separation logic]: #notes-separation-logic
[permission accounting]: #notes-permission-accounting
[fractional permissions]: #notes-fractional-permissions
# Finding code that explodes under symbolic evaluation {#papers-bornholt-oopsla-2018}


James Bornholt, Emina Torlak
Association for Computing Machinery
New York, NY, USA
October
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=Finding%20code%20that%20explodes%20under%20symbolic%20evaluation)
[[DBLP]](https://dblp.org/search?q=Finding%20code%20that%20explodes%20under%20symbolic%20evaluation)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Finding%20code%20that%20explodes%20under%20symbolic%20evaluation)
[[doi]](https://doi.org/10.1145/3276519)
[[url]](https://doi.org/10.1145/3276519)

Notes: 
[symbolic evaluation](#symbolic evaluation),
[symbolic execution](#symbolic execution),
[bounded model checking](#bounded model checking),
[Rosette solver](#Rosette solver)\
Referenced by: 
[notes/bounded-model-checking](#notes-bounded-model-checking),
[notes/symbolic-evaluation](#notes-symbolic-evaluation),
[notes/symbolic-execution](#notes-symbolic-execution)\




[symbolic evaluation]: #notes-symbolic-evaluation
[symbolic execution]: #notes-symbolic-execution
[bounded model checking]: #notes-bounded-model-checking
[Rosette solver]: #notes-rosette-solver
# Experience with embedding hardware description languages in HOL {#papers-boulton-tpcd-1993}


Richard Boulton, Andrew Gordon, Michael J. C. Gordon, John Harrison, John Herbert, John Van Tassel
Proceedings of the IFIP TC10/WG 10.2 International Conference on Theorem Provers in Circuit Design: Theory, Practice and Experience
IFIP Transactions A: Computer Science and Technology, volume A-10
North-Holland
Nijmegen, The Netherlands
Pages 129-156
1993
[[Google Scholar]](https://scholar.google.com/scholar?q=Experience%20with%20embedding%20hardware%20description%20languages%20in%20HOL)
[[DBLP]](https://dblp.org/search?q=Experience%20with%20embedding%20hardware%20description%20languages%20in%20HOL)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Experience%20with%20embedding%20hardware%20description%20languages%20in%20HOL)
[[url]](https://www.cl.cam.ac.uk/~jrh13/papers/EmbeddingPaper.html)

Notes: 
[HOL theorem prover](#HOL theorem prover),
[embedding](#embedding)\
Referenced by: 
[notes/embedding](#notes-embedding)\



[HOL theorem prover]: #notes-hol-theorem-prover
[embedding]: #notes-embedding
# Noninterference for free {#papers-bowman-icfp-2015}


William J. Bowman, Amal Ahmed
Association for Computing Machinery
New York, NY, USA
Pages 101-113
August
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=Noninterference%20for%20free)
[[DBLP]](https://dblp.org/search?q=Noninterference%20for%20free)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Noninterference%20for%20free)
[[doi]](https://doi.org/10.1145/2858949.2784733)
[[url]](https://doi.org/10.1145/2858949.2784733)

Notes: 
[non-interference](#non-interference)\
Referenced by: 
[notes/non-interference](#notes-non-interference)\




[non-interference]: #notes-non-interference
# SUSHI: A test generator for programs with complex structured inputs {#papers-braione-icse-2018}


Pietro Braione, Giovanni Denaro, Andrea Mattavelli, Mauro Pezzè
Proceedings of the 40th International Conference on Software Engineering: Companion Proceeedings
ICSE '18
Gothenburg, Sweden
Association for Computing Machinery
New York, NY, USA
Pages 21-24
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=SUSHI%3A%20A%20test%20generator%20for%20programs%20with%20complex%20structured%20inputs)
[[DBLP]](https://dblp.org/search?q=SUSHI%3A%20A%20test%20generator%20for%20programs%20with%20complex%20structured%20inputs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=SUSHI%3A%20A%20test%20generator%20for%20programs%20with%20complex%20structured%20inputs)
[[doi]](https://doi.org/10.1145/3183440.3183472)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450356633)
[[url]](https://doi.org/10.1145/3183440.3183472)

Notes: 
[search based test generation](#search based test generation),
[symbolic execution](#symbolic execution),
[fuzz testing](#fuzz testing),
[test generation](#test generation),
[unit tests](#unit tests)\


[Search based test generation] alone is unable to generate inputs that
have complex structures such as dependencies between different data structures.

This paper uses symbolic execution to capture the missing dependencies and
then transforms this into a fitness function to guide the search for inputs
satisfying the dependencies.

SUSHI implements this for Java and is based on JBSE.

It is evaluated on benchmarks: avl, treemap, caching, tsafe, gantt, clos01, clos72.
And compared against JBSE, Seeker and EvoSuite.
Results with SUSHI seem to be dramatically better.

Future work is automatic synthesis of invariants.



[search based test generation]: #notes-search-based-test-generation
[symbolic execution]: #notes-symbolic-execution
[fuzz testing]: #notes-fuzz-testing
[test generation]: #notes-test-generation
[unit tests]: #notes-unit-tests
# Revisiting the sequential programming model for multi-core {#papers-bridges-micro-2007}


Matthew Bridges, Neil Vachharajani, Yun Zhang, Thomas Jablin, David August
40th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO 2007)
Pages 69-84
December
2007
[[Google Scholar]](https://scholar.google.com/scholar?q=Revisiting%20the%20sequential%20programming%20model%20for%20multi-core)
[[DBLP]](https://dblp.org/search?q=Revisiting%20the%20sequential%20programming%20model%20for%20multi-core)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Revisiting%20the%20sequential%20programming%20model%20for%20multi-core)
[[doi]](https://doi.org/10.1109/MICRO.2007.20)

Notes: 
[threads](#threads),
[pipeline parallelism](#pipeline parallelism)\



[threads]: #notes-threads
[pipeline parallelism]: #notes-pipeline-parallelism
# A semantics for concurrent separation logic {#papers-brookes-tcs-2006}


Stephen Brookes
Pages 227 - 270
2007
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20semantics%20for%20concurrent%20separation%20logic)
[[DBLP]](https://dblp.org/search?q=A%20semantics%20for%20concurrent%20separation%20logic)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20semantics%20for%20concurrent%20separation%20logic)
[[doi]](https://doi.org/10.1016/j.tcs.2006.12.034)
[[url]](http://www.sciencedirect.com/science/article/pii/S0304397506009248)

Notes: 
[permission logic](#permission logic),
[concurrent separation logic](#concurrent separation logic)\




[permission logic]: #notes-permission-logic
[concurrent separation logic]: #notes-concurrent-separation-logic
# Automated testing and debugging of SAT and QBF solvers {#papers-brummayer-sat-2010}


Robert Brummayer, Florian Lonsing, Armin Biere
Theory and Applications of Satisfiability Testing - SAT 2010
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 44-57
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=Automated%20testing%20and%20debugging%20of%20SAT%20and%20QBF%20solvers)
[[DBLP]](https://dblp.org/search?q=Automated%20testing%20and%20debugging%20of%20SAT%20and%20QBF%20solvers)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automated%20testing%20and%20debugging%20of%20SAT%20and%20QBF%20solvers)
[[doi]](https://doi.org/10.1007/978-3-642-14186-7_6)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-14186-7)

Notes: 
[SMT solver](#SMT solver),
[SAT solver](#SAT solver)\
Papers: 
[mansur:arxiv:2020](#mansur-arxiv-2020),
[stump:fmsd:2013](#stump-fmsd-2013)\
Referenced by: 
[papers/barrett:mlf:2015](#papers-barrett-mlf-2015),
[papers/mansur:arxiv:2020](#papers-mansur-arxiv-2020),
[papers/stump:fmsd:2013](#papers-stump-fmsd-2013),
[notes/smt-solver](#notes-smt-solver)\



[SMT solver]: #notes-smt-solver
[SAT solver]: #notes-sat-solver
[mansur:arxiv:2020]: #papers-mansur-arxiv-2020
[stump:fmsd:2013]: #papers-stump-fmsd-2013
# Automatic verification of pipelined microprocessor control {#papers-burch-cav-1994}


Jerry R. Burch, David L. Dill
Proceedings of the 6th International Conference on Computer Aided Verification
CAV '94
Springer-Verlag
London, UK
Pages 68-80
1994
[[Google Scholar]](https://scholar.google.com/scholar?q=Automatic%20verification%20of%20pipelined%20microprocessor%20control)
[[DBLP]](https://dblp.org/search?q=Automatic%20verification%20of%20pipelined%20microprocessor%20control)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automatic%20verification%20of%20pipelined%20microprocessor%20control)
[[doi]](https://doi.org/10.1007/3-540-58179-0_44)
[[ISBN]](http://books.google.com/books?vid=ISBN3-540-58179-0)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# Translating formal software specifications to natural language / A grammar-based approach {#papers-burke-lacl-2005}


David A. Burke, Kristofer Johannisson
Logical Aspects of Computational Linguistics (LACL 2005)
LNAI, volume 3402
Springer
Pages 51-66
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=Translating%20formal%20software%20specifications%20to%20natural%20language%20/%20A%20grammar-based%20approach)
[[DBLP]](https://dblp.org/search?q=Translating%20formal%20software%20specifications%20to%20natural%20language%20/%20A%20grammar-based%20approach)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Translating%20formal%20software%20specifications%20to%20natural%20language%20/%20A%20grammar-based%20approach)
[[doi]](https://doi.org/10.1007/11422532_4)

Notes: 
[formal specification](#formal specification),
[natural language](#natural language)\



[formal specification]: #notes-formal-specification
[natural language]: #notes-natural-language
# A static analyzer for finding dynamic programming errors {#papers-bush-spe-2000}


William R. Bush, Jonathan D. Pincus, David J. Sielaff
John Wiley & Sons, Inc.
USA
Pages 775-802
June
2000
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20static%20analyzer%20for%20finding%20dynamic%20programming%20errors)
[[DBLP]](https://dblp.org/search?q=A%20static%20analyzer%20for%20finding%20dynamic%20programming%20errors)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20static%20analyzer%20for%20finding%20dynamic%20programming%20errors)
[[doi]](https://doi.org/10.1002/(SICI)1097-024X(200006)30:7<775::AID-SPE309>3.0.CO;2-H)
[[url]](https://doi.org/10.1002/(SICI)1097-024X(200006)30:7\%3C775::AID-SPE309\%3E3.0.CO;2-H)

Notes: 
[symbolic execution](#symbolic execution)\



[symbolic execution]: #notes-symbolic-execution
# Symbolic execution for software testing: Three decades later {#papers-cadar-cacm-2013}


Cristian Cadar, Koushik Sen
Association for Computing Machinery
New York, NY, USA
Pages 82-90
February
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Symbolic%20execution%20for%20software%20testing%3A%20Three%20decades%20later)
[[DBLP]](https://dblp.org/search?q=Symbolic%20execution%20for%20software%20testing%3A%20Three%20decades%20later)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Symbolic%20execution%20for%20software%20testing%3A%20Three%20decades%20later)
[[doi]](https://doi.org/10.1145/2408776.2408795)
[[url]](https://doi.org/10.1145/2408776.2408795)

Notes: 
[symbolic execution](#symbolic execution),
[DART verifier](#DART verifier),
[KLEE verifier](#KLEE verifier),
[survey](#survey)\
Papers: 
[baldoni:compsurv:2018](#baldoni-compsurv-2018)\
Referenced by: 
[papers/beyer:hvc:2017](#papers-beyer-hvc-2017),
[notes/klee-verifier](#notes-klee-verifier)\


This is a survey of symbolic execution with an emphasis on the [KLEE verifier].
It is probably a better introduction to the concepts of symbolic execution than the
[baldoni:compsurv:2018] survey but this makes it less complete.

Like [baldoni:compsurv:2018], this article describes some of the important
optimizations to make symbolic execution effective including

- Path optimizations such as
  random exploration,
  interleaving symbolic execution with random exploration,
  pruning redundant paths,
  lazy test generation (only exploring functions if their output is important to the constraint),
  static path merging (aka branch predication).

- Constraint optimizations such as
  irrelevant constraint elimination,
  incremental solving (e.g., counterexample caching),

It ends with a sketch of five symbolic execution tools:
the [DART verifier],
CUTE,
CREST,
EXE and
the [KLEE verifier].



[symbolic execution]: #notes-symbolic-execution
[DART verifier]: #notes-dart-verifier
[KLEE verifier]: #notes-klee-verifier
[survey]: #notes-survey
[baldoni:compsurv:2018]: #papers-baldoni-compsurv-2018
# KLEE: Unassisted and automatic generation of high-coverage tests for complex systems programs {#papers-cadar-osdi-2008}


Cristian Cadar, Daniel Dunbar, Dawson Engler
Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation
OSDI'08
San Diego, California
USENIX Association
Berkeley, CA, USA
Pages 209-224
2008
[[Google Scholar]](https://scholar.google.com/scholar?q=KLEE%3A%20Unassisted%20and%20automatic%20generation%20of%20high-coverage%20tests%20for%20complex%20systems%20programs)
[[DBLP]](https://dblp.org/search?q=KLEE%3A%20Unassisted%20and%20automatic%20generation%20of%20high-coverage%20tests%20for%20complex%20systems%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=KLEE%3A%20Unassisted%20and%20automatic%20generation%20of%20high-coverage%20tests%20for%20complex%20systems%20programs)

Notes: 
[symbolic execution](#symbolic execution)\
Referenced by: 
[notes/klee-verifier](#notes-klee-verifier)\




[symbolic execution]: #notes-symbolic-execution
# Compositional shape analysis by means of bi-abduction {#papers-calcagno-popl-2009}


Cristiano Calcagno, Dino Distefano, Peter W. O'Hearn, Hongseok Yang
Proceedings of the 36th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
POPL '09
Savannah, GA, USA
Association for Computing Machinery
New York, NY, USA
Pages 289-300
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Compositional%20shape%20analysis%20by%20means%20of%20bi-abduction)
[[DBLP]](https://dblp.org/search?q=Compositional%20shape%20analysis%20by%20means%20of%20bi-abduction)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Compositional%20shape%20analysis%20by%20means%20of%20bi-abduction)
[[doi]](https://doi.org/10.1145/1480881.1480917)
[[ISBN]](http://books.google.com/books?vid=ISBN9781605583792)
[[url]](https://doi.org/10.1145/1480881.1480917)

Notes: 
[permission logic](#permission logic),
[biabduction](#biabduction),
[smallfoot verifier](#smallfoot verifier),
[modular verification](#modular verification)\
Papers: 
[berdine:fmco:2005](#berdine-fmco-2005)\
Referenced by: 
[notes/annotation-burden](#notes-annotation-burden),
[notes/modular-verification](#notes-modular-verification)\


One of the big challenges in automated verification is the
annotation burden.
In particular, to make verification compositional, we need contracts
for all the functions but writing and maintaining
contracts for a large codebase is a significant overhead
and discovering the contracts for an existing codebase
is a lot of work.
This paper focusses on discovering contracts that describe
what parts of a heap-allocated data structure a function
depends on in order to support separation logic based
verification of memory safety along the lines of
[Smallfoot][berdine:fmco:2005].

In particular, they are interested in finding the
precondition of a function: what parts of a function's
arguments does a function depend on?
And they want the precondition discovered to be as small
as possible.
(This is a form of "shape analysis".)

The bulk of the paper deals with analysing individual functions.
A short section then describes the fixpoint calculation to
propagate analysis results from one function to another.

What stands out about this paper is the experimental results: they are able to
analyse device drivers, the Linux kernel, Gimp, OpenSSL, etc.  and infer
sufficiently strong contracts for between 42% and 61% of the functions in those
codebases.  There seem to be two key features of their analysis that lead to
this success (and the performance of their tool).

- They are able to cope with partial
  analyses: imprecision and issues such as function pointers
  have a local effect on analysis but they are able
  to keep going.

- The analysis tends to proceed bottom up whereas many
  alternative analyses they mention seem to have been
  top down.

  That said, they suggest that a top-down pass might be
  worth adding to further improve the precision of analysis.
  Presumably this helps propagate information that a function
  is always called with the data structure in some shape.



[permission logic]: #notes-permission-logic
[biabduction]: #notes-biabduction
[smallfoot verifier]: #notes-smallfoot-verifier
[modular verification]: #notes-modular-verification
[berdine:fmco:2005]: #papers-berdine-fmco-2005
# Formalization and automatic derivation of code generators {#papers-cattell-phd-1978}


Roderic Geoffrey Galton Cattell
Ph.D. thesis
Carnegie Mellon University
Pittsburgh, PA, USA
1978
[[Google Scholar]](https://scholar.google.com/scholar?q=Formalization%20and%20automatic%20derivation%20of%20code%20generators)
[[DBLP]](https://dblp.org/search?q=Formalization%20and%20automatic%20derivation%20of%20code%20generators)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Formalization%20and%20automatic%20derivation%20of%20code%20generators)
[[url]](https://pdfs.semanticscholar.org/5caa/48dc2c51e19bc3c8983e27419f69e1098e9c.pdf)

Notes: 
[ISA specification](#ISA specification)\



[ISA specification]: #notes-isa-specification
# Automatic derivation of code generators from machine descriptions {#papers-cattell-toplas-1980}


Roderic Geoffrey Galton Cattell
ACM
New York, NY, USA
Pages 173-190
April
1980
[[Google Scholar]](https://scholar.google.com/scholar?q=Automatic%20derivation%20of%20code%20generators%20from%20machine%20descriptions)
[[DBLP]](https://dblp.org/search?q=Automatic%20derivation%20of%20code%20generators%20from%20machine%20descriptions)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automatic%20derivation%20of%20code%20generators%20from%20machine%20descriptions)
[[doi]](https://doi.org/10.1145/357094.357097)

Notes: 
[ISA specification](#ISA specification)\



[ISA specification]: #notes-isa-specification
# The Haskell 98 foreign function interface 1.0: An addendum to the Haskell 98 report {#papers-chakravarty-haskffi-2003}


Manuel Chakravarty, Sigbjorn Finne, Fergus Henderson, Marcin Kowalczyk, Daan Leijen, Simon Marlow, Erik Meijer, Sven Panne, Simon L. Peyton Jones, Alastair D. Reid, Malcolm Wallace, Michael Weber
2003
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20Haskell%2098%20foreign%20function%20interface%201.0%3A%20An%20addendum%20to%20the%20Haskell%2098%20report)
[[DBLP]](https://dblp.org/search?q=The%20Haskell%2098%20foreign%20function%20interface%201.0%3A%20An%20addendum%20to%20the%20Haskell%2098%20report)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20Haskell%2098%20foreign%20function%20interface%201.0%3A%20An%20addendum%20to%20the%20Haskell%2098%20report)
[[url]](https://www.cse.unsw.edu.au/~chak/haskell/ffi)

Notes: 
[Haskell language](#Haskell language),
[foreign function interface](#foreign function interface)\
Papers: 
[jones:hw:1997](#jones-hw-1997)\
Referenced by: 
[papers/jones:hw:1997](#papers-jones-hw-1997),
[notes/foreign-function-interface](#notes-foreign-function-interface)\




[Haskell language]: #notes-haskell-language
[foreign function interface]: #notes-foreign-function-interface
[jones:hw:1997]: #papers-jones-hw-1997
# Bigtable: A distributed storage system for structured data {#papers-chang-tocs-2012}


Fay Chang, Jeffrey Dean, Sanjay Ghemawat, Wilson C. Hsieh, Deborah A. Wallach, Mike Burrows, Tushar Chandra, Andrew Fikes, Robert E. Gruber
Association for Computing Machinery
New York, NY, USA
June
2008
[[Google Scholar]](https://scholar.google.com/scholar?q=Bigtable%3A%20A%20distributed%20storage%20system%20for%20structured%20data)
[[DBLP]](https://dblp.org/search?q=Bigtable%3A%20A%20distributed%20storage%20system%20for%20structured%20data)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Bigtable%3A%20A%20distributed%20storage%20system%20for%20structured%20data)
[[doi]](https://doi.org/10.1145/1365815.1365816)
[[url]](https://doi.org/10.1145/1365815.1365816)

Notes: 
[google papers](#google papers),
[google infrastructure](#google infrastructure)\



[google papers]: #notes-google-papers
[google infrastructure]: #notes-google-infrastructure
# A reachability predicate for analyzing low-level software {#papers-chatterjee-tacas-2007}


Shaunak Chatterjee, Shuvendu K. Lahiri, Shaz Qadeer, Zvonimir Rakamarić
Tools and Algorithms for the Construction and Analysis of Systems
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 19-33
2007
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20reachability%20predicate%20for%20analyzing%20low-level%20software)
[[DBLP]](https://dblp.org/search?q=A%20reachability%20predicate%20for%20analyzing%20low-level%20software)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20reachability%20predicate%20for%20analyzing%20low-level%20software)
[[doi]](https://doi.org/10.1007/978-3-540-71209-1_4)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-71209-1)

Referenced by: 
[papers/barnett:cacm:2011](#papers-barnett-cacm-2011)\




# S2E: A platform for in-vivo multi-path analysis of software systems {#papers-chipounov-asplos-2011}


Vitaly Chipounov, Volodymyr Kuznetsov, George Candea
Proceedings of the Sixteenth International Conference on Architectural Support for Programming Languages and Operating Systems
ASPLOS XVI
Newport Beach, California, USA
Association for Computing Machinery
New York, NY, USA
Pages 265-278
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=S2E%3A%20A%20platform%20for%20in-vivo%20multi-path%20analysis%20of%20software%20systems)
[[DBLP]](https://dblp.org/search?q=S2E%3A%20A%20platform%20for%20in-vivo%20multi-path%20analysis%20of%20software%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=S2E%3A%20A%20platform%20for%20in-vivo%20multi-path%20analysis%20of%20software%20systems)
[[doi]](https://doi.org/10.1145/1950365.1950396)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450302661)
[[url]](https://doi.org/10.1145/1950365.1950396)

Notes: 
[S2E verifier](#S2E verifier),
[symbolic execution](#symbolic execution)\
Referenced by: 
[notes/s2e-verifier](#notes-s2e-verifier)\



[S2E verifier]: #notes-s2e-verifier
[symbolic execution]: #notes-symbolic-execution
# Selective symbolic execution {#papers-chipounov-hotdep-2009}


Vitaly Chipounov, Vlad Georgescu, Cristian Zamfir, George Candea
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Selective%20symbolic%20execution)
[[DBLP]](https://dblp.org/search?q=Selective%20symbolic%20execution)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Selective%20symbolic%20execution)
[[url]](http://infoscience.epfl.ch/record/139393)

Notes: 
[symbolic execution](#symbolic execution),
[KLEE verifier](#KLEE verifier),
[S2E verifier](#S2E verifier)\
Referenced by: 
[notes/s2e-verifier](#notes-s2e-verifier)\


The [S2E verifier] can analyze application code, complex GUI
libraries, kernel code, device drivers, and even hardware devices.
It does this by alternating between concrete execution (using QEMU) and
[symbolic execution] (using the [KLEE verifier]).
Switching modes makes it more flexible but it also makes it more efficient
because (slower) symbolic execution can be restricted to the code
of most interest which might be a library, a recently changed code path,
etc.

The big trick is switching from concrete execution to symbolic execution.

The evaluation is fairly sparse but they say they are able to analyze
device drivers in Windows with only a 1.7x slowdown relative to unmodified
QEMU.



[symbolic execution]: #notes-symbolic-execution
[KLEE verifier]: #notes-klee-verifier
[S2E verifier]: #notes-s2e-verifier
# The S2E platform: Design, implementation, and applications {#papers-chipounov-tcs-2012}


Vitaly Chipounov, Volodymyr Kuznetsov, George Candea
Association for Computing Machinery
New York, NY, USA
February
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20S2E%20platform%3A%20Design%2C%20implementation%2C%20and%20applications)
[[DBLP]](https://dblp.org/search?q=The%20S2E%20platform%3A%20Design%2C%20implementation%2C%20and%20applications)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20S2E%20platform%3A%20Design%2C%20implementation%2C%20and%20applications)
[[doi]](https://doi.org/10.1145/2110356.2110358)
[[url]](https://doi.org/10.1145/2110356.2110358)

Notes: 
[S2E verifier](#S2E verifier),
[symbolic execution](#symbolic execution)\
Referenced by: 
[notes/s2e-verifier](#notes-s2e-verifier)\



[S2E verifier]: #notes-s2e-verifier
[symbolic execution]: #notes-symbolic-execution
# Kami: A platform for high-level parametric hardware specification and its modular verification {#papers-choi-icfp-2017}


Joonwon Choi, Muralidaran Vijayaraghavan, Benjamin Sherman, Adam J. Chlipala, Arvind
ACM
Pages 24
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=Kami%3A%20A%20platform%20for%20high-level%20parametric%20hardware%20specification%20and%20its%20modular%20verification)
[[DBLP]](https://dblp.org/search?q=Kami%3A%20A%20platform%20for%20high-level%20parametric%20hardware%20specification%20and%20its%20modular%20verification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Kami%3A%20A%20platform%20for%20high-level%20parametric%20hardware%20specification%20and%20its%20modular%20verification)
[[doi]](https://doi.org/10.1145/3110268)





# Reasoning about the ARM weakly consistent memory model {#papers-chong-asplos-2008}


Nathan Chong, Samin Ishtiaq
Proceedings of the 2008 ACM SIGPLAN workshop on Memory Systems Performance and Correctness: held in conjunction with the Thirteenth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS '08), Seattle, Washington, USA, March 2, 2008
Pages 16-19
2008
[[Google Scholar]](https://scholar.google.com/scholar?q=Reasoning%20about%20the%20ARM%20weakly%20consistent%20memory%20model)
[[DBLP]](https://dblp.org/search?q=Reasoning%20about%20the%20ARM%20weakly%20consistent%20memory%20model)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Reasoning%20about%20the%20ARM%20weakly%20consistent%20memory%20model)
[[doi]](https://doi.org/10.1145/1353522.1353528)

Notes: 
[weak memory](#weak memory)\



[weak memory]: #notes-weak-memory
# Code-level model checking in the software development workflow {#papers-chong-icse-2020}


Nathan Chong, Byron Cook, Konstantinos Kallas, Kareem Khazem, Felipe R. Monteiro, Daniel Schwartz-Narbonne, Serdar Tasiran, Michael Tautschnig, Mark R. Tuttle
Proceedings of the 2020 International Conference on Software Engineering (ICSE)
June
2020
[[Google Scholar]](https://scholar.google.com/scholar?q=Code-level%20model%20checking%20in%20the%20software%20development%20workflow)
[[DBLP]](https://dblp.org/search?q=Code-level%20model%20checking%20in%20the%20software%20development%20workflow)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Code-level%20model%20checking%20in%20the%20software%20development%20workflow)
[[doi]](https://doi.org/10.1145/3377813.3381347)

Notes: 
[model checking](#model checking),
[CBMC verifier](#CBMC verifier)\


This very readable paper describes the successful introduction of a formal
verification flow into the development of the Amazon C Common library.  Anyone
trying to introduce formal verification into a traditional development team
should read this paper!

The most important aspect of the paper is probably their focus on getting
developer buy in. This resulted in the developers writing a lot of the function
contracts as well as reviewing contracts, proofs and bugfixes written by the
verification team.  In part, this was due to finding bugs that the developers
considered worth fixing although the verification team's goal was not just to
find bugs but to prove absence of bugs.

They highlight four lessons that they learned:

- Make specifications explicit in source code
- Write proofs-harnesses in declarative style
- Integrate proof artifacts into the development workflow
- Fix bugs instead of just reporting them

that they credit with:

- Increased proof speed (i.e., reduced human effort)
- Increased rate of bugs found and fixed
- Active developer engagement with proofs
- Increase in lines of specifications written by developers


One surprising thing is the notion of proof which, in their case,
is the verification harness used to invoke each verified function
with appropriately constrained symbolic inputs and appropriate assertions
about the results.
This harness allows them to use the [CBMC verifier] to verify that
each function meets its contract.

The properties verified (and bugs found) are mostly low-level safety properties
(integer overflow, null pointer dereference and memory safety) together with
some functional properties.

The paper is full of stories about how they interacted with and gained the
trust of the developers and graphs showing the rate at which proofs, bugs, etc.
were created/found/etc.


[model checking]: #notes-model-checking
[CBMC verifier]: #notes-cbmc-verifier
# False positives over time: A problem in deploying static analysis tools {#papers-chou-bugs-2005}


Andy Chou
Proceedings of BUGS 2005 (PLDI 2005 Workshop on the Evaluation of Software Defect Detection Tools)
Chicago, IL, USA
June
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=False%20positives%20over%20time%3A%20A%20problem%20in%20deploying%20static%20analysis%20tools)
[[DBLP]](https://dblp.org/search?q=False%20positives%20over%20time%3A%20A%20problem%20in%20deploying%20static%20analysis%20tools)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=False%20positives%20over%20time%3A%20A%20problem%20in%20deploying%20static%20analysis%20tools)
[[url]](http://www.cs.umd.edu/~pugh/SoftwareDefectWorkshop05/BugWorkshop05.pdf)



This one-page, position paper by one of the cofounders of Coverity
makes the interesting observation (that is obvious once it has been said)

> All source code analyzers generate false positives, or issues which are
> reported but are not really defects. False positives accumulate over time
> because developers fix real defects but tend to leave false positives in the
> source code.

Six mitigations are briefly sketched:

- annotations in the source code
- override analysis decisions
- change the source code
- stop using the tool or disable specific analyses
- rank errors based on utility, probability or whatever.  (This is what
  Coverity does)
- annotate false positives

Solutions based on changing source code are vulnerable to changes in the tool
rendering the changes obsolete because the tool no longer trips up on that
part of the code.



# Three decades of HDLs: Part I, CDL through TI-HDL {#papers-chu-ieeedtc-1992}


Yaohan Chu, Donald L. Dietmeyer, James R. Duley, Fredrick J. Hill, Mario R. Barbacci, Charles W. Rose, Greg Ordy, Bill Johnson, Martin Roberts
Pages 69-81
1992
[[Google Scholar]](https://scholar.google.com/scholar?q=Three%20decades%20of%20HDLs%3A%20Part%20I%2C%20CDL%20through%20TI-HDL)
[[DBLP]](https://dblp.org/search?q=Three%20decades%20of%20HDLs%3A%20Part%20I%2C%20CDL%20through%20TI-HDL)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Three%20decades%20of%20HDLs%3A%20Part%20I%2C%20CDL%20through%20TI-HDL)
[[doi]](https://doi.org/10.1109/54.143147)
[[url]](https://doi.org/10.1109/54.143147)

Notes: 
[ISPS](#ISPS)\



[ISPS]: #notes-isps
# UQBT: Adaptable binary translation at low cost {#papers-cifuentes-computer-2000}


Cristina Cifuentes, M. Van Emmerik
Pages 60-66
March
2000
[[Google Scholar]](https://scholar.google.com/scholar?q=UQBT%3A%20Adaptable%20binary%20translation%20at%20low%20cost)
[[DBLP]](https://dblp.org/search?q=UQBT%3A%20Adaptable%20binary%20translation%20at%20low%20cost)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=UQBT%3A%20Adaptable%20binary%20translation%20at%20low%20cost)
[[doi]](https://doi.org/10.1109/2.825697)

Notes: 
[ISA specification](#ISA specification),
[SLED](#SLED)\



[ISA specification]: #notes-isa-specification
[SLED]: #notes-sled
# Specifying the semantics of machine instructions {#papers-cifuentes-iwpc-1998}


Cristina Cifuentes, Shane Sendall
Program Comprehension, 1998. IWPC '98. Proceedings., 6th International Workshop on
Pages 126-133
Jun
1998
[[Google Scholar]](https://scholar.google.com/scholar?q=Specifying%20the%20semantics%20of%20machine%20instructions)
[[DBLP]](https://dblp.org/search?q=Specifying%20the%20semantics%20of%20machine%20instructions)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Specifying%20the%20semantics%20of%20machine%20instructions)
[[doi]](https://doi.org/10.1109/WPC.1998.693332)

Notes: 
[ISA specification](#ISA specification),
[formal specification](#formal specification),
[SLED](#SLED)\



[ISA specification]: #notes-isa-specification
[formal specification]: #notes-formal-specification
[SLED]: #notes-sled
# QuickCheck: A lightweight tool for random testing of Haskell programs {#papers-claessen-icfp-2000}


Koen Claessen, John Hughes
Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming
ICFP '00
Association for Computing Machinery
New York, NY, USA
Pages 268-279
2000
[[Google Scholar]](https://scholar.google.com/scholar?q=QuickCheck%3A%20A%20lightweight%20tool%20for%20random%20testing%20of%20Haskell%20programs)
[[DBLP]](https://dblp.org/search?q=QuickCheck%3A%20A%20lightweight%20tool%20for%20random%20testing%20of%20Haskell%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=QuickCheck%3A%20A%20lightweight%20tool%20for%20random%20testing%20of%20Haskell%20programs)
[[doi]](https://doi.org/10.1145/351240.351266)
[[ISBN]](http://books.google.com/books?vid=ISBN1581132026)
[[url]](https://doi.org/10.1145/351240.351266)

Notes: 
[property-based testing](#property-based testing),
[fuzz testing](#fuzz testing),
[unit tests](#unit tests)\
Papers: 
[becker:fm:2016](#becker-fm-2016)\
Referenced by: 
[notes/property-based-testing](#notes-property-based-testing)\


QuickCheck takes a test-based approach to formal verification.
You write universally-quantified properties and QuickCheck uses
random testing ([fuzz testing]) to check whether the property holds.
QuickCheck was originally written for Haskell but various people have
since implemented it for around 40 different languages.

It is based on a lightweight DSL (the original was around 300 lines – most of
which is included in an appendix).

A bunch of cool things in the paper

- 'classify' labels inputs satisfying some condition so that
  you can count different categories of test input.

- 'collect' generates histograms of input values.
  (This and 'collect' is reminiscent of similar functionality that
  later appeared in System-Verilog.)

- parts of the DSL for creating test-data generators

  - 'forAll' is used to invoke custom test-data generators.
    (They remark that it is important to know the desired
    distribution of test-cases in order to create (select?) a
    good test-data generator.)

  - 'oneof' is used to combine generators

  - 'frequency' is used to combine generators with different weights

  - 'sized' is used to control the size of values generated

  - the typeclass 'Arbitrary' is used to select a test-data generator
    based on type.

  - the typeclass 'Coarbitrary' is used to generate random functions.
    It is roughly equivalent to generating a hash from the inputs and
    using that as to modify the random seed to generate the outputs.

    Key to making this work is that '>>' splits seeds instead of serializing
    them.

- structured inputs (e.g., substitution maps) can't just be random: you have
  to design a generator that has the right data distribution to generate
  values that are not just legal but are likely to hit important cases.

- When they tried QuickCheck on Lava, they were able to also check properties
  with a first-order solver but it was still worth using QuickCheck because
  it would quickly find counterexamples a lot of the time and because
  the ability to create random functions allows QuickCheck to test
  higher-order properties.

- An important part of QuickCheck is that it is easy to use which means
  that it is much more likely to be used.

- The errors detected are roughly equally in the test-data generators, the
  specifications and the program.
  (This reminds me of what [becker:fm:2016] reports.)

- To help write specifications, they are developing a library of finite set
  theory.

- There is no measurement of *test coverage* because they want QuickCheck
  to be lightweight and easy to use with any Haskell compiler.

Something that I had not remembered correctly about this paper was shrinking.
Shrinking (simplifying test-data values) is a key part of QuickCheck
but it is mentioned almost as an afterthought as an idea suggested by
Andy Gill and with little detail on the best ways to shrink values.



[property-based testing]: #notes-property-based-testing
[fuzz testing]: #notes-fuzz-testing
[unit tests]: #notes-unit-tests
[becker:fm:2016]: #papers-becker-fm-2016
# An introduction to symbolic trajectory evaluation {#papers-claessen-sfm-2006}


Koen Claessen, Jan-Willem Roorda
Formal Methods for Hardware Verification, 6th International School on Formal Methods for the Design of Computer, Communication, and Software Systems, SFM 2006, Bertinoro, Italy, May 22-27, 2006, Advanced Lectures
Lecture Notes in Computer Science, volume 3965
Springer
Pages 56-77
2006
[[Google Scholar]](https://scholar.google.com/scholar?q=An%20introduction%20to%20symbolic%20trajectory%20evaluation)
[[DBLP]](https://dblp.org/search?q=An%20introduction%20to%20symbolic%20trajectory%20evaluation)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=An%20introduction%20to%20symbolic%20trajectory%20evaluation)
[[doi]](https://doi.org/10.1007/11757283_3)
[[url]](https://doi.org/10.1007/11757283_3)

Notes: 
[symbolic trajectory evaluation](#symbolic trajectory evaluation)\
Referenced by: 
[notes/symbolic-trajectory-evaluation](#notes-symbolic-trajectory-evaluation)\



[symbolic trajectory evaluation]: #notes-symbolic-trajectory-evaluation
# Quantitative analysis of the leakage of confidential data {#papers-clark-entcs-2002}


David Clark, Sebastian Hunt, Pasquale Malacaria
Pages 238 - 251
2002
[[Google Scholar]](https://scholar.google.com/scholar?q=Quantitative%20analysis%20of%20the%20leakage%20of%20confidential%20data)
[[DBLP]](https://dblp.org/search?q=Quantitative%20analysis%20of%20the%20leakage%20of%20confidential%20data)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Quantitative%20analysis%20of%20the%20leakage%20of%20confidential%20data)
[[doi]](https://doi.org/10.1016/S1571-0661(04)00290-7)

Notes: 
[information flow](#information flow)\



[information flow]: #notes-information-flow
# Model checking: Algorithmic verification and debugging {#papers-clarke-cacm-2009}


Edmund M. Clarke, E. Allen Emerson, Joseph Sifakis
Association for Computing Machinery
New York, NY, USA
Pages 74-84
November
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Model%20checking%3A%20Algorithmic%20verification%20and%20debugging)
[[DBLP]](https://dblp.org/search?q=Model%20checking%3A%20Algorithmic%20verification%20and%20debugging)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Model%20checking%3A%20Algorithmic%20verification%20and%20debugging)
[[doi]](https://doi.org/10.1145/1592761.1592781)
[[url]](https://doi.org/10.1145/1592761.1592781)

Notes: 
[survey](#survey),
[model checking](#model checking),
[temporal logic](#temporal logic),
[bounded model checking](#bounded model checking),
[symbolic model checking](#symbolic model checking),
[partial order reduction](#partial order reduction),
[CEGAR](#CEGAR),
[abstract interpretation](#abstract interpretation),
[Turing Award](#Turing Award)\
Referenced by: 
[papers/mcmillan:ecs:2003](#papers-mcmillan-ecs-2003),
[notes/model-checking](#notes-model-checking),
[notes/temporal-logic](#notes-temporal-logic)\


This [Turing Award] paper/talk is a great overview of [model checking:
definition,
[temporal logic],
what it is good for, challenges (mostly state-space explosion),
tricks (like [symbolic model checking], [bounded model checking], [partial order reduction] and [CEGAR]).

It also talks about the problems creating specifications.
As well as challenges understanding subtle details of [temporal logic],
there are challenges specifying extra-functional requirements for security
properties, reconfigurability properties, quality of service (e.g., jitter).

And it talks about problems verifying real world systems: mixed
hardware-software systems, using abstraction to scale (using hybrid
[model checking] / [abstract interpretation] methods and compositional reasoning)
and exploiting design-time architectural choices to improve verifiability.



[survey]: #notes-survey
[model checking]: #notes-model-checking
[temporal logic]: #notes-temporal-logic
[bounded model checking]: #notes-bounded-model-checking
[symbolic model checking]: #notes-symbolic-model-checking
[partial order reduction]: #notes-partial-order-reduction
[CEGAR]: #notes-cegar
[abstract interpretation]: #notes-abstract-interpretation
[Turing Award]: #notes-turing-award
# Counterexample-guided abstraction refinement {#papers-clarke-cav-2000}


Edmund M. Clarke, Orna Grumberg, Somesh Jha, Yuan Lu, Helmut Veith
Computer Aided Verification
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 154-169
2000
[[Google Scholar]](https://scholar.google.com/scholar?q=Counterexample-guided%20abstraction%20refinement)
[[DBLP]](https://dblp.org/search?q=Counterexample-guided%20abstraction%20refinement)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Counterexample-guided%20abstraction%20refinement)
[[doi]](https://doi.org/10.1007/10722167_15)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-45047-4)

Notes: 
[CEGAR](#CEGAR)\
Referenced by: 
[notes/cegar](#notes-cegar)\




[CEGAR]: #notes-cegar
# A tool for checking ANSI-C programs {#papers-clarke-tacas-2004}


Edmund M. Clarke, Daniel Kroening, Flavio Lerda
Tools and Algorithms for the Construction and Analysis of Systems
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 168-176
2004
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20tool%20for%20checking%20ANSI-C%20programs)
[[DBLP]](https://dblp.org/search?q=A%20tool%20for%20checking%20ANSI-C%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20tool%20for%20checking%20ANSI-C%20programs)
[[doi]](https://doi.org/10.1007/978-3-540-24730-2_15)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-24730-2)

Notes: 
[CBMC verifier](#CBMC verifier),
[bounded model checking](#bounded model checking)\
Referenced by: 
[notes/cbmc-verifier](#notes-cbmc-verifier)\




[CBMC verifier]: #notes-cbmc-verifier
[bounded model checking]: #notes-bounded-model-checking
# Design and synthesis of synchronization skeletons using branching-time temporal logic {#papers-clarke-wlop-1982}


Edmund M. Clarke, E. Allen Emerson
Logic of Programs, Workshop
Springer-Verlag
London, UK, UK
Pages 52-71
1982
[[Google Scholar]](https://scholar.google.com/scholar?q=Design%20and%20synthesis%20of%20synchronization%20skeletons%20using%20branching-time%20temporal%20logic)
[[DBLP]](https://dblp.org/search?q=Design%20and%20synthesis%20of%20synchronization%20skeletons%20using%20branching-time%20temporal%20logic)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Design%20and%20synthesis%20of%20synchronization%20skeletons%20using%20branching-time%20temporal%20logic)
[[doi]](https://doi.org/10.1007/BFb0025774)
[[ISBN]](http://books.google.com/books?vid=ISBN3-540-11212-X)

Notes: 
[model checking](#model checking),
[temporal logic](#temporal logic)\



[model checking]: #notes-model-checking
[temporal logic]: #notes-temporal-logic
# Hyperproperties {#papers-clarkson-jcs-2010}


Michael R. Clarkson, Fred B. Schneider
IOS Press
Pages 1157-1210
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=Hyperproperties)
[[DBLP]](https://dblp.org/search?q=Hyperproperties)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Hyperproperties)
[[doi]](https://doi.org/10.3233/JCS-2009-0393)

Notes: 
[information flow](#information flow),
[hyperproperty](#hyperproperty)\




[information flow]: #notes-information-flow
[hyperproperty]: #notes-hyperproperty
# The last mile: An empirical study of timing channels on seL4 {#papers-cock-ccs-2014}


David Cock, Qian Ge, Toby Murray, Gernot Heiser
Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security
CCS'14
Scottsdale, Arizona, USA
ACM
New York, NY, USA
Pages 570-581
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20last%20mile%3A%20An%20empirical%20study%20of%20timing%20channels%20on%20seL4)
[[DBLP]](https://dblp.org/search?q=The%20last%20mile%3A%20An%20empirical%20study%20of%20timing%20channels%20on%20seL4)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20last%20mile%3A%20An%20empirical%20study%20of%20timing%20channels%20on%20seL4)
[[doi]](https://doi.org/10.1145/2660267.2660294)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-2957-6)





# Local verification of global invariants in concurrent programs {#papers-cohen-cav-2010}


Ernie Cohen, Michał Moskal, Wolfram Schulte, Stephan Tobies
International Conference on Computer Aided Verification
Springer
Pages 480-494
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=Local%20verification%20of%20global%20invariants%20in%20concurrent%20programs)
[[DBLP]](https://dblp.org/search?q=Local%20verification%20of%20global%20invariants%20in%20concurrent%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Local%20verification%20of%20global%20invariants%20in%20concurrent%20programs)
[[doi]](https://doi.org/10.1007/978-3-642-14295-6_42)

Notes: 
[VCC verifier](#VCC verifier)\
Referenced by: 
[papers/barnett:fmco:2005](#papers-barnett-fmco-2005),
[papers/cohen:entcs:2009](#papers-cohen-entcs-2009),
[papers/legoues:sefm:2011](#papers-legoues-sefm-2011),
[papers/leino:informatics:2001](#papers-leino-informatics-2001),
[papers/philippaerts:scp:2014](#papers-philippaerts-scp-2014),
[notes/annotation-burden](#notes-annotation-burden)\


Describes how VCC was used to verify Hyper-V Hypervisor and PikeOS RTOS.
Key idea is “two-state invariants” which are basically specs of parts of the transition relation.  Required to be reflexive to allow a stuttering-style verification.  Overall name for the technique is “Locally Checked Invariants” (LCI).
Unlike alternatives like Concurrent Separation Logic, this is built out of some simple primitives with a small amount of syntactic sugar so that it can be very explicit about object lifetime, object ownership, which fields are protected by each lock, etc.
Annotations can introduce ghost state and ghost code to modify that state — this allows them to keep things first-order.
Significant annotation burden: 1 line of annotation per line of code.  This seems to be partly the cost of flexibility / building everything out of primitives and partly the complexity of the relationships being described.  I suspect that more sugar and some annotation inference would make a big difference.
They allude to some performance issues that are fixed by changing how the invariants, etc are written.  With 1/3 of the 100kloc annotated, it takes around 16 CPU hours to verify the properties — but this is very parallel.
Limitation: seems to assume SC or DRF.



[VCC verifier]: #notes-vcc-verifier
# A precise yet efficient memory model for C {#papers-cohen-entcs-2009}


Ernie Cohen, Michał Moskal, Stephan Tobies, Wolfram Schulte
Elsevier
Pages 85-103
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20precise%20yet%20efficient%20memory%20model%20for%20C)
[[DBLP]](https://dblp.org/search?q=A%20precise%20yet%20efficient%20memory%20model%20for%20C)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20precise%20yet%20efficient%20memory%20model%20for%20C)
[[doi]](https://doi.org/10.1016/j.entcs.2009.09.061)

Notes: 
[VCC verifier](#VCC verifier)\
Papers: 
[cohen:cav:2010](#cohen-cav-2010)\


A memory model (in this context) is basically "what is a pointer"?
Is a pointer an identifier for an object or an integer index into an array of bytes?
How do you handle fields of objects?
How do you handle pointer arithmetic?
etc.
After some experimentation (described in a lovely historical note in section 7), the authors came up with a model
that can handle many of the awkward features of C:
pointers into the middle of objects,
pointers past the end of objects,
pointer casts,
unions,
bitfields,
etc.
This formed part of the [VCC tool][cohen:cav:2010] that was used to reason about
real, complex OS-level code (that needed many of these features).

Most of the model is what you would expect (pointers, fields, casts, etc.).
The core of the model though is the addition of two operations "join" and "split".
"join" combines a sequence of memory bytes into an object of some type (e.g., an int, a struct or an array);
and "split" converts an object with some type back into the corresponding sequence of bytes.
"Join" might be used when an object is allocated while "split" might be used when accessing a different union field than last time.

An important part of this paper is the set of SMT axioms that are used to turn this model into an effective reasoning tool.



[VCC verifier]: #notes-vcc-verifier
[cohen:cav:2010]: #papers-cohen-cav-2010
# Issues in deploying software defect detection tools {#papers-cok-bugs-2005}


David R. Cok
Proceedings of BUGS 2005 (PLDI 2005 Workshop on the Evaluation of Software Defect Detection Tools)
Chicago, IL, USA
June
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=Issues%20in%20deploying%20software%20defect%20detection%20tools)
[[DBLP]](https://dblp.org/search?q=Issues%20in%20deploying%20software%20defect%20detection%20tools)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Issues%20in%20deploying%20software%20defect%20detection%20tools)
[[url]](http://www.cs.umd.edu/~pugh/SoftwareDefectWorkshop05/BugWorkshop05.pdf)

Notes: 
[under-approximation](#under-approximation)\


This one-page, position paper talks about what makes a bug-finding tool useful
and usable in an industrial setting.
The [slides](https://www.cs.umd.edu/~pugh/BugWorkshop05/presentations/3-adoptation/Cok-BUGS05.pdf) are worth reading since they say things not present in the paper.

Usefulness is affected by three things

- Accuracy.
  In the [slides](https://www.cs.umd.edu/~pugh/BugWorkshop05/presentations/3-adoptation/Cok-BUGS05.pdf)
  the conventional true/false positive/negative metrics are recast as follows

  - TP/(TP+FN) = recall = sensitivity = Pr(detect the bug | there is a bug)
  - TP/(TP+FP) = precision = predictive value positive = Pr(real bug| detected bug)
  - TN/(TN+FP) = specificity = Pr(no detection | no bug)
  - FN/(FN+TN) = predictive value negative = Pr(no bug| no detection)

- Handling the bulk of the important defect areas for a user
- Time and space performance consistent with the benefit provided

Usability has several components

- Out-of-the-box experience
- Resource investment profile
- Perspicuity

Finally, there is a need for confidence that the tool will continue to exist
and be supported.



[under-approximation]: #notes-under-approximation
# Unifying type checking and property checking for low-level code {#papers-condit-popl-2009}


Jeremy Condit, Brian Hackett, Shuvendu K. Lahiri, Shaz Qadeer
ACM SIGPLAN Notices
ACM
Pages 302-314
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Unifying%20type%20checking%20and%20property%20checking%20for%20low-level%20code)
[[DBLP]](https://dblp.org/search?q=Unifying%20type%20checking%20and%20property%20checking%20for%20low-level%20code)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Unifying%20type%20checking%20and%20property%20checking%20for%20low-level%20code)
[[doi]](https://doi.org/10.1145/1594834.1480921)





# Design of a separable transition-diagram compiler {#papers-conway-cacm-1963}


Melvin E. Conway
ACM
New York, NY, USA
Pages 396-408
July
1963
[[Google Scholar]](https://scholar.google.com/scholar?q=Design%20of%20a%20separable%20transition-diagram%20compiler)
[[DBLP]](https://dblp.org/search?q=Design%20of%20a%20separable%20transition-diagram%20compiler)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Design%20of%20a%20separable%20transition-diagram%20compiler)
[[doi]](https://doi.org/10.1145/366663.366704)




# Model checking boot code from AWS data centers {#papers-cook-cav-2018}


Byron Cook, Kareem Khazem, Daniel Kroening, Serdar Tasiran, Michael Tautschnig, Mark R. Tuttle
International Conference on Computer Aided Verification
Springer
Pages 467-486
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=Model%20checking%20boot%20code%20from%20AWS%20data%20centers)
[[DBLP]](https://dblp.org/search?q=Model%20checking%20boot%20code%20from%20AWS%20data%20centers)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Model%20checking%20boot%20code%20from%20AWS%20data%20centers)
[[doi]](https://doi.org/10.1007/s10703-020-00344-2)

Notes: 
[bounded model checking](#bounded model checking),
[bounded verification](#bounded verification),
[model checking](#model checking)\




[bounded model checking]: #notes-bounded-model-checking
[bounded verification]: #notes-bounded-verification
[model checking]: #notes-model-checking
# Constructions: A higher order proof system for mechanizing mathematics {#papers-coquand-eurocal-1985}


Thierry Coquand, Gérard Huet
EUROCAL '85: European Conference on Computer Algebra Linz, Austria, April 1-3 1985 Proceedings Vol. 1: Invited Lectures
Springer
Berlin, Heidelberg
Pages 151-184
1985
[[Google Scholar]](https://scholar.google.com/scholar?q=Constructions%3A%20A%20higher%20order%20proof%20system%20for%20mechanizing%20mathematics)
[[DBLP]](https://dblp.org/search?q=Constructions%3A%20A%20higher%20order%20proof%20system%20for%20mechanizing%20mathematics)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Constructions%3A%20A%20higher%20order%20proof%20system%20for%20mechanizing%20mathematics)
[[doi]](https://doi.org/10.1007/3-540-15983-5_13)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-39684-0)

Notes: 
[Coq theorem prover](#Coq theorem prover)\



[Coq theorem prover]: #notes-coq-theorem-prover
# Spanner: Google's globally distributed database {#papers-corbett-tocs-2013}


James C. Corbett, Jeffrey Dean, Michael Epstein, Andrew Fikes, Christopher Frost, J. J. Furman, Sanjay Ghemawat, Andrey Gubarev, Christopher Heiser, Peter Hochschild, Wilson C. Hsieh, Sebastian Kanthak, Eugene Kogan, Hongyi Li, Alexander Lloyd, Sergey Melnik, David Mwaura, David Nagle, Sean Quinlan, Rajesh Rao, Lindsay Rolig, Yasushi Saito, Michal Szymaniak, Christopher Taylor, Ruth Wang, Dale Woodford
Association for Computing Machinery
New York, NY, USA
August
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Spanner%3A%20Google%27s%20globally%20distributed%20database)
[[DBLP]](https://dblp.org/search?q=Spanner%3A%20Google%27s%20globally%20distributed%20database)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Spanner%3A%20Google%27s%20globally%20distributed%20database)
[[doi]](https://doi.org/10.1145/2491245)
[[url]](https://doi.org/10.1145/2491245)

Notes: 
[google papers](#google papers),
[google infrastructure](#google infrastructure),
[Paxos](#Paxos)\



[google papers]: #notes-google-papers
[google infrastructure]: #notes-google-infrastructure
[Paxos]: #notes-paxos
# End-to-end verification of information flow security for C and assembly programs {#papers-costanzo-pldi-2016}


David Costanzo, Zhong Shao, Ronghui Gu
Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation
PLDI'16
Santa Barbara, CA, USA
ACM
New York, NY, USA
Pages 648-664
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=End-to-end%20verification%20of%20information%20flow%20security%20for%20C%20and%20assembly%20programs)
[[DBLP]](https://dblp.org/search?q=End-to-end%20verification%20of%20information%20flow%20security%20for%20C%20and%20assembly%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=End-to-end%20verification%20of%20information%20flow%20security%20for%20C%20and%20assembly%20programs)
[[doi]](https://doi.org/10.1145/2908080.2908100)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-4261-2)
[[url]](http://doi.acm.org/10.1145/2908080.2908100)

Notes: 
[information flow](#information flow)\
Papers: 
[gu:osdi:2016](#gu-osdi-2016)\
Referenced by: 
[papers/murray:secpriv:2013](#papers-murray-secpriv-2013),
[notes/annotation-burden](#notes-annotation-burden),
[notes/non-interference](#notes-non-interference)\


Information-flow control tackles two of the classic Confidentiality-Integrity-Availability (CIA) aspects of security.
This paper presents a framework that applies IFC to the mCertiKOS microkernel in order to prove confidentiality properties.
The proof consists of Coq proofs about individual system calls and a general framework relating lower-level "unwinding conditions" to the overall security properties.
The proof covers both C and x86 assembly code in mCertiKOS and includes reasoning about page tables.

For those familiar with the mCertiKOS work, one of the remarkable things about this paper is the size of the proofs.
While the refinement proofs (described [elsewhere][gu:osdi:2016]) are over 200K lines of proof, the security proofs in this paper are just over 6K lines of proof.
I think that the reason that they are so small comes from two things.

1.  mCertiKOS is deterministic and is isomorphic to its
    specification.
    This means that they only/mostly need to prove that
    the specification satisfies their security specification.
    This allows them to leverage their existing, voluminous
    refinement proofs that the implementation satisfies
    the functional specification.

2. The proof is limited to a restricted subset of mCertiKOS that 
   omits inter-processor communication.
   Omitting IPC eliminates a lot of information flow which makes
   it simpler to state and prove the security properties.
   But omitting IPC also eliminates a lot of the useful behaviour
   of an operating system leaving you with little more than
   time-sharing.
   
The framework used is a variant of Sabelfield and Sand's PER model
and fits into the classic pattern of "non-interference" proofs.
The framework used is more general than is required for the proof
about mCertiKOS that seems to be based on a static labelling of
each component of the state as being part of one process or another.
This static labelling seems to cause some difficulty as shared
pieces of state such as machine registers need to change labels
on every context switch.



[information flow]: #notes-information-flow
[gu:osdi:2016]: #papers-gu-osdi-2016
# An abstract interpretation framework for refactoring with application to extract methods with contracts {#papers-cousot-oopsla-2012}


Patrick Cousot, Radhia Cousot, Francesco Logozzo, Mike Barnett
Proceedings of the 27th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA 2012
ACM
Pages 213-232
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=An%20abstract%20interpretation%20framework%20for%20refactoring%20with%20application%20to%20extract%20methods%20with%20contracts)
[[DBLP]](https://dblp.org/search?q=An%20abstract%20interpretation%20framework%20for%20refactoring%20with%20application%20to%20extract%20methods%20with%20contracts)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=An%20abstract%20interpretation%20framework%20for%20refactoring%20with%20application%20to%20extract%20methods%20with%20contracts)
[[doi]](https://doi.org/10.1145/2384616.2384633)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-1561-6)

Notes: 
[abstract interpretation](#abstract interpretation)\


There is a lot to recommend Design by Contract where each function/method is equipped with contracts (pre/post-conditions).
But the cost is that you have to create and maintain all those contracts.
This paper addresses an interesting part of the problem that arises while refactoring code: creating a contract for any functions/methods extracted.
The insight here is that this is really a matter of refactoring the proof that the original code meets its contracts.
The goal they set is that the new contract must meet four criteria:
validity, safety, completeness and generality.

The basic approach taken is to use a combination of over- and under-approximation and forward and backward analyses to produce the weakest precondition and the strongest postcondition.

Their goal is a method that can work with a variety of specification logics: first order, separation logic, region logic, ...
So they create a generalization of Hoare logic to abstract over properties these all share: algebraic Hoare logic.

The main body is fairly dense with definitions: Galois connections, abstract domains, pre/post-condition abstract domains, predicate transformers, abstract Hoare logic, 
contracts, partial orders on contracts, etc.

There is also a section about the implementation and experiments that is about 2 pages long.  It would have been great to hear more here - it sounds like it was a *lot* of work.




[abstract interpretation]: #notes-abstract-interpretation
# Frama-C: A software analysis perspective {#papers-cuoq-sefm-2012}


Pascal Cuoq, Florent Kirchner, Nikolai Kosmatov, Virgile Prevosto, Julien Signoles, Boris Yakobowski, Patrick Baudin, Richard Bonichon, Bernard Botella, Loïc Correnson, Zaynah Dargaye, Philippe Herrmann, Benjamin Monate, Yannick Moy, Anne Pacalet, Armand Puccetti, Muriel Roger, Nicky Williams
International Conference on Software Engineering and Formal Methods
Springer
Pages 233-247
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=Frama-C%3A%20A%20software%20analysis%20perspective)
[[DBLP]](https://dblp.org/search?q=Frama-C%3A%20A%20software%20analysis%20perspective)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Frama-C%3A%20A%20software%20analysis%20perspective)
[[doi]](https://doi.org/10.1007/s00165-014-0326-7)

Notes: 
[abstract interpretation](#abstract interpretation),
[Frama-C verifier](#Frama-C verifier),
[Why3 verifier](#Why3 verifier)\
Referenced by: 
[papers/filliatre:fem:2004](#papers-filliatre-fem-2004),
[papers/mangano:crisis:2016](#papers-mangano-crisis-2016),
[notes/frama-c-verifier](#notes-frama-c-verifier)\


Frama-C is a platform for verifying C programs.
This foundational article describes the architecture of this platform,
the analyses built into Frama-C and the additional plugins that can be used
with it and provides references to those other plugins.
The paper cites many related papers about individual plugins and
case studies.

The core of Frama-C is the ACSL specification language that can be used for
classic Hoare-logic like statements (first order logic + arith + pointers/separation).
In addition, functions can state which locations they modify.

The kernel of Frama-C consists of support for generating messages, logging user actions for later audit (and replay?), running independent transforms in parallel (e.g., to analyse with different parameters).
In addition, there are three key analyses that lay a foundation for other analyses:
* Value is a forwards abstract interpreter that tracks whether a location is initialized, dangling and anything known about the value (e.g., its range or "x%4 == 3").
* WP is a deductive verification plug-in that calculates weakest preconditions and discharges the resulting verification conditions using the Alt-Ergo SMT solver, Coq or Why (which can invoke several different backends).  WP provides a choice of memory models based on how complex the pointer dereferencing and casting/unions are in the code being analyzed.
* PathCrawler is a concolic testing plugin that enumerates paths and explores them using bounds on loop iterations to prune the number of paths.

The Value analysis also generates information about dependencies, write sets, etc. that other plugins can use to determine which statements are affected by or could affect some other statement and to generate program srlices either as a diagnostic aid or for more refined analyses.

Some additional plugins are
* Aoraï converts LTL formulae about function call sequences into ACSL annotations that are inserted into the program.
* Sante uses testing to confirm that any alarms are true bugs and not false alarms.  This uses a combination of Value to generate alarms, slicing to reduce the program to the parts needed by each alarm and PathCrawler to explore the paths within each slice.



[abstract interpretation]: #notes-abstract-interpretation
[Frama-C verifier]: #notes-frama-c-verifier
[Why3 verifier]: #notes-why3-verifier
# Event-driven programming for robust software {#papers-dabek-sigops-2002}


Frank Dabek, Nickolai Zeldovich, M. Frans Kaashoek, David Mazières, Robert Morris
Proceedings of the 10th Workshop on ACM SIGOPS European Workshop
EW 10
Saint-Emilion, France
ACM
New York, NY, USA
Pages 186-189
2002
[[Google Scholar]](https://scholar.google.com/scholar?q=Event-driven%20programming%20for%20robust%20software)
[[DBLP]](https://dblp.org/search?q=Event-driven%20programming%20for%20robust%20software)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Event-driven%20programming%20for%20robust%20software)
[[doi]](https://doi.org/10.1145/1133373.1133410)

Notes: 
[events](#events),
[threads](#threads)\



[events]: #notes-events
[threads]: #notes-threads
# Automatically partitioning packet processing applications for pipelined architectures {#papers-dai-pldi-2005}


Jinquan Dai, Bo Huang, Long Li, Luddy Harrison
Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation
PLDI '05
Chicago, IL, USA
ACM
New York, NY, USA
Pages 237-248
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=Automatically%20partitioning%20packet%20processing%20applications%20for%20pipelined%20architectures)
[[DBLP]](https://dblp.org/search?q=Automatically%20partitioning%20packet%20processing%20applications%20for%20pipelined%20architectures)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automatically%20partitioning%20packet%20processing%20applications%20for%20pipelined%20architectures)
[[doi]](https://doi.org/10.1145/1065010.1065039)
[[ISBN]](http://books.google.com/books?vid=ISBN1-59593-056-6)

Notes: 
[threads](#threads),
[pipeline parallelism](#pipeline parallelism)\



[threads]: #notes-threads
[pipeline parallelism]: #notes-pipeline-parallelism
# Simulation of a horizontal bit-sliced processor using the ISPS architecture simulation facility {#papers-dam-ieeetc-1981}


Andries van Dam, Mario R. Barbacci, Constantine Halatsis, J. Joosten, M. Letheren
Pages 513-519
1981
[[Google Scholar]](https://scholar.google.com/scholar?q=Simulation%20of%20a%20horizontal%20bit-sliced%20processor%20using%20the%20ISPS%20architecture%20simulation%20facility)
[[DBLP]](https://dblp.org/search?q=Simulation%20of%20a%20horizontal%20bit-sliced%20processor%20using%20the%20ISPS%20architecture%20simulation%20facility)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Simulation%20of%20a%20horizontal%20bit-sliced%20processor%20using%20the%20ISPS%20architecture%20simulation%20facility)
[[doi]](https://doi.org/10.1109/TC.1981.1675830)
[[url]](https://doi.org/10.1109/TC.1981.1675830)

Notes: 
[ISPS](#ISPS)\



[ISPS]: #notes-isps
# Machine code verification of a tiny ARM hypervisor {#papers-dam-ted-2013}


Mads Dam, Roberto Guanciale, Hamed Nemati
Proceedings of the 3rd International Workshop on Trustworthy Embedded Devices
TrustED '13
Berlin, Germany
ACM
New York, NY, USA
Pages 3-12
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Machine%20code%20verification%20of%20a%20tiny%20ARM%20hypervisor)
[[DBLP]](https://dblp.org/search?q=Machine%20code%20verification%20of%20a%20tiny%20ARM%20hypervisor)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Machine%20code%20verification%20of%20a%20tiny%20ARM%20hypervisor)
[[doi]](https://doi.org/10.1145/2517300.2517302)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-2486-1)

Notes: 
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture)\




[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
# Machine code verification of a tiny ARM hypervisor {#papers-dam-trusted-2013}


Mads Dam, Roberto Guanciale, Hamed Nemati
Proceedings of the 3rd international workshop on Trustworthy embedded devices
ACM
Pages 3-12
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Machine%20code%20verification%20of%20a%20tiny%20ARM%20hypervisor)
[[DBLP]](https://dblp.org/search?q=Machine%20code%20verification%20of%20a%20tiny%20ARM%20hypervisor)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Machine%20code%20verification%20of%20a%20tiny%20ARM%20hypervisor)
[[doi]](https://doi.org/10.1145/2517300.2517302)

Notes: 
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture)\




[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
# LSCs: Breathing life into message sequence charts {#papers-damm-fmoods-1999}


Werner Damm, David Harel
Formal Methods for Open Object-Based Distributed Systems, IFIF TC6/WG6.1 Third International Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS), February 15-18, 1999, Florence, Italy
IFIP Conference Proceedings, volume 139
Kluwer
1999
[[Google Scholar]](https://scholar.google.com/scholar?q=LSCs%3A%20Breathing%20life%20into%20message%20sequence%20charts)
[[DBLP]](https://dblp.org/search?q=LSCs%3A%20Breathing%20life%20into%20message%20sequence%20charts)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=LSCs%3A%20Breathing%20life%20into%20message%20sequence%20charts)
[[doi]](https://doi.org/10.1023/A:1011227529550)

Notes: 
[formal specification](#formal specification)\



[formal specification]: #notes-formal-specification
# A complete formal semantics of x86-64 user-level instruction set architecture {#papers-dasgupta-pldi-2019}


Sandeep Dasgupta, Vikram Adve
Proceedings of the 2019 ACM SIGPLAN Conference on Programming Language Design and Implementation
PLDI '19
ACM
Pages 1103-1118
June
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20complete%20formal%20semantics%20of%20x86-64%20user-level%20instruction%20set%20architecture)
[[DBLP]](https://dblp.org/search?q=A%20complete%20formal%20semantics%20of%20x86-64%20user-level%20instruction%20set%20architecture)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20complete%20formal%20semantics%20of%20x86-64%20user-level%20instruction%20set%20architecture)
[[doi]](https://doi.org/10.1145/3314221.3314601)

Notes: 
[ISA specification](#ISA specification),
[x86 architecture](#x86 architecture),
[instruction set architecture](#instruction set architecture)\




[ISA specification]: #notes-isa-specification
[x86 architecture]: #notes-x86-architecture
[instruction set architecture]: #notes-instruction-set-architecture
# Formal specification of the x86 instruction set architecture {#papers-degenbaev-phd-2012}


Ulan Degenbaev
Ph.D. thesis
Universität des Saarlandes
Postfach 151141, 66041 Saarbrücken
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=Formal%20specification%20of%20the%20x86%20instruction%20set%20architecture)
[[DBLP]](https://dblp.org/search?q=Formal%20specification%20of%20the%20x86%20instruction%20set%20architecture)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Formal%20specification%20of%20the%20x86%20instruction%20set%20architecture)
[[url]](http://scidok.sulb.uni-saarland.de/volltexte/2012/4707)

Notes: 
[ISA specification](#ISA specification),
[x86 architecture](#x86 architecture),
[instruction set architecture](#instruction set architecture)\




[ISA specification]: #notes-isa-specification
[x86 architecture]: #notes-x86-architecture
[instruction set architecture]: #notes-instruction-set-architecture
# Enforcing high-level protocols in low-level software {#papers-deline-pldi-2001}


Robert DeLine, Manuel Fähndrich
Proceedings of the ACM SIGPLAN 2001 Conference on Programming Language Design and Implementation
PLDI'01
Snowbird, Utah, USA
Association for Computing Machinery
New York, NY, USA
Pages 59--69
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=Enforcing%20high-level%20protocols%20in%20low-level%20software)
[[DBLP]](https://dblp.org/search?q=Enforcing%20high-level%20protocols%20in%20low-level%20software)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Enforcing%20high-level%20protocols%20in%20low-level%20software)
[[doi]](https://doi.org/10.1145/378795.378811)
[[ISBN]](http://books.google.com/books?vid=ISBN1581134142)
[[url]](https://doi.org/10.1145/378795.378811)

Notes: 
[contract driven development](#contract driven development),
[permission logic](#permission logic),
[spec-sharp-project](#spec-sharp-project)\




[contract driven development]: #notes-contract-driven-development
[permission logic]: #notes-permission-logic
[spec-sharp-project]: #notes-spec-sharp-project
# Satisfiability modulo theories: Introduction and applications {#papers-demoura-cacm-2011}


Leonardo de Moura, Nikolaj Bjørner
Association for Computing Machinery
New York, NY, USA
Pages 69-77
September
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=Satisfiability%20modulo%20theories%3A%20Introduction%20and%20applications)
[[DBLP]](https://dblp.org/search?q=Satisfiability%20modulo%20theories%3A%20Introduction%20and%20applications)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Satisfiability%20modulo%20theories%3A%20Introduction%20and%20applications)
[[doi]](https://doi.org/10.1145/1995376.1995394)
[[url]](https://doi.org/10.1145/1995376.1995394)

Notes: 
[SAT solver](#SAT solver),
[SMT solver](#SMT solver),
[survey](#survey)\
Papers: 
[malik:cacm:2009](#malik-cacm-2009)\
Referenced by: 
[papers/malik:cacm:2009](#papers-malik-cacm-2009)\


This paper is a great intro/overview of [SMT solver]: what it is, how it builds
on SAT, an example of how one particular theory (difference arithmetic) is
implemented, and the many applications of SMT solvers in program analysis,
program verification, etc.

Worth reading in conjunction with the [SAT solver] intro/overview in
[malik:cacm:2009],



[SAT solver]: #notes-sat-solver
[SMT solver]: #notes-smt-solver
[survey]: #notes-survey
[malik:cacm:2009]: #papers-malik-cacm-2009
# The Lean theorem prover (system description) {#papers-demoura-cade-2015}


Leonardo de Moura, Soonho Kong, Jeremy Avigad, Floris Van Doorn, Jakob von Raumer
International Conference on Automated Deduction
Springer
Pages 378-388
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20Lean%20theorem%20prover%20%28system%20description%29)
[[DBLP]](https://dblp.org/search?q=The%20Lean%20theorem%20prover%20%28system%20description%29)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20Lean%20theorem%20prover%20%28system%20description%29)
[[doi]](https://doi.org/10.1007/978-3-319-21401-6_26)

Notes: 
[Lean theorem prover](#Lean theorem prover),
[interactive theorem prover](#interactive theorem prover)\
Referenced by: 
[papers/ullrich:msc:2016](#papers-ullrich-msc-2016)\




[Lean theorem prover]: #notes-lean-theorem-prover
[interactive theorem prover]: #notes-interactive-theorem-prover
# Z3: An efficient SMT solver {#papers-demoura-tacas-2008}


Leonardo de Moura, Nikolaj Bjørner
International conference on Tools and Algorithms for the Construction and Analysis of Systems
Springer
Pages 337-340
2008
[[Google Scholar]](https://scholar.google.com/scholar?q=Z3%3A%20An%20efficient%20SMT%20solver)
[[DBLP]](https://dblp.org/search?q=Z3%3A%20An%20efficient%20SMT%20solver)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Z3%3A%20An%20efficient%20SMT%20solver)
[[doi]](https://doi.org/10.1007/978-3-540-78800-3_24)

Notes: 
[SMT solver](#SMT solver),
[Z3 solver](#Z3 solver)\
Referenced by: 
[papers/baranowski:atva:2018](#papers-baranowski-atva-2018),
[papers/barnett:cacm:2011](#papers-barnett-cacm-2011),
[papers/deng:hasp:2019](#papers-deng-hasp-2019),
[papers/leino:lpair:2010](#papers-leino-lpair-2010),
[papers/nelson:sosp:2019](#papers-nelson-sosp-2019),
[papers/zhang:asplos:2015](#papers-zhang-asplos-2015),
[notes/z3-solver](#notes-z3-solver)\




[SMT solver]: #notes-smt-solver
[Z3 solver]: #notes-z3-solver
# SecChisel: Language and tool for practical and scalable security verification of security-aware hardware architectures {#papers-deng-hasp-2019}


Shuwen Deng, Doğuhan Gümüşoğlu, Wenjie Xiong, Sercan Sari, Y. Serhan Gener, Corine Lu, Onur Demir, Jakub Szefer
Proceedings of the 8th International Workshop on Hardware and Architectural Support for Security and Privacy
ACM
Pages 7:1-7:8
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=SecChisel%3A%20Language%20and%20tool%20for%20practical%20and%20scalable%20security%20verification%20of%20security-aware%20hardware%20architectures)
[[DBLP]](https://dblp.org/search?q=SecChisel%3A%20Language%20and%20tool%20for%20practical%20and%20scalable%20security%20verification%20of%20security-aware%20hardware%20architectures)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=SecChisel%3A%20Language%20and%20tool%20for%20practical%20and%20scalable%20security%20verification%20of%20security-aware%20hardware%20architectures)
[[doi]](https://doi.org/10.1145/3337167.3337174)

Notes: 
[information flow](#information flow)\
Papers: 
[demoura:tacas:2008](#demoura-tacas-2008)\


Extends Chisel with security labels to track information flow.
Uses [the Z3 SMT solver][demoura:tacas:2008]
to check but check is based on syntactic structure, not on semantic analysis.
That is, it just propagates labels.
Suggests this is important for performance.

Sketches several optimisations — I would have liked to have had more detail here.
There seem to be several strategies for labelling each module: explicitly label all flops; explicitly label inputs and outputs of module and scan internal connectivity to check for flow; programmer sketches abstract connectivity by specifying which inputs are connected to which outputs as a matrix.  It is not clear whether hybrids of these are supported.
The paper seems like an early report with many unimplemented features (dynamic labelling, nested modules, Chisel 3 support) and no case study to demonstrate/test/evaluate design choices.
Related work discusses a lot of other security related hardware description languages.



[information flow]: #notes-information-flow
[demoura:tacas:2008]: #papers-demoura-tacas-2008
# A lattice model of secure information flow {#papers-denning-cacm-1976}


Dorothy E. Denning
ACM
New York, NY, USA
Pages 236-243
May
1976
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20lattice%20model%20of%20secure%20information%20flow)
[[DBLP]](https://dblp.org/search?q=A%20lattice%20model%20of%20secure%20information%20flow)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20lattice%20model%20of%20secure%20information%20flow)
[[doi]](https://doi.org/10.1145/360051.360056)

Notes: 
[information flow](#information flow)\




[information flow]: #notes-information-flow
# Automatically generating instruction selectors using declarative machine descriptions {#papers-dias-popl-2010}


João Dias, Norman Ramsey
Proceedings of the 37th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
POPL '10
Madrid, Spain
Association for Computing Machinery
New York, NY, USA
Pages 403-416
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=Automatically%20generating%20instruction%20selectors%20using%20declarative%20machine%20descriptions)
[[DBLP]](https://dblp.org/search?q=Automatically%20generating%20instruction%20selectors%20using%20declarative%20machine%20descriptions)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automatically%20generating%20instruction%20selectors%20using%20declarative%20machine%20descriptions)
[[doi]](https://doi.org/10.1145/1706299.1706346)
[[ISBN]](http://books.google.com/books?vid=ISBN9781605584799)
[[url]](https://doi.org/10.1145/1706299.1706346)

Notes: 
[ISA specification](#ISA specification),
[SLED](#SLED)\



[ISA specification]: #notes-isa-specification
[SLED]: #notes-sled
# Study of integrating random and symbolic testing for object-oriented software {#papers-dimjasevic-ifm-2018}


Marko Dimjašević, Falk Howar, Kasper Luckow, Zvonimir Rakamarić
Integrated Formal Methods
Springer International Publishing
Cham
Pages 89-109
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=Study%20of%20integrating%20random%20and%20symbolic%20testing%20for%20object-oriented%20software)
[[DBLP]](https://dblp.org/search?q=Study%20of%20integrating%20random%20and%20symbolic%20testing%20for%20object-oriented%20software)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Study%20of%20integrating%20random%20and%20symbolic%20testing%20for%20object-oriented%20software)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-319-98938-9)

Notes: 
[fuzz testing](#fuzz testing),
[symbolic execution](#symbolic execution),
[unit tests](#unit tests)\
Papers: 
[garg:icse:2013](#garg-icse-2013)\


Describes and evaluates JDOOP: a hybrid fuzzer/symbolic executor for Java
that uses random search to quickly build coverage and symbolic execution to
hit hard to hit branch conditions.
JDOOP is a combination of RANDOOP and JDART.

As in [garg:icse:2013] the main goal is to generate sequences of method calls
that achieve high coverage.

One major barrier is the handling of non-Java code which, unfortunately
includes Java string functions `charAt` and `indexOf`.
These are not treated symbolically: the tool has a choice of either
returning a symbolic return value or of concretizing inputs and running
concretely.



[fuzz testing]: #notes-fuzz-testing
[symbolic execution]: #notes-symbolic-execution
[unit tests]: #notes-unit-tests
[garg:icse:2013]: #papers-garg-icse-2013
# Views: Compositional reasoning for concurrent programs {#papers-dinsdale-young-popl-2013}


Thomas Dinsdale-Young, Lars Birkedal, Philippa Gardner, Matthew Parkinson, Hongseok Yang
Proceedings of the 40th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
POPL '13
Rome, Italy
Association for Computing Machinery
New York, NY, USA
Pages 287-300
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Views%3A%20Compositional%20reasoning%20for%20concurrent%20programs)
[[DBLP]](https://dblp.org/search?q=Views%3A%20Compositional%20reasoning%20for%20concurrent%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Views%3A%20Compositional%20reasoning%20for%20concurrent%20programs)
[[doi]](https://doi.org/10.1145/2429069.2429104)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450318327)
[[url]](https://doi.org/10.1145/2429069.2429104)

Notes: 
[permission logic](#permission logic)\




[permission logic]: #notes-permission-logic
# A local shape analysis based on separation logic {#papers-distefano-tacas-2006}


Dino Distefano, Peter W. O'Hearn, Hongseok Yang
International Conference on Tools and Algorithms for the Construction and Analysis of Systems
Springer
Pages 287-302
2006
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20local%20shape%20analysis%20based%20on%20separation%20logic)
[[DBLP]](https://dblp.org/search?q=A%20local%20shape%20analysis%20based%20on%20separation%20logic)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20local%20shape%20analysis%20based%20on%20separation%20logic)

Notes: 
[permission logic](#permission logic),
[separation logic](#separation logic)\




[permission logic]: #notes-permission-logic
[separation logic]: #notes-separation-logic
# A PMS level notation for the description and simulation of digital systems {#papers-djordjevic-cj-1985}


Jovan Djordjevic, Mario R. Barbacci, Brad Hosler
Pages 357-365
1985
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20PMS%20level%20notation%20for%20the%20description%20and%20simulation%20of%20digital%20systems)
[[DBLP]](https://dblp.org/search?q=A%20PMS%20level%20notation%20for%20the%20description%20and%20simulation%20of%20digital%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20PMS%20level%20notation%20for%20the%20description%20and%20simulation%20of%20digital%20systems)
[[doi]](https://doi.org/10.1093/comjnl/28.4.357)
[[url]](https://doi.org/10.1093/comjnl/28.4.357)

Notes: 
[ISPS](#ISPS)\



[ISPS]: #notes-isps
# Using continuations to implement thread management and communication in operating systems {#papers-draves-sosp-1991}


Richard P. Draves, Brian N. Bershad, Richard F. Rashid, Randall W. Dean
Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles
SOSP '91
Pacific Grove, California, USA
ACM
New York, NY, USA
Pages 122-136
1991
[[Google Scholar]](https://scholar.google.com/scholar?q=Using%20continuations%20to%20implement%20thread%20management%20and%20communication%20in%20operating%20systems)
[[DBLP]](https://dblp.org/search?q=Using%20continuations%20to%20implement%20thread%20management%20and%20communication%20in%20operating%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Using%20continuations%20to%20implement%20thread%20management%20and%20communication%20in%20operating%20systems)
[[doi]](https://doi.org/10.1145/121132.121155)
[[ISBN]](http://books.google.com/books?vid=ISBN0-89791-447-3)

Notes: 
[continuations](#continuations),
[operating systems](#operating systems),
[threads](#threads)\
Referenced by: 
[notes/continuations](#notes-continuations)\



[continuations]: #notes-continuations
[operating systems]: #notes-operating-systems
[threads]: #notes-threads
# Compiler support for exploiting coarse-grained pipelined parallelism. {#papers-du-sc-2003}


Wei Du, Renato Ferreira, Gagan Agrawal
Proceedings of Conference on High Performance Networking and Computing (SC2003)
Pages 8
2003
[[Google Scholar]](https://scholar.google.com/scholar?q=Compiler%20support%20for%20exploiting%20coarse-grained%20pipelined%20parallelism.)
[[DBLP]](https://dblp.org/search?q=Compiler%20support%20for%20exploiting%20coarse-grained%20pipelined%20parallelism.)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Compiler%20support%20for%20exploiting%20coarse-grained%20pipelined%20parallelism.)
[[doi]](https://doi.org/10.1145/1048935.1050159)

Notes: 
[pipeline parallelism](#pipeline parallelism)\



[pipeline parallelism]: #notes-pipeline-parallelism
# Protothreads: Simplifying Event-driven Programming of Memory-constrained Embedded Systems {#papers-dunkels-enss-2006}


Adam Dunkels, Oliver Schmidt, Thiemo Voigt, Muneeb Ali
Proceedings of the 4th International Conference on Embedded Networked Sensor Systems
SenSys '06
Boulder, Colorado, USA
ACM
New York, NY, USA
Pages 29-42
2006
[[Google Scholar]](https://scholar.google.com/scholar?q=Protothreads%3A%20Simplifying%20Event-driven%20Programming%20of%20Memory-constrained%20Embedded%20Systems)
[[DBLP]](https://dblp.org/search?q=Protothreads%3A%20Simplifying%20Event-driven%20Programming%20of%20Memory-constrained%20Embedded%20Systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Protothreads%3A%20Simplifying%20Event-driven%20Programming%20of%20Memory-constrained%20Embedded%20Systems)
[[doi]](https://doi.org/10.1145/1182807.1182811)
[[ISBN]](http://books.google.com/books?vid=ISBN1-59593-343-3)

Notes: 
[threads](#threads),
[events](#events)\



[threads]: #notes-threads
[events]: #notes-events
# Labels and event processes in the Asbestos operating system {#papers-efstathopoulos-sosp-2005}


Petros Efstathopoulos, Maxwell Krohn, Steve VanDeBogart, Cliff Frey, David Ziegler, Eddie Kohler, David Mazières, M. Frans Kaashoek, Robert Morris
Proceedings of the Twentieth ACM Symposium on Operating Systems Principles
SOSP'05
Brighton, United Kingdom
ACM
New York, NY, USA
Pages 17-30
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=Labels%20and%20event%20processes%20in%20the%20Asbestos%20operating%20system)
[[DBLP]](https://dblp.org/search?q=Labels%20and%20event%20processes%20in%20the%20Asbestos%20operating%20system)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Labels%20and%20event%20processes%20in%20the%20Asbestos%20operating%20system)
[[doi]](https://doi.org/10.1145/1095810.1095813)
[[ISBN]](http://books.google.com/books?vid=ISBN1-59593-079-5)

Notes: 
[information flow](#information flow)\
Referenced by: 
[papers/spencer:security:1999](#papers-spencer-security-1999)\




[information flow]: #notes-information-flow
# Aspect weaving as component knitting: Separating concerns with Knit {#papers-eide-aspse-2001}


Eric Eide, Alastair D. Reid, Matthew Flatt, Jay Lepreau
Workshop on Advanced Separation of Concerns in Software Engineering
Toronto, Ontario, Canada
May
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=Aspect%20weaving%20as%20component%20knitting%3A%20Separating%20concerns%20with%20Knit)
[[DBLP]](https://dblp.org/search?q=Aspect%20weaving%20as%20component%20knitting%3A%20Separating%20concerns%20with%20Knit)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Aspect%20weaving%20as%20component%20knitting%3A%20Separating%20concerns%20with%20Knit)

Notes: 
[operating systems](#operating systems),
[Domain Specific Language](#Domain Specific Language)\
Papers: 
[reid:osdi:2000](#reid-osdi-2000)\




[operating systems]: #notes-operating-systems
[Domain Specific Language]: #notes-domain-specific-language
[reid:osdi:2000]: #papers-reid-osdi-2000
# Static and dynamic structure in design patterns {#papers-eide-icse-2002}


Eric Eide, Alastair D. Reid, John Regehr, Jay Lepreau
Proceedings of the 24th International Conference on Software Engineering (ICSE 2002)
Orlando, Florida, USA
ACM
Pages 208-218
19-25
May
2002
[[Google Scholar]](https://scholar.google.com/scholar?q=Static%20and%20dynamic%20structure%20in%20design%20patterns)
[[DBLP]](https://dblp.org/search?q=Static%20and%20dynamic%20structure%20in%20design%20patterns)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Static%20and%20dynamic%20structure%20in%20design%20patterns)
[[doi]](https://doi.org/10.1145/581339.581367)

Notes: 
[operating systems](#operating systems),
[Domain Specific Language](#Domain Specific Language)\
Papers: 
[reid:osdi:2000](#reid-osdi-2000)\




[operating systems]: #notes-operating-systems
[Domain Specific Language]: #notes-domain-specific-language
[reid:osdi:2000]: #papers-reid-osdi-2000
# Locking discipline inference and checking {#papers-ernst-icse-2016}


Michael D. Ernst, Alberto Lovato, Damiano Macedonio, Fausto Spoto, Javier Thaine
2016 IEEE/ACM 38th International Conference on Software Engineering (ICSE)
IEEE
Pages 1133-1144
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Locking%20discipline%20inference%20and%20checking)
[[DBLP]](https://dblp.org/search?q=Locking%20discipline%20inference%20and%20checking)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Locking%20discipline%20inference%20and%20checking)
[[doi]](https://doi.org/10.1145/2884781.2884882)





# Static contract checking with abstract interpretation {#papers-fahndrich-foveoos-2010}


Manuel Fähndrich, Francesco Logozzo
International Conference on Formal Verification of Object-oriented Software
Springer
Pages 10-30
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=Static%20contract%20checking%20with%20abstract%20interpretation)
[[DBLP]](https://dblp.org/search?q=Static%20contract%20checking%20with%20abstract%20interpretation)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Static%20contract%20checking%20with%20abstract%20interpretation)
[[doi]](https://doi.org/10.1007/978-3-642-18070-5_2)

Notes: 
[contract driven development](#contract driven development),
[abstract interpretation](#abstract interpretation)\
Referenced by: 
[papers/barnett:cacm:2011](#papers-barnett-cacm-2011),
[notes/contract-driven-development](#notes-contract-driven-development)\




[contract driven development]: #notes-contract-driven-development
[abstract interpretation]: #notes-abstract-interpretation
# A formal description of SYSTEM/360 {#papers-falkoff-ibm-1964}


Adin D. Falkoff, Kenneth E. Iverson, Edward H. Sussenguth
IBM Corp.
Riverton, NJ, USA
Pages 198-261
June
1964
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20formal%20description%20of%20SYSTEM/360)
[[DBLP]](https://dblp.org/search?q=A%20formal%20description%20of%20SYSTEM/360)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20formal%20description%20of%20SYSTEM/360)
[[doi]](https://doi.org/10.1147/sj.32.0198)

Notes: 
[ISA specification](#ISA specification),
[formal specification](#formal specification)\




[ISA specification]: #notes-isa-specification
[formal specification]: #notes-formal-specification
# Describing instruction set processors using nML {#papers-fauth-edtc-1995}


Andreas Fauth, Johan Van Praet, Markus Freericks
Proceedings European Design and Test Conference, 1995. ED&TC 1995
IEEE
Pages 503-507
1995
[[Google Scholar]](https://scholar.google.com/scholar?q=Describing%20instruction%20set%20processors%20using%20nML)
[[DBLP]](https://dblp.org/search?q=Describing%20instruction%20set%20processors%20using%20nML)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Describing%20instruction%20set%20processors%20using%20nML)
[[doi]](https://doi.org/10.1109/EDTC.1995.470354)

Notes: 
[ISA specification](#ISA specification),
[formal specification](#formal specification),
[microarchitecture](#microarchitecture)\



[ISA specification]: #notes-isa-specification
[formal specification]: #notes-formal-specification
[microarchitecture]: #notes-microarchitecture
# Automatic checking of instruction specifications {#papers-fernandez-icse-1997}


Mary F. Fernández, Norman Ramsey
Proceedings of the 19th International Conference on Software Engineering
ICSE '97
Boston, Massachusetts, USA
Association for Computing Machinery
New York, NY, USA
Pages 326-336
1997
[[Google Scholar]](https://scholar.google.com/scholar?q=Automatic%20checking%20of%20instruction%20specifications)
[[DBLP]](https://dblp.org/search?q=Automatic%20checking%20of%20instruction%20specifications)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automatic%20checking%20of%20instruction%20specifications)
[[doi]](https://doi.org/10.1145/253228.253300)
[[ISBN]](http://books.google.com/books?vid=ISBN0897919149)
[[url]](https://doi.org/10.1145/253228.253300)

Notes: 
[ISA specification](#ISA specification),
[SLED](#SLED)\



[ISA specification]: #notes-isa-specification
[SLED]: #notes-sled
# Verification of a practical hardware security architecture through static information flow analysis {#papers-ferraiuolo-asplos-2017}


Andrew Ferraiuolo, Rui Xu, Danfeng Zhang, Andrew C. Myers, G. Edward Suh
ACM SIGARCH Computer Architecture News
ACM
Pages 555-568
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=Verification%20of%20a%20practical%20hardware%20security%20architecture%20through%20static%20information%20flow%20analysis)
[[DBLP]](https://dblp.org/search?q=Verification%20of%20a%20practical%20hardware%20security%20architecture%20through%20static%20information%20flow%20analysis)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Verification%20of%20a%20practical%20hardware%20security%20architecture%20through%20static%20information%20flow%20analysis)
[[doi]](https://doi.org/10.1145/3037697.3037739)

Notes: 
[information flow](#information flow)\





[information flow]: #notes-information-flow
# HyperFlow: A processor architecture for nonmalleable, timing-safe information flow security {#papers-ferraiuolo-ccs-2018}


Andrew Ferraiuolo, Mark Zhao, G. Edward Suh, Andrew C. Myers
Proceedings of the 2018 ACM SIGSAC Conference on Computer and  Communications Security, CCS 2018
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=HyperFlow%3A%20A%20processor%20architecture%20for%20nonmalleable%2C%20timing-safe%20information%20flow%20security)
[[DBLP]](https://dblp.org/search?q=HyperFlow%3A%20A%20processor%20architecture%20for%20nonmalleable%2C%20timing-safe%20information%20flow%20security)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=HyperFlow%3A%20A%20processor%20architecture%20for%20nonmalleable%2C%20timing-safe%20information%20flow%20security)
[[doi]](https://doi.org/10.1145/3243734.3243743)

Notes: 
[information flow](#information flow)\




[information flow]: #notes-information-flow
# Secure information flow verification with mutable dependent types {#papers-ferraiuolo-dac-2017}


Andrew Ferraiuolo, Weizhe Hua, Andrew C. Myers, G. Edward Suh
Proceedings of the 54th Annual Design Automation Conference 2017
ACM
Pages 6
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=Secure%20information%20flow%20verification%20with%20mutable%20dependent%20types)
[[DBLP]](https://dblp.org/search?q=Secure%20information%20flow%20verification%20with%20mutable%20dependent%20types)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Secure%20information%20flow%20verification%20with%20mutable%20dependent%20types)
[[doi]](https://doi.org/10.1145/3061639.3062316)

Notes: 
[information flow](#information flow),
[dependent type](#dependent type)\




[information flow]: #notes-information-flow
[dependent type]: #notes-dependent-type
# Komodo: Using verification to disentangle secure-enclave hardware from software {#papers-ferraiuolo-sosp-2017}


Andrew Ferraiuolo, Andrew Baumann, Chris Hawblitzel, Bryan Parno
Proceedings of the 26th Symposium on Operating Systems Principles
ACM
Pages 287-305
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=Komodo%3A%20Using%20verification%20to%20disentangle%20secure-enclave%20hardware%20from%20software)
[[DBLP]](https://dblp.org/search?q=Komodo%3A%20Using%20verification%20to%20disentangle%20secure-enclave%20hardware%20from%20software)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Komodo%3A%20Using%20verification%20to%20disentangle%20secure-enclave%20hardware%20from%20software)
[[doi]](https://doi.org/10.1145/3132747.3132782)

Notes: 
[information flow](#information flow)\
Papers: 
[leino:lpair:2010](#leino-lpair-2010),
[nelson:sosp:2019](#nelson-sosp-2019)\
Referenced by: 
[notes/non-interference](#notes-non-interference)\


Komodo implements functionality similar to SGX but is implemented in formally verified software on ARMv7 processors instead of being implemented in hardware and microcode.
The introduction makes a very convincing argument that this is the right way to deploy security extensions because
it can be updated much faster,
and the verification is transparent ("it replaces folklore with formal verification").
They verify both functional properties and security properties (non-interference).
(Komodo lacks the memory encryption features of SGX – that would benefit from having hardware support.
Komodo is also limited to a single processor at the moment.)



Komodo is a small, simple monitor running in Arm's TrustZone secure mode.
It supports about 12 secure monitor calls (SMC) allowing the OS to create an enclave, provide the enclave with memory, initialize the enclave and stop an enclave.
It also supports 7 supervisor calls (SVC) allowing the enclave to perform attestations, allocate more memory and exit.

The Komodo verification is largely performed in [Dafny][leino:lpair:2010] and is based on:

- a (trusted) specification of a subset of ARMv7
- a (trusted) specification of Komodo's SMCs and SVCs
- a (trusted) specification of the allowed information flow

Although the proof is performed using Dafny, Dafny is (virtually) unused to write executable code.  Instead, Komodo is written in assembly code using Vale and the Vale tool generates proofs and ASTs that Dafny checks.

The paper describes subtleties around interrupts.
These are almost entirely disabled both to simplify the system and because the verification approach that is based on a linear control-flow model.
However, there is a one-instruction window at the start of a couple of exception handlers that is discussed at length.

Komodo as described here is a rewrite of an earlier prototype written in C and assembly (see [the Serval paper][nelson:sosp:2019]).
The current version in Vale took 2 person-years effort which should be compared with the effort required fir CertiKOS and seL.
The process of writing a specification and verifying the implementation revealed bugs in the original implementation.
They also ran into bugs associated with things omitted from their architecture specification such as the need for DSB/ISB barriers, cache issues and a bug in the code that dumped Vale assembly out as Arm assembly.

They report frustrating problems with the verification tools.
In particular, solver time increased exponentially with proof complexity and
they got no information from the tools to help them debug these issues.

[Note: I work with Andrew Ferraiuolo, the lead author on this paper.]



[information flow]: #notes-information-flow
[leino:lpair:2010]: #papers-leino-lpair-2010
[nelson:sosp:2019]: #papers-nelson-sosp-2019
# The Why/Krakatoa/Caduceus platform for deductive program verification {#papers-filliatre-cav-2007}


Jean-Christophe Filliâtre, Claude Marché
International Conference on Computer Aided Verification
Springer
Pages 173-177
2007
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20Why/Krakatoa/Caduceus%20platform%20for%20deductive%20program%20verification)
[[DBLP]](https://dblp.org/search?q=The%20Why/Krakatoa/Caduceus%20platform%20for%20deductive%20program%20verification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20Why/Krakatoa/Caduceus%20platform%20for%20deductive%20program%20verification)
[[doi]](https://doi.org/10.1007/978-3-540-73368-3_21)

Notes: 
[Why3 verifier](#Why3 verifier)\




[Why3 verifier]: #notes-why3-verifier
# Why3 — where programs meet provers {#papers-filliatre-esop-2013}


Jean-Christophe Filliâtre, Andrei Paskevich
European Symposium on Programming
Springer
Pages 125-128
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Why3%20%E2%80%94%20where%20programs%20meet%20provers)
[[DBLP]](https://dblp.org/search?q=Why3%20%E2%80%94%20where%20programs%20meet%20provers)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Why3%20%E2%80%94%20where%20programs%20meet%20provers)
[[doi]](https://doi.org/10.1007/978-3-642-37036-6_8)

Notes: 
[Why3 verifier](#Why3 verifier)\




[Why3 verifier]: #notes-why3-verifier
# Multi-prover verification of C programs {#papers-filliatre-fem-2004}


Jean-Christophe Filliâtre, Claude Marché
Sixth International Conference on Formal Engineering Methods
LNCS, volume 3308
Springer
Pages 15-29
2004
[[Google Scholar]](https://scholar.google.com/scholar?q=Multi-prover%20verification%20of%20C%20programs)
[[DBLP]](https://dblp.org/search?q=Multi-prover%20verification%20of%20C%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Multi-prover%20verification%20of%20C%20programs)
[[doi]](https://doi.org/10.1007/978-3-540-30482-1_10)

Notes: 
[Why3 verifier](#Why3 verifier)\
Papers: 
[cuoq:sefm:2012](#cuoq-sefm-2012)\
Referenced by: 
[papers/barnett:fmco:2005](#papers-barnett-fmco-2005),
[papers/philippaerts:scp:2014](#papers-philippaerts-scp-2014)\


Describes "Caduceus": a tool to translate C code to the WhyML specification
language lowering imperative code to pure code and handling pointers.
Introduced the specification notation that later became ACSL and a forerunner
to [Frama-C][cuoq:sefm:2012].

Given current understanding of undefined behaviour and implementation defined behaviour in C, the translation from C looks a bit naïve.



[Why3 verifier]: #notes-why3-verifier
[cuoq:sefm:2012]: #papers-cuoq-sefm-2012
# CSeq: a concurrency pre-processor for sequential C verification tools {#papers-fischer-ase-2013}


Bernd Fischer, Omar Inverso, Gennaro Parlato
Proceedings of the 28th IEEE/ACM International Conference on Automated Software Engineering
IEEE Press
Pages 710-713
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=CSeq%3A%20a%20concurrency%20pre-processor%20for%20sequential%20C%20verification%20tools)
[[DBLP]](https://dblp.org/search?q=CSeq%3A%20a%20concurrency%20pre-processor%20for%20sequential%20C%20verification%20tools)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=CSeq%3A%20a%20concurrency%20pre-processor%20for%20sequential%20C%20verification%20tools)
[[doi]](https://doi.org/10.1109/ASE.2013.6693139)





# Very long instruction word architectures and the ELI-512 {#papers-fisher-isca-1983}


Joseph A. Fisher
Proceedings of the 10th Annual International Symposium on Computer Architecture
ISCA '83
Stockholm, Sweden
ACM
New York, NY, USA
Pages 140-150
1983
[[Google Scholar]](https://scholar.google.com/scholar?q=Very%20long%20instruction%20word%20architectures%20and%20the%20ELI-512)
[[DBLP]](https://dblp.org/search?q=Very%20long%20instruction%20word%20architectures%20and%20the%20ELI-512)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Very%20long%20instruction%20word%20architectures%20and%20the%20ELI-512)
[[doi]](https://doi.org/10.1145/800046.801649)
[[ISBN]](http://books.google.com/books?vid=ISBN0-89791-101-6)

Notes: 
[VLIW](#VLIW),
[microarchitecture](#microarchitecture),
[instruction set architecture](#instruction set architecture)\



[VLIW]: #notes-vliw
[microarchitecture]: #notes-microarchitecture
[instruction set architecture]: #notes-instruction-set-architecture
# Modelling the ARMv8 architecture, operationally: concurrency and ISA {#papers-flur-popl-2016}


Shaked Flur, Kathryn E. Gray, Christopher Pulte, Susmit Sarkar, Ali Sezgin, Luc Maranget, Will Deacon, Peter Sewell
Proceedings Principles of Programming Languages, POPL 2016
Pages 608-621
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Modelling%20the%20ARMv8%20architecture%2C%20operationally%3A%20concurrency%20and%20ISA)
[[DBLP]](https://dblp.org/search?q=Modelling%20the%20ARMv8%20architecture%2C%20operationally%3A%20concurrency%20and%20ISA)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Modelling%20the%20ARMv8%20architecture%2C%20operationally%3A%20concurrency%20and%20ISA)
[[doi]](https://doi.org/10.1145/2837614.2837615)

Notes: 
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture)\




[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
# Very high-speed computing systems {#papers-flynn-ieeeproc-1966}


Michael J. Flynn
Pages 1901 - 1909
December
1966
[[Google Scholar]](https://scholar.google.com/scholar?q=Very%20high-speed%20computing%20systems)
[[DBLP]](https://dblp.org/search?q=Very%20high-speed%20computing%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Very%20high-speed%20computing%20systems)
[[doi]](https://doi.org/10.1109/PROC.1966.5273)

Notes: 
[SIMD](#SIMD),
[MIMD](#MIMD),
[data parallelism](#data parallelism)\
Referenced by: 
[notes/data-parallelism](#notes-data-parallelism),
[notes/mimd](#notes-mimd),
[notes/parallelism](#notes-parallelism),
[notes/simd](#notes-simd)\



[SIMD]: #notes-simd
[MIMD]: #notes-mimd
[data parallelism]: #notes-data-parallelism
# An empirical study on the correctness of formally verified distributed systems {#papers-fonseca-ecs-2017}


Pedro Fonseca, Kaiyuan Zhang, Xi Wang, Arvind Krishnamurthy
Proceedings of the Twelfth European Conference on Computer Systems
EuroSys '17
Belgrade, Serbia
ACM
New York, NY, USA
Pages 328-343
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=An%20empirical%20study%20on%20the%20correctness%20of%20formally%20verified%20distributed%20systems)
[[DBLP]](https://dblp.org/search?q=An%20empirical%20study%20on%20the%20correctness%20of%20formally%20verified%20distributed%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=An%20empirical%20study%20on%20the%20correctness%20of%20formally%20verified%20distributed%20systems)
[[doi]](https://doi.org/10.1145/3064176.3064183)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-4938-3)





# A HOL specification of the ARM instruction set architecture {#papers-fox-cambridge-2001}


Anthony C. J. Fox
Report
University of Cambridge, Computer Laboratory
June
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20HOL%20specification%20of%20the%20ARM%20instruction%20set%20architecture)
[[DBLP]](https://dblp.org/search?q=A%20HOL%20specification%20of%20the%20ARM%20instruction%20set%20architecture)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20HOL%20specification%20of%20the%20ARM%20instruction%20set%20architecture)
[[url]](https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-545.pdf)

Notes: 
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture)\




[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
# A trustworthy monadic formalization of the ARMv7 instruction set architecture {#papers-fox-itp-2010}


Anthony C. J. Fox, Magnus O. Myreen
Proceedings Interactive Theorem Proving ITP 2010
LNCS, volume 6172
Springer
Pages 243-258
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20trustworthy%20monadic%20formalization%20of%20the%20ARMv7%20instruction%20set%20architecture)
[[DBLP]](https://dblp.org/search?q=A%20trustworthy%20monadic%20formalization%20of%20the%20ARMv7%20instruction%20set%20architecture)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20trustworthy%20monadic%20formalization%20of%20the%20ARMv7%20instruction%20set%20architecture)
[[doi]](https://doi.org/10.1007/978-3-642-14052-5_18)

Notes: 
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture)\




[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
# Directions in ISA specification {#papers-fox-itp-2012}


Anthony C. J. Fox
Interactive Theorem Proving
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 338-344
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=Directions%20in%20ISA%20specification)
[[DBLP]](https://dblp.org/search?q=Directions%20in%20ISA%20specification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Directions%20in%20ISA%20specification)
[[doi]](https://doi.org/10.1007/978-3-642-32347-8_23)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-32347-8)

Notes: 
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture),
[L3](#L3)\
Referenced by: 
[notes/l3](#notes-l3)\




[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
[L3]: #notes-l3
# Improved tool support for machine-code decompilation in HOL4 {#papers-fox-itps-2015}


Anthony C. J. Fox
Proceedings 6th International Conference Interactive Theorem Proving ITP 2015
LNCS, volume 9236
Nanjing, China
Springer
Pages 187-202
August
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=Improved%20tool%20support%20for%20machine-code%20decompilation%20in%20HOL4)
[[DBLP]](https://dblp.org/search?q=Improved%20tool%20support%20for%20machine-code%20decompilation%20in%20HOL4)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Improved%20tool%20support%20for%20machine-code%20decompilation%20in%20HOL4)
[[doi]](https://doi.org/10.1007/978-3-319-22102-1)

Notes: 
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture)\




[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
# Formal specification and verification of ARM6 {#papers-fox-tphols-2003}


Anthony C. J. Fox
Theorem Proving in Higher Order Logics (TPHOLs '03)
LNCS, volume 2758
Springer
Pages 25-40
2003
[[Google Scholar]](https://scholar.google.com/scholar?q=Formal%20specification%20and%20verification%20of%20ARM6)
[[DBLP]](https://dblp.org/search?q=Formal%20specification%20and%20verification%20of%20ARM6)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Formal%20specification%20and%20verification%20of%20ARM6)
[[doi]](https://doi.org/10.1007/10930755_2)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-45130-3)

Notes: 
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture)\




[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
# Formal verification of the ARM6 micro-architecture {#papers-fox-ucam-2002}


Anthony C. J. Fox
Report
University of Cambridge, Computer Laboratory
November
2002
[[Google Scholar]](https://scholar.google.com/scholar?q=Formal%20verification%20of%20the%20ARM6%20micro-architecture)
[[DBLP]](https://dblp.org/search?q=Formal%20verification%20of%20the%20ARM6%20micro-architecture)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Formal%20verification%20of%20the%20ARM6%20micro-architecture)
[[url]](http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-548.pdf)

Notes: 
[Arm architecture](#Arm architecture),
[CPU verification](#CPU verification),
[microarchitecture](#microarchitecture)\



[Arm architecture]: #notes-arm-architecture
[CPU verification]: #notes-cpu-verification
[microarchitecture]: #notes-microarchitecture
# Attacking, repairing, and verifying SecVisor: A retrospective on the security of a hypervisor {#papers-franklin-cmu-2008}


Jason Franklin, Arvind Seshadri, Ning Qu, Sagar Chaki, Anupam Datta
CMU
2008
[[Google Scholar]](https://scholar.google.com/scholar?q=Attacking%2C%20repairing%2C%20and%20verifying%20SecVisor%3A%20A%20retrospective%20on%20the%20security%20of%20a%20hypervisor)
[[DBLP]](https://dblp.org/search?q=Attacking%2C%20repairing%2C%20and%20verifying%20SecVisor%3A%20A%20retrospective%20on%20the%20security%20of%20a%20hypervisor)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Attacking%2C%20repairing%2C%20and%20verifying%20SecVisor%3A%20A%20retrospective%20on%20the%20security%20of%20a%20hypervisor)

Papers: 
[seshadri:sosp:2007](#seshadri-sosp-2007)\
Referenced by: 
[papers/seshadri:sosp:2007](#papers-seshadri-sosp-2007)\


Uses the Murphi model checker to formalize the combined software and hardware security features in the [SecVisor][seshadri:sosp:2007] hypervisor developed by some of the authors the year before.
Interestingly, the adversary is modelled as an explicit piece of code that tries to write to everywhere that it should not.
They were able to discover two bugs involving mapping physical pages that contain unapproved code and creating aliases in the virtual address space.

Some lessons that they highlight are the importance of

- a clear, explicit specification of the adversary model
- an explicit statement of the top-level security requirements
- a clean separation between these requirements and the mechanisms used to achieve them  (This separation was not as clear in the original paper.)

Notes:

- this paper verifies a manually constructed abstraction of the software - possible errors could occur due to both the manual process and the degree of abstraction required
- it appears that Murphi does not produce minimal counterexamples
- Murphi is an explicit state model checker and therefore requires significant abstraction and, even then, runs into severe scaling issues.  They were only able to verify with three or four memory pages, four pages was over 100 times slower, five pages exceeded available resources.



[seshadri:sosp:2007]: #papers-seshadri-sosp-2007
# A knowledge-based code generator generator {#papers-fraser-sigart-1977}


Christopher W. Fraser
ACM
New York, NY, USA
Pages 126-129
August
1977
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20knowledge-based%20code%20generator%20generator)
[[DBLP]](https://dblp.org/search?q=A%20knowledge-based%20code%20generator%20generator)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20knowledge-based%20code%20generator%20generator)
[[doi]](https://doi.org/10.1145/872736.806941)




# DynAlloy: Upgrading Alloy with Actions {#papers-frias-icse-2005}


Marcelo F. Frias, Juan P. Galeotti, Carlos G. López Pombo, Nazareno M. Aguirre
Proceedings of the 27th International Conference on Software Engineering
ICSE '05
St. Louis, MO, USA
ACM
New York, NY, USA
Pages 442-451
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=DynAlloy%3A%20Upgrading%20Alloy%20with%20Actions)
[[DBLP]](https://dblp.org/search?q=DynAlloy%3A%20Upgrading%20Alloy%20with%20Actions)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=DynAlloy%3A%20Upgrading%20Alloy%20with%20Actions)
[[doi]](https://doi.org/10.1145/1062455.1062535)
[[ISBN]](http://books.google.com/books?vid=ISBN1-58113-963-2)

Notes: 
[Alloy verifier](#Alloy verifier),
[requirements specification](#requirements specification)\



[Alloy verifier]: #notes-alloy-verifier
[requirements specification]: #notes-requirements-specification
# Model checking early requirements specifications in Tropos {#papers-fuxman-isre-2001}


Ariel Fuxman, Marco Pistore, John Mylopoulos, Paolo Traverso
Requirements Engineering, 2001. Proceedings. Fifth IEEE International Symposium on
IEEE
Pages 174-181
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=Model%20checking%20early%20requirements%20specifications%20in%20Tropos)
[[DBLP]](https://dblp.org/search?q=Model%20checking%20early%20requirements%20specifications%20in%20Tropos)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Model%20checking%20early%20requirements%20specifications%20in%20Tropos)
[[doi]](https://doi.org/10.1109/ISRE.2001.948557)

Notes: 
[requirements specification](#requirements specification)\



[requirements specification]: #notes-requirements-specification
# Feedback-directed unit test generation for C/C++ using concolic execution {#papers-garg-icse-2013}


Pranav Garg, Franjo Ivančić, Gogul Balakrishnan, Naoto Maeda, Aarti Gupta
Proceedings of the 2013 International Conference on Software Engineering
ICSE '13
San Francisco, CA, USA
IEEE Press
Pages 132-141
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Feedback-directed%20unit%20test%20generation%20for%20C/C%2B%2B%20using%20concolic%20execution)
[[DBLP]](https://dblp.org/search?q=Feedback-directed%20unit%20test%20generation%20for%20C/C%2B%2B%20using%20concolic%20execution)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Feedback-directed%20unit%20test%20generation%20for%20C/C%2B%2B%20using%20concolic%20execution)
[[ISBN]](http://books.google.com/books?vid=ISBN9781467330763)

Notes: 
[fuzz testing](#fuzz testing),
[symbolic execution](#symbolic execution),
[unit tests](#unit tests)\
Referenced by: 
[papers/dimjasevic:ifm:2018](#papers-dimjasevic-ifm-2018)\


This paper describes a test generation tool based on a hybrid of [symbolic
execution] and [fuzz testing].
The goal is to generate high coverage sequences of method calls.

An interesting technical detail is that use unsat core to generate "conflict sequences":
unsatisfiable branch sequences.
This is used to reduce the number of SMT queries required.

The tool is evaluated on eight benchmarks based primarily on coverage metrics.



[fuzz testing]: #notes-fuzz-testing
[symbolic execution]: #notes-symbolic-execution
[unit tests]: #notes-unit-tests
# The nesC language: A holistic approach to networked embedded systems {#papers-gay-pldi-2003}


David Gay, Philip Levis, Robert von Behren, Matt Welsh, Eric Brewer, David Culler
Proceedings of the ACM SIGPLAN 2003 Conference on Programming Language Design and Implementation
PLDI '03
San Diego, California, USA
ACM
New York, NY, USA
Pages 1-11
2003
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20nesC%20language%3A%20A%20holistic%20approach%20to%20networked%20embedded%20systems)
[[DBLP]](https://dblp.org/search?q=The%20nesC%20language%3A%20A%20holistic%20approach%20to%20networked%20embedded%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20nesC%20language%3A%20A%20holistic%20approach%20to%20networked%20embedded%20systems)
[[doi]](https://doi.org/10.1145/781131.781133)
[[ISBN]](http://books.google.com/books?vid=ISBN1-58113-662-5)

Notes: 
[events](#events)\



[events]: #notes-events
# A survey of microarchitectural timing attacks and countermeasures on contemporary hardware {#papers-ge-jce-2016}


Qian Ge, Yuval Yarom, David Cock, Gernot Heiser
Springer
Pages 1-27
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20survey%20of%20microarchitectural%20timing%20attacks%20and%20countermeasures%20on%20contemporary%20hardware)
[[DBLP]](https://dblp.org/search?q=A%20survey%20of%20microarchitectural%20timing%20attacks%20and%20countermeasures%20on%20contemporary%20hardware)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20survey%20of%20microarchitectural%20timing%20attacks%20and%20countermeasures%20on%20contemporary%20hardware)
[[doi]](https://doi.org/10.1007/s13389-016-0141-6)

Notes: 
[survey](#survey),
[microarchitecture](#microarchitecture),
[side channel](#side channel),
[security](#security)\
Referenced by: 
[notes/side-channel](#notes-side-channel)\



[survey]: #notes-survey
[microarchitecture]: #notes-microarchitecture
[side channel]: #notes-side-channel
[security]: #notes-security
# SAGE: Whitebox fuzzing for security testing {#papers-godefroid-acmq-2012}


Patrice Godefroid, Michael Y. Levin, David Molnar
ACM
New York, NY, USA
Pages 20:20-20:27
January
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=SAGE%3A%20Whitebox%20fuzzing%20for%20security%20testing)
[[DBLP]](https://dblp.org/search?q=SAGE%3A%20Whitebox%20fuzzing%20for%20security%20testing)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=SAGE%3A%20Whitebox%20fuzzing%20for%20security%20testing)
[[doi]](https://doi.org/10.1145/2090147.2094081)

Notes: 
[symbolic execution](#symbolic execution)\




[symbolic execution]: #notes-symbolic-execution
# The soundness of bugs is what matters (position statement) {#papers-godefroid-bugs-2005}


Patrice Godefroid
Proceedings of BUGS 2005 (PLDI 2005 Workshop on the Evaluation of Software Defect Detection Tools)
Chicago, IL, USA
June
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20soundness%20of%20bugs%20is%20what%20matters%20%28position%20statement%29)
[[DBLP]](https://dblp.org/search?q=The%20soundness%20of%20bugs%20is%20what%20matters%20%28position%20statement%29)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20soundness%20of%20bugs%20is%20what%20matters%20%28position%20statement%29)
[[url]](https://patricegodefroid.github.io/public_psfiles/bugs2005.pdf)

Notes: 
[symbolic execution](#symbolic execution),
[under-approximation](#under-approximation)\
Papers: 
[xie:bugs:2005](#xie-bugs-2005)\
Referenced by: 
[papers/xie:bugs:2005](#papers-xie-bugs-2005)\


This one-page, position paper is "written in a provocative style for
entertainment purposes" but, nevertheless, makes some very good points.  The
main argument is that the goal of most verification research is defect
detection and that they should therefore focus on finding "sound bugs" (bugs
that can actually occur) and avoid "unsound bugs" (false alarms).  This is why
(despite its limitations) testing remains so important: testing finds sound
bugs.  The solution is to switch from "may analysis" (over-approximation) to
"must analysis" ([under-approximation]).

This paper is worth reading alongside [xie:bugs:2005] (from the same workshop)
that uses "soundness" in the more conventional sense of showing absence of any
bugs of a certain class.



[symbolic execution]: #notes-symbolic-execution
[under-approximation]: #notes-under-approximation
[xie:bugs:2005]: #papers-xie-bugs-2005
# Fuzzing: Hack, art, and science {#papers-godefroid-cacm-2020}


Patrice Godefroid
Association for Computing Machinery
New York, NY, USA
Pages 70-76
January
2020
[[Google Scholar]](https://scholar.google.com/scholar?q=Fuzzing%3A%20Hack%2C%20art%2C%20and%20science)
[[DBLP]](https://dblp.org/search?q=Fuzzing%3A%20Hack%2C%20art%2C%20and%20science)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Fuzzing%3A%20Hack%2C%20art%2C%20and%20science)
[[doi]](https://doi.org/10.1145/3363824)
[[url]](https://doi.org/10.1145/3363824)

Notes: 
[fuzz testing](#fuzz testing),
[symbolic execution](#symbolic execution),
[SAGE verifier](#SAGE verifier),
[survey](#survey)\
Referenced by: 
[notes/fuzz-testing](#notes-fuzz-testing)\


Nice overview article that describes whitebox fuzzing such as the [SAGE
verifier] in the context of blackbox fuzzing, blackbox fuzzing, greybox
fuzzing, hybrid fuzzing, test generation, security analysis, etc.



[fuzz testing]: #notes-fuzz-testing
[symbolic execution]: #notes-symbolic-execution
[SAGE verifier]: #notes-sage-verifier
[survey]: #notes-survey
# DART: Directed automated random testing {#papers-godefroid-pldi-2005}


Patrice Godefroid, Nils Klarlund, Koushik Sen
Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation
PLDI '05
Chicago, IL, USA
Association for Computing Machinery
New York, NY, USA
Pages 213-223
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=DART%3A%20Directed%20automated%20random%20testing)
[[DBLP]](https://dblp.org/search?q=DART%3A%20Directed%20automated%20random%20testing)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=DART%3A%20Directed%20automated%20random%20testing)
[[doi]](https://doi.org/10.1145/1065010.1065036)
[[ISBN]](http://books.google.com/books?vid=ISBN1595930566)
[[url]](https://doi.org/10.1145/1065010.1065036)

Notes: 
[DART verifier](#DART verifier),
[symbolic execution](#symbolic execution)\



[DART verifier]: #notes-dart-verifier
[symbolic execution]: #notes-symbolic-execution
# Automated synthesis of symbolic instruction encodings from I/O samples {#papers-godefroid-pldi-2012}


Patrice Godefroid, Ankur Taly
Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation
PLDI '12
Beijing, China
ACM
New York, NY, USA
Pages 441-452
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=Automated%20synthesis%20of%20symbolic%20instruction%20encodings%20from%20I/O%20samples)
[[DBLP]](https://dblp.org/search?q=Automated%20synthesis%20of%20symbolic%20instruction%20encodings%20from%20I/O%20samples)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automated%20synthesis%20of%20symbolic%20instruction%20encodings%20from%20I/O%20samples)
[[doi]](https://doi.org/10.1145/2254064.2254116)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-1205-9)

Notes: 
[ISA specification](#ISA specification)\




[ISA specification]: #notes-isa-specification
# Abstract stobjs and their application to ISA modeling {#papers-goel-acl2-2013}


Shilpi Goel, Warren A. Hunt Jr., Matt Kaufmann
Proceedings of the ACL2 Workshop 2013, EPTCS 114
Pages 54-69
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Abstract%20stobjs%20and%20their%20application%20to%20ISA%20modeling)
[[DBLP]](https://dblp.org/search?q=Abstract%20stobjs%20and%20their%20application%20to%20ISA%20modeling)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Abstract%20stobjs%20and%20their%20application%20to%20ISA%20modeling)
[[doi]](https://doi.org/10.4204/EPTCS.114.5)

Notes: 
[ISA specification](#ISA specification),
[x86 architecture](#x86 architecture),
[instruction set architecture](#instruction set architecture),
[ACL2 theorem prover](#ACL2 theorem prover)\




[ISA specification]: #notes-isa-specification
[x86 architecture]: #notes-x86-architecture
[instruction set architecture]: #notes-instruction-set-architecture
[ACL2 theorem prover]: #notes-acl2-theorem-prover
# Simulation and formal verification of x86 machine-code programs that make system calls {#papers-goel-fmcad-2014}


Shilpi Goel, Warren A. Hunt Jr., Matt Kaufmann, Soumava Ghosh
Formal Methods in Computer-Aided Design, FMCAD
Pages 91-98
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=Simulation%20and%20formal%20verification%20of%20x86%20machine-code%20programs%20that%20make%20system%20calls)
[[DBLP]](https://dblp.org/search?q=Simulation%20and%20formal%20verification%20of%20x86%20machine-code%20programs%20that%20make%20system%20calls)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Simulation%20and%20formal%20verification%20of%20x86%20machine-code%20programs%20that%20make%20system%20calls)
[[doi]](https://doi.org/10.1109/FMCAD.2014.6987600)

Notes: 
[ISA specification](#ISA specification),
[x86 architecture](#x86 architecture),
[instruction set architecture](#instruction set architecture),
[ACL2 theorem prover](#ACL2 theorem prover)\




[ISA specification]: #notes-isa-specification
[x86 architecture]: #notes-x86-architecture
[instruction set architecture]: #notes-instruction-set-architecture
[ACL2 theorem prover]: #notes-acl2-theorem-prover
# Engineering a formal, executable x86 ISA simulator for software verification {#papers-goel-pcs-2017}


Shilpi Goel, Warren A. Hunt Jr., Matt Kaufmann
Provably Correct Systems
Springer International Publishing
Cham
Pages 173-209
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=Engineering%20a%20formal%2C%20executable%20x86%20ISA%20simulator%20for%20software%20verification)
[[DBLP]](https://dblp.org/search?q=Engineering%20a%20formal%2C%20executable%20x86%20ISA%20simulator%20for%20software%20verification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Engineering%20a%20formal%2C%20executable%20x86%20ISA%20simulator%20for%20software%20verification)
[[doi]](https://doi.org/10.1007/978-3-319-48628-4_8)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-319-48628-4)

Notes: 
[x86 architecture](#x86 architecture),
[instruction set architecture](#instruction set architecture),
[ACL2 theorem prover](#ACL2 theorem prover)\




[x86 architecture]: #notes-x86-architecture
[instruction set architecture]: #notes-instruction-set-architecture
[ACL2 theorem prover]: #notes-acl2-theorem-prover
# Formal verification of application and system programs based on a validated x86 ISA model {#papers-goel-phd-2016}


Shilpi Goel
Ph.D. thesis
University of Texas at Austin
December
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Formal%20verification%20of%20application%20and%20system%20programs%20based%20on%20a%20validated%20x86%20ISA%20model)
[[DBLP]](https://dblp.org/search?q=Formal%20verification%20of%20application%20and%20system%20programs%20based%20on%20a%20validated%20x86%20ISA%20model)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Formal%20verification%20of%20application%20and%20system%20programs%20based%20on%20a%20validated%20x86%20ISA%20model)
[[url]](http://www.cs.utexas.edu/users/shigoel/x86isaInfo/Shilpi-Goel-Dissertation.pdf)

Notes: 
[ISA specification](#ISA specification),
[x86 architecture](#x86 architecture),
[instruction set architecture](#instruction set architecture),
[ACL2 theorem prover](#ACL2 theorem prover)\




[ISA specification]: #notes-isa-specification
[x86 architecture]: #notes-x86-architecture
[instruction set architecture]: #notes-instruction-set-architecture
[ACL2 theorem prover]: #notes-acl2-theorem-prover
# Security policies and security models {#papers-goguen-secpriv-1982}


Joseph A. Goguen, José Meseguer
1982 IEEE Symposium on Security and Privacy
IEEE
Pages 11-11
1982
[[Google Scholar]](https://scholar.google.com/scholar?q=Security%20policies%20and%20security%20models)
[[DBLP]](https://dblp.org/search?q=Security%20policies%20and%20security%20models)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Security%20policies%20and%20security%20models)
[[doi]](https://doi.org/10.1109/SP.1982.10014)

Notes: 
[information flow](#information flow)\
Referenced by: 
[papers/rushby:sri:1992](#papers-rushby-sri-1992),
[notes/non-interference](#notes-non-interference)\




[information flow]: #notes-information-flow
# Unwinding and inference control {#papers-goguen-secpriv-1984}


Joseph A. Goguen, José Meseguer
1984 IEEE Symposium on Security and Privacy
IEEE
Pages 75-75
1984
[[Google Scholar]](https://scholar.google.com/scholar?q=Unwinding%20and%20inference%20control)
[[DBLP]](https://dblp.org/search?q=Unwinding%20and%20inference%20control)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Unwinding%20and%20inference%20control)
[[doi]](https://doi.org/10.1109/SP.1984.10019)

Notes: 
[information flow](#information flow)\
Referenced by: 
[notes/non-interference](#notes-non-interference)\




[information flow]: #notes-information-flow
# DeepState: Symbolic unit testing for C and C++ {#papers-goodman-ndss-2018}


Peter Goodman, Alex Groce
NDSS Workshop on Binary Analysis Research
San Diego, California, USA
Pages 7
18
February
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=DeepState%3A%20Symbolic%20unit%20testing%20for%20C%20and%20C%2B%2B)
[[DBLP]](https://dblp.org/search?q=DeepState%3A%20Symbolic%20unit%20testing%20for%20C%20and%20C%2B%2B)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=DeepState%3A%20Symbolic%20unit%20testing%20for%20C%20and%20C%2B%2B)
[[doi]](https://doi.org/10.14722/bar.2018.23009)

Notes: 
[fuzz testing](#fuzz testing),
[symbolic execution](#symbolic execution),
[binary analysis](#binary analysis),
[property-based testing](#property-based testing),
[unit tests](#unit tests)\


DeepState seeks to narrow the gap between techniques that programmers are
familiar with (e.g., testing) and symbolic execution / binary analysis tools by
enabling the use of parameterized unit tests with a variety of symbolic
execution backends (angr, Manticore and Dr. Fuzz) and fuzzers and making it
easy to switch between backends.

The interface is a DSL that extends
[GoogleTest](https://github.com/google/googletest).

A key challenge is handling "debug printfs" in the code being tested since that
causes a path explosion.
Their solution is to provide a streaming log interface that defers printing log
output until the end of the test.

They enable "swarm testing" in their DSL by providing constructs like "OneOf"
that select one of several code blocks to execute.  Each member of the swarm
can disable some subset of the code blocks or change their relative probability
to increase the diversity of testing.
_(I have seen a similar approach in hardware model checking before.)_

They tackle problems around symbolic loop bounds and symbolic array accesses by
forking particular concrete values to reduce the state (path?) explosion
problem. They call this "pumping".
_(I want to know more about this.)_

The code is [available on github](https://github.com/trailofbits/deepstate)
under an open-source license;
and
there are [blog articles about DeepState](https://github.com/trailofbits/deepstate#articles-describing-deepstate).



[fuzz testing]: #notes-fuzz-testing
[symbolic execution]: #notes-symbolic-execution
[binary analysis]: #notes-binary-analysis
[property-based testing]: #notes-property-based-testing
[unit tests]: #notes-unit-tests
# A stream compiler for communication-exposed architectures {#papers-gordon-asplos-2002}


Michael I. Gordon, William Thies, Michal Karczmarek, Jasper Lin, Ali S. Meli, Andrew A. Lamb, Chris Leger, Jeremy Wong, Henry Hoffmann, David Maze, Saman P. Amarasinghe
Proceedings Architectural Support for Programming Languages and Operating Systems
Pages 291-303
2002
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20stream%20compiler%20for%20communication-exposed%20architectures)
[[DBLP]](https://dblp.org/search?q=A%20stream%20compiler%20for%20communication-exposed%20architectures)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20stream%20compiler%20for%20communication-exposed%20architectures)
[[doi]](https://doi.org/10.1145/605397.605428)
[[ISBN]](http://books.google.com/books?vid=ISBN1-58113-574-2)

Notes: 
[stream processing](#stream processing)\



[stream processing]: #notes-stream-processing
# Introduction to HOL: A Theorem Proving Environment for Higher Order Logic {#papers-gordon-book-1993}


Cambridge University Press
New York, NY, USA
1993
[[Google Scholar]](https://scholar.google.com/scholar?q=Introduction%20to%20HOL%3A%20A%20Theorem%20Proving%20Environment%20for%20Higher%20Order%20Logic)
[[DBLP]](https://dblp.org/search?q=Introduction%20to%20HOL%3A%20A%20Theorem%20Proving%20Environment%20for%20Higher%20Order%20Logic)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Introduction%20to%20HOL%3A%20A%20Theorem%20Proving%20Environment%20for%20Higher%20Order%20Logic)
[[ISBN]](http://books.google.com/books?vid=ISBN0-521-44189-7)

Notes: 
[HOL theorem prover](#HOL theorem prover),
[interactive theorem prover](#interactive theorem prover)\
Referenced by: 
[notes/hol-theorem-prover](#notes-hol-theorem-prover)\



[HOL theorem prover]: #notes-hol-theorem-prover
[interactive theorem prover]: #notes-interactive-theorem-prover
# An integrated concurrency and core-ISA architectural envelope definition, and test oracle, for IBM POWER multiprocessors {#papers-gray-micro-2015}


Kathryn E. Gray, Gabriel Kerneis, Dominic P. Mulligan, Christopher Pulte, Susmit Sarkar, Peter Sewell
MICRO 2015: Proceedings of the 48th International Symposium on Microarchitecture (MICRO 2015)
Waikiki, Hawaii, USA
Pages 635-646
December
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=An%20integrated%20concurrency%20and%20core-ISA%20architectural%20envelope%20definition%2C%20and%20test%20oracle%2C%20for%20IBM%20POWER%20multiprocessors)
[[DBLP]](https://dblp.org/search?q=An%20integrated%20concurrency%20and%20core-ISA%20architectural%20envelope%20definition%2C%20and%20test%20oracle%2C%20for%20IBM%20POWER%20multiprocessors)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=An%20integrated%20concurrency%20and%20core-ISA%20architectural%20envelope%20definition%2C%20and%20test%20oracle%2C%20for%20IBM%20POWER%20multiprocessors)
[[doi]](https://doi.org/10.1145/2830772.2830775)

Notes: 
[PowerPC architecture](#PowerPC architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture)\




[PowerPC architecture]: #notes-powerpc-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
# Cognitive dimensions of notations {#papers-green-pandc-1990}


Thomas R. G. Green
Proceedings of the Fifth Conference of the British Computer Society, Human-Computer Interaction Specialist Group on People and Computers V
Univ. of Nottingham
Cambridge University Press
USA
Pages 443-460
1990
[[Google Scholar]](https://scholar.google.com/scholar?q=Cognitive%20dimensions%20of%20notations)
[[DBLP]](https://dblp.org/search?q=Cognitive%20dimensions%20of%20notations)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Cognitive%20dimensions%20of%20notations)
[[ISBN]](http://books.google.com/books?vid=ISBN0521384303)




# Cognitive dimensions of information artefacts: a tutorial {#papers-green-tutorial-1998}


Thomas R. G. Green, Alan F. Blackwell
1998
[[Google Scholar]](https://scholar.google.com/scholar?q=Cognitive%20dimensions%20of%20information%20artefacts%3A%20a%20tutorial)
[[DBLP]](https://dblp.org/search?q=Cognitive%20dimensions%20of%20information%20artefacts%3A%20a%20tutorial)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Cognitive%20dimensions%20of%20information%20artefacts%3A%20a%20tutorial)




# Symbolic simulation of the JEM1 microprocessor {#papers-greve-fmcad-1998}


David A. Greve
Formal Methods in Computer-Aided Design: Second International Conference, FMCAD' 98 Palo Alto, CA, USA, November 4-6, 1998 Proceedings
Springer
Berlin, Heidelberg
Pages 321-333
1998
[[Google Scholar]](https://scholar.google.com/scholar?q=Symbolic%20simulation%20of%20the%20JEM1%20microprocessor)
[[DBLP]](https://dblp.org/search?q=Symbolic%20simulation%20of%20the%20JEM1%20microprocessor)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Symbolic%20simulation%20of%20the%20JEM1%20microprocessor)
[[doi]](https://doi.org/10.1007/3-540-49519-3_21)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-49519-2)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# One test to rule them all {#papers-groce-issta-2017}


Alex Groce, Josie Holmes, Kevin Kellar
Proceedings of the 26th ACM SIGSOFT International Symposium on Software Testing and Analysis
ISSTA 2017
Santa Barbara, CA, USA
Association for Computing Machinery
New York, NY, USA
Pages 1-11
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=One%20test%20to%20rule%20them%20all)
[[DBLP]](https://dblp.org/search?q=One%20test%20to%20rule%20them%20all)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=One%20test%20to%20rule%20them%20all)
[[doi]](https://doi.org/10.1145/3092703.3092704)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450350761)
[[url]](https://doi.org/10.1145/3092703.3092704)

Notes: 
[test-case reduction](#test-case reduction)\
Referenced by: 
[notes/test-case-reduction](#notes-test-case-reduction)\



[test-case reduction]: #notes-test-case-reduction
# A retrospective on `MIPS: A microprocessor architecture' {#papers-gross-micro-2016}


Thomas R. Gross, Norman P. Jouppi, John L. Hennessy, Steven Przybylski, Christopher Rowen
Pages 70-85
July
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20retrospective%20on%20%60MIPS%3A%20A%20microprocessor%20architecture%27)
[[DBLP]](https://dblp.org/search?q=A%20retrospective%20on%20%60MIPS%3A%20A%20microprocessor%20architecture%27)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20retrospective%20on%20%60MIPS%3A%20A%20microprocessor%20architecture%27)
[[doi]](https://doi.org/10.1109/MM.2016.66)

Notes: 
[instruction set architecture](#instruction set architecture),
[MIPS architecture](#MIPS architecture),
[microarchitecture](#microarchitecture)\
Papers: 
[hennessy:micro:1982](#hennessy-micro-1982)\



[instruction set architecture]: #notes-instruction-set-architecture
[MIPS architecture]: #notes-mips-architecture
[microarchitecture]: #notes-microarchitecture
[hennessy:micro:1982]: #papers-hennessy-micro-1982
# Existential types for imperative languages {#papers-grossman-esop-2002}


Dan Grossman
Programming Languages and Systems
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 21-35
2002
[[Google Scholar]](https://scholar.google.com/scholar?q=Existential%20types%20for%20imperative%20languages)
[[DBLP]](https://dblp.org/search?q=Existential%20types%20for%20imperative%20languages)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Existential%20types%20for%20imperative%20languages)
[[doi]](https://doi.org/10.1007/3-540-45927-8_3)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-45927-9)





# CertiKOS: An extensible architecture for building certified concurrent OS Kernels {#papers-gu-osdi-2016}


Ronghui Gu, Zhong Shao, Hao Chen, Xiongnan Newman Wu, Jieung Kim, Vilhelm Sjöberg, David Costanzo
12th USENIX Symposium on Operating Systems Design and Implementation (OSDI 16)
Pages 653-669
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=CertiKOS%3A%20An%20extensible%20architecture%20for%20building%20certified%20concurrent%20OS%20Kernels)
[[DBLP]](https://dblp.org/search?q=CertiKOS%3A%20An%20extensible%20architecture%20for%20building%20certified%20concurrent%20OS%20Kernels)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=CertiKOS%3A%20An%20extensible%20architecture%20for%20building%20certified%20concurrent%20OS%20Kernels)

Notes: 
[CompCert compiler](#CompCert compiler),
[Coq theorem prover](#Coq theorem prover)\
Referenced by: 
[papers/costanzo:pldi:2016](#papers-costanzo-pldi-2016),
[notes/annotation-burden](#notes-annotation-burden)\


This is one of a steady stream of papers from the FLINT group at Yale on creating a formally verified OS.
Some distinguishing features of CertiKOS are the completeness of the verification (cf. seL4), the way that the C code and the proofs are split into more than 30 very small layers each adding one feature at a time and greatly simplifying the proof of each layer and their use of an extended version of the CompCert C compiler. The layered structure is strongly reminiscent of Bryan Ford's work on Recursive Virtual Machines – unsurprising since Bryan was an early contributor to this project.
The use of CompCert avoids the need to perform translation validation (cf. seL4 work).
This paper adds concurrency with fine-grained locking and progress guarantees to CertiKOS.

The key result in this paper is Contextual Refinement: that if the kernel K is a refinement of the specification then, for any user program P, KxP is a refinement of SxP.
Showing this result for a concurrent system requires a proof that kernel calls are linearizable and of a progress property such as starvation freedom.
A consequence of this result is that they can also derive _behavior equivalence_ of P under either S or K.

Most of the paper describes the proof with particular focus on how the layered structure determines the structure of the proof.
The layers are:

* Concurrent layer interface. A notion of shared objects supporting a number of primitives and ghost state maintaining a log of past primitive calls. Objects can be "private" or "atomic".  Atomic objects are shared so the name indicates a requirement that they be accessed atomically.
* Machine model with hardware scheduler.  This layer introduces an oracle to decide whether to perform a context switch after each instruction.
* Machine model with local copy of shared memory.  This layer introduces a notion of ownership of a shared object by introducing "pull" actions to take ownership and "push" actions to release ownership.  (These are ghost code, updating ghost state.). This lets them talk about Data Race Freedom.
* Partial machine with environment contexts.  This layer lets them reason separately about the code running on different CPUs.
* CPU-local machine model.  This layer introduces a "log cache" in order to delay when primitive actions are considered to happen through shuffling and merging of events in a log.  I think this is where serializability comes into play.

It is worth mentioning what is not verified:

* TLB shootdown code (because they don't have a spec for the TLB)
* The ELF loader (this seems like a significant omission!)
* The boot loader
* A PreInit module that initialises the CPU and the devices.
Also, the concurrency results assume a sequentially consistent memory model – that is, a strict interleaving semantics.
The paper says that the proof should remain valid for the x86 TSO model but that is not done in this paper.

The introduction suggests that one of the benefits of the layered approach is that it decomposes the verification task into many simple _and easily automated ones_.  The paper makes a good case for the simplicity of this approach but it seems that the proof itself is around 40,000 lines of definitions and 50,000 lines of proof so the argument that this is easily automated is less clear.

Since the code itself is only 6500 lines of C and assembly code, the total proof+specification overhead is around 15x for this part.
The paper suggests that one third of the overhead is redundant and semi-automatically generated.  However, it still has to be maintained so I think that this remains a serious issue for more widespread adoption.

The paper is not clear but my suspicion is that part of the reason for the size of the proof and auxiliary definitions is the layered structure.
My guess is that, for each layer, you have to state and re-prove any properties that carry over from the layer below – even if that proof is fairly trivial.

As far as I can tell, the sizes stated in the paper are the size of the new concurrency related proof – I don't think that it includes the size of the proof about the previous sequential version that is reused.  (The paper does not explicitly mention the size of the CompCert changes and proofs but I assume that those are part of the 90,000 lines.)

Since one of the key differences from seL4 is the support of fine-grained locking (instead of seL4's single big lock), the evaluation focussed on absolute and relative performance as the number of CPUs grows.
The L4 family has always focussed on very fast IPC so, as one might expect, seL4 is significantly faster (50-100%).
They do not directly compare multiprocessor scaling with seL4 but they do compare use of a single big-lock version of CertiKOS with the fine-grained locking version and see that the big lock adds around 40% overhead on 3 cores compared with finer locks.


A second evaluation uses mC2 (the particular version of CertiKOS in this paper) as a hypervisor.
In this experiment, they are able to run Ubuntu in the guest VMs and they compare against the KVM hypervisor.
The big performance difference here comes from limitations of the disk driver interface.


One question that I am left with is whether the layered structure brings any flexibility to the code (as it did in Ford's Recursive Virtual Machines).
That is, can we replace, omit or reorder layers to get interesting variations on CertiKOS?
It is possible that the hypervisor configuration does this – but it is not clear from the paper.




[CompCert compiler]: #notes-compcert-compiler
[Coq theorem prover]: #notes-coq-theorem-prover
# The SeaHorn verification framework {#papers-gurfinkel-cav-2015}


Arie Gurfinkel, Temesghen Kahsai, Anvesh Komuravelli, Jorge A. Navas
Computer Aided Verification
Springer International Publishing
Cham
Pages 343-361
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20SeaHorn%20verification%20framework)
[[DBLP]](https://dblp.org/search?q=The%20SeaHorn%20verification%20framework)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20SeaHorn%20verification%20framework)
[[doi]](https://doi.org/10.1007/978-3-319-21690-4_20)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-319-21690-4)

Notes: 
[abstract interpretation](#abstract interpretation),
[SeaHorn verifier](#SeaHorn verifier),
[LLVM compiler](#LLVM compiler)\
Referenced by: 
[papers/matsushita:esop:2020](#papers-matsushita-esop-2020),
[notes/seahorn-verifier](#notes-seahorn-verifier)\




[abstract interpretation]: #notes-abstract-interpretation
[SeaHorn verifier]: #notes-seahorn-verifier
[LLVM compiler]: #notes-llvm-compiler
# An annotation language for optimizing software libraries {#papers-guyer-dsl-1999}


Samuel Z. Guyer, Calvin Lin
Proceedings of the 2nd Conference on Domain-Specific Languages - Volume 2
DSL'99
Austin, Texas
USENIX Association
Berkeley, CA, USA
1999
[[Google Scholar]](https://scholar.google.com/scholar?q=An%20annotation%20language%20for%20optimizing%20software%20libraries)
[[DBLP]](https://dblp.org/search?q=An%20annotation%20language%20for%20optimizing%20software%20libraries)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=An%20annotation%20language%20for%20optimizing%20software%20libraries)
[[doi]](https://doi.org/10.1007/3-540-45574-4_15)




# A robust machine code proof framework for highly secure applications {#papers-hardin-acl2-2006}


David S. Hardin, Eric W. Smith, William D. Young
Proceedings of the Sixth International Workshop on the ACL2 Theorem Prover and Its Applications
ACL2 '06
Seattle, Washington, USA
ACM
New York, NY, USA
Pages 11-20
2006
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20robust%20machine%20code%20proof%20framework%20for%20highly%20secure%20applications)
[[DBLP]](https://dblp.org/search?q=A%20robust%20machine%20code%20proof%20framework%20for%20highly%20secure%20applications)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20robust%20machine%20code%20proof%20framework%20for%20highly%20secure%20applications)
[[doi]](https://doi.org/10.1145/1217975.1217978)
[[ISBN]](http://books.google.com/books?vid=ISBN0-9788493-0-2)

Notes: 
[ISA specification](#ISA specification),
[ACL2 theorem prover](#ACL2 theorem prover)\



[ISA specification]: #notes-isa-specification
[ACL2 theorem prover]: #notes-acl2-theorem-prover
# Behavioral interface specification languages {#papers-hatcliff-compsurv-2012}


John Hatcliff, Gary T. Leavens, K. Rustan M. Leino, Peter Müller, Matthew Parkinson
Association for Computing Machinery
New York, NY, USA
June
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=Behavioral%20interface%20specification%20languages)
[[DBLP]](https://dblp.org/search?q=Behavioral%20interface%20specification%20languages)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Behavioral%20interface%20specification%20languages)
[[doi]](https://doi.org/10.1145/2187671.2187678)
[[url]](https://doi.org/10.1145/2187671.2187678)

Notes: 
[contract driven development](#contract driven development),
[spec-sharp-project](#spec-sharp-project),
[separation logic](#separation logic),
[loop invariant](#loop invariant)\




[contract driven development]: #notes-contract-driven-development
[spec-sharp-project]: #notes-spec-sharp-project
[separation logic]: #notes-separation-logic
[loop invariant]: #notes-loop-invariant
# Ironclad apps: End-to-end security via automated full-system verification {#papers-hawblitzel-osdi-2014}


Chris Hawblitzel, Jon Howell, Jacob R. Lorch, Arjun Narayan, Bryan Parno, Danfeng Zhang, Brian Zill
11th USENIX Symposium on Operating Systems Design and Implementation (OSDI 14)
Pages 165-181
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=Ironclad%20apps%3A%20End-to-end%20security%20via%20automated%20full-system%20verification)
[[DBLP]](https://dblp.org/search?q=Ironclad%20apps%3A%20End-to-end%20security%20via%20automated%20full-system%20verification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Ironclad%20apps%3A%20End-to-end%20security%20via%20automated%20full-system%20verification)





# Specified blocks {#papers-hehner-vstte-2008}


Eric C. R. Hehner
Verified Software: Theories, Tools, Experiments: First IFIP TC 2/WG 2.3 Conference, VSTTE 2005, Zurich, Switzerland, October 10-13, 2005, Revised Selected Papers and Discussions
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 384-391
2008
[[Google Scholar]](https://scholar.google.com/scholar?q=Specified%20blocks)
[[DBLP]](https://dblp.org/search?q=Specified%20blocks)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Specified%20blocks)
[[doi]](https://doi.org/10.1007/978-3-540-69149-5\_41)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-69149-5)
[[url]](https://doi.org/10.1007/978-3-540-69149-5\_41)

Notes: 
[loop invariant](#loop invariant)\
Papers: 
[tuerk:vstte:2010](#tuerk-vstte-2010),
[schwerhoff:ecoop:2015](#schwerhoff-ecoop-2015)\
Referenced by: 
[papers/tuerk:vstte:2010](#papers-tuerk-vstte-2010),
[notes/loop-invariant](#notes-loop-invariant)\


Program verification based on assertions is fundamentally wrong.
Like Ptolemy's planetary theory of cycles within cycles, they
are overly complex and we need something as simple as
Galileo's theory of elliptical orbits.
This paper forcefully argues that they should be replaced
with "specified blocks" that form a specification of
an entire block of code.
That is, we should describe what a block of code
is intended to do instead of what is true at strategic points
in the code.

A specified block consists of a block of code plus a
predicate that relates the new and old values of any variables.
For example, a block that increments every element of an array
might have the specification

    (forall j: 0..n . L'[j] = L[j]+1)

while the obvious loop that implements this specification would have
the specification

    (forall j: 0,..i . L'[j] = L[j]) &&
    (forall j: i,..n . L'[j] = L[j]+1)

Compare this with the loop invariant that looks like this

    (forall j: 0,..i . L'[j] = L[j]+1) &&
    (forall j: i,..n . L'[j] = L[j]) &&
    0 ≤ i ≤ n

The loop invariant is different from the loop specification in three ways:

- The loop invariant describes what has been done so far
  whereas the loop specification describes what is still to be done.
  You can see this in the first line where the loop specification
  says that the loop does not change some initial segment of the loop
  while the loop invariant says that, so far, the initial segment
  has been incremented.

- Likewise, the second line of the loop specification says that the
  loop is going to increment the tail of the array while the loop
  invariant says that the loop has not yet been changed.

- Finally, the loop invariant describes a single iteration of the loop
  and so it has to say something about the range of i while the loop
  specification describes all remaining iterations of the loop
  and does not need to constrain i.

For loops, the difference of describing what is still to be done
enables local reasoning about loops because the focus is on
the action of the loop, not the code that comes before it.
This was
[independently rediscovered by Tuerk two years later][tuerk:vstte:2010]
in the context of separation logic
where it eliminates the need to invent predicates for describing
partial data structures.
This was later used as the motivation for supporting
[lightweight magic wands][schwerhoff:ecoop:2015].

The paper contains four examples to illustrate how specified blocks
are easier to work with: incrementing arrays, binary search, exponentiation
and product of power series.
The exponentiation example involves gotos: contradicting Dijkstra by saying
"Apparently, unstructured goto's pose no more verification problem
than structured loops."

This approach to specification has been implemented in HOL.



[loop invariant]: #notes-loop-invariant
[tuerk:vstte:2010]: #papers-tuerk-vstte-2010
[schwerhoff:ecoop:2015]: #papers-schwerhoff-ecoop-2015
# Computer architecture: A quantitative approach (Fifth edition) {#papers-hennessy-book-2011}


John L. Hennessy, David A. Patterson
Morgan Kaufmann Publishers Inc.
San Francisco, CA, USA
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=Computer%20architecture%3A%20A%20quantitative%20approach%20%28Fifth%20edition%29)
[[DBLP]](https://dblp.org/search?q=Computer%20architecture%3A%20A%20quantitative%20approach%20%28Fifth%20edition%29)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Computer%20architecture%3A%20A%20quantitative%20approach%20%28Fifth%20edition%29)
[[ISBN]](http://books.google.com/books?vid=ISBN012383872X%2C%209780123838728)

Notes: 
[microarchitecture](#microarchitecture),
[instruction set architecture](#instruction set architecture)\



[microarchitecture]: #notes-microarchitecture
[instruction set architecture]: #notes-instruction-set-architecture
# MIPS: A microprocessor architecture {#papers-hennessy-micro-1982}


John L. Hennessy, Norman P. Jouppi, Steven Przybylski, Christopher Rowen, Thomas R. Gross, Forest Baskett, John Gill
Proceedings of the 15th Annual Workshop on Microprogramming
MICRO 15
Palo Alto, California, USA
IEEE Press
Piscataway, NJ, USA
Pages 17-22
1982
[[Google Scholar]](https://scholar.google.com/scholar?q=MIPS%3A%20A%20microprocessor%20architecture)
[[DBLP]](https://dblp.org/search?q=MIPS%3A%20A%20microprocessor%20architecture)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=MIPS%3A%20A%20microprocessor%20architecture)
[[doi]](https://doi.org/10.1145/1014194.800930)

Notes: 
[ISA specification](#ISA specification),
[MIPS architecture](#MIPS architecture),
[RISC architecture](#RISC architecture)\
Referenced by: 
[papers/gross:micro:2016](#papers-gross-micro-2016)\



[ISA specification]: #notes-isa-specification
[MIPS architecture]: #notes-mips-architecture
[RISC architecture]: #notes-risc-architecture
# Software verification with BLAST {#papers-henzinger-spin-2003}


Thomas A. Henzinger, Ranjit Jhala, Rupak Majumdar, Grégoire Sutre
Model Checking Software
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 235-239
2003
[[Google Scholar]](https://scholar.google.com/scholar?q=Software%20verification%20with%20BLAST)
[[DBLP]](https://dblp.org/search?q=Software%20verification%20with%20BLAST)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Software%20verification%20with%20BLAST)
[[doi]](https://doi.org/10.1007/3-540-44829-2_17)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-44829-7)

Notes: 
[model checking](#model checking),
[CEGAR](#CEGAR)\
Papers: 
[necula:cc:2002](#necula-cc-2002),
[ball:pldi:2001](#ball-pldi-2001)\
Referenced by: 
[papers/ball:pldi:2001](#papers-ball-pldi-2001)\



[model checking]: #notes-model-checking
[CEGAR]: #notes-cegar
[necula:cc:2002]: #papers-necula-cc-2002
[ball:pldi:2001]: #papers-ball-pldi-2001
# Fractional permissions without the fractions {#papers-heule-ftfjp-2011}


Stefan Heule, K. Rustan M. Leino, Peter Müller, Alexander J. Summers
Proceedings of the 13th Workshop on Formal Techniques for Java-Like Programs
FTfJP '11
Lancaster, United Kingdom
Association for Computing Machinery
New York, NY, USA
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=Fractional%20permissions%20without%20the%20fractions)
[[DBLP]](https://dblp.org/search?q=Fractional%20permissions%20without%20the%20fractions)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Fractional%20permissions%20without%20the%20fractions)
[[doi]](https://doi.org/10.1145/2076674.2076675)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450308939)
[[url]](https://doi.org/10.1145/2076674.2076675)

Notes: 
[permission logic](#permission logic),
[Chalice verifier](#Chalice verifier),
[fractional permissions](#fractional permissions),
[permission accounting](#permission accounting)\
Papers: 
[bornat:popl:2005](#bornat-popl-2005)\
Referenced by: 
[papers/heule:vmcai:2013](#papers-heule-vmcai-2013),
[notes/chalice-verifier](#notes-chalice-verifier),
[notes/fractional-permissions](#notes-fractional-permissions),
[notes/permission-accounting](#notes-permission-accounting)\


The standard way of distinguishing read and write permissions
in separation logic is with
[fractional permissions][bornat:popl:2005]
in which you can write a resource if you have 100% of the resource
read a resource if you have some fraction of the resource
and you have no access if you have 0% of the resource.
When you replicate references to a resource, you split the
fraction into some smaller parts and when you are done with those
references, you recombine (sum) all their fractions.

Whilst this is intuitively appealing, in practice you find yourself
making arbitrary choices about the size of each fraction
and, if you add another use of a resource, you might need to update
the existing choice of fractions from "p/2" (say) to "p/3".

This paper describes an experimental version of the [Chalice verifier] which
directly encodes the notion of "read permission" as a read
instead of having to encode it as a fraction of an access.
They end up with six different forms of permission:

- 1 - a full permission (allowing both reads and writes)
- rd - read permission
- rd(tok) - a token read permission (used for asynchronous method calls)
- rd(o) - monitor read permission (used for monitor calls)
- P1 + P2 - combining permissions
- P1 - P2 - removing permissions



[permission logic]: #notes-permission-logic
[Chalice verifier]: #notes-chalice-verifier
[fractional permissions]: #notes-fractional-permissions
[permission accounting]: #notes-permission-accounting
[bornat:popl:2005]: #papers-bornat-popl-2005
# Stratified synthesis: Automatically learning the x86-64 instruction set {#papers-heule-pldi-2016}


Stefan Heule, Eric Schkufza, Rahul Sharma, Alex Aiken
Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation
PLDI '16
Santa Barbara, CA, USA
ACM
New York, NY, USA
Pages 237-250
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Stratified%20synthesis%3A%20Automatically%20learning%20the%20x86-64%20instruction%20set)
[[DBLP]](https://dblp.org/search?q=Stratified%20synthesis%3A%20Automatically%20learning%20the%20x86-64%20instruction%20set)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Stratified%20synthesis%3A%20Automatically%20learning%20the%20x86-64%20instruction%20set)
[[doi]](https://doi.org/10.1145/2908080.2908121)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-4261-2)

Notes: 
[x86 architecture](#x86 architecture),
[instruction set architecture](#instruction set architecture),
[ISA specification](#ISA specification)\




[x86 architecture]: #notes-x86-architecture
[instruction set architecture]: #notes-instruction-set-architecture
[ISA specification]: #notes-isa-specification
# Abstract read permissions: Fractional permissions without the fractions {#papers-heule-vmcai-2013}


Stefan Heule, K. Rustan M. Leino, Peter Müller, Alexander J. Summers
Verification, Model Checking, and Abstract Interpretation
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 315-334
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Abstract%20read%20permissions%3A%20Fractional%20permissions%20without%20the%20fractions)
[[DBLP]](https://dblp.org/search?q=Abstract%20read%20permissions%3A%20Fractional%20permissions%20without%20the%20fractions)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Abstract%20read%20permissions%3A%20Fractional%20permissions%20without%20the%20fractions)
[[doi]](https://doi.org/10.1007/978-3-642-35873-9_20)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-35873-9)

Notes: 
[permission logic](#permission logic)\
Papers: 
[heule:ftfjp:2011](#heule-ftfjp-2011)\


Not read but appears to be an updated version of
[an earlier paper][heule:ftfjp:2011]
but with a less open publisher.



[permission logic]: #notes-permission-logic
[heule:ftfjp:2011]: #papers-heule-ftfjp-2011
# Simplifying design and verification for structural hazards and datapaths in pipelined circuits {#papers-higgins-hldvt-2004}


J. Thomas Higgins, Mark D. Aagaard
Proceedings of the High-Level Design Validation and Test Workshop, 2004. Ninth IEEE International
HLDVT '04
IEEE Computer Society
Washington, DC, USA
Pages 31-36
2004
[[Google Scholar]](https://scholar.google.com/scholar?q=Simplifying%20design%20and%20verification%20for%20structural%20hazards%20and%20datapaths%20in%20pipelined%20circuits)
[[DBLP]](https://dblp.org/search?q=Simplifying%20design%20and%20verification%20for%20structural%20hazards%20and%20datapaths%20in%20pipelined%20circuits)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Simplifying%20design%20and%20verification%20for%20structural%20hazards%20and%20datapaths%20in%20pipelined%20circuits)
[[doi]](https://doi.org/10.1109/HLDVT.2004.1431229)
[[ISBN]](http://books.google.com/books?vid=ISBN0-7803-8714-7)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# The ramifications of sharing in data structures {#papers-hobor-popl-2013}


Aquinas Hobor, Jules Villard
Proceedings of the 40th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
POPL '13
Rome, Italy
Association for Computing Machinery
New York, NY, USA
Pages 523-536
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20ramifications%20of%20sharing%20in%20data%20structures)
[[DBLP]](https://dblp.org/search?q=The%20ramifications%20of%20sharing%20in%20data%20structures)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20ramifications%20of%20sharing%20in%20data%20structures)
[[doi]](https://doi.org/10.1145/2429069.2429131)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450318327)
[[url]](https://doi.org/10.1145/2429069.2429131)

Notes: 
[magic wand](#magic wand),
[permission logic](#permission logic),
[separation logic](#separation logic),
[frame rule](#frame rule)\
Papers: 
[krishnaswami:tldi:2010](#krishnaswami-tldi-2010)\


This paper tackles a generalized form of the
[ramification problem][krishnaswami:tldi:2010].
That is, it tackles the problem that separation logic is good at
reasoning about pointer-based structures such as trees when you can split
the heap into disjoint parts but separation logic's weakness had been
reasoning about structures such as dags that rely on sharing.
In particular, reasoning about something like a garbage collector
has been hard.

The _power_ of separation logic comes from the FRAME rule

                 {P} c {Q}
    ———————————————————————————————————   FRAME
             {F ∗ P} c {F ∗ Q}

This rule lets us use local reasoning "{P} c {Q}" to reason about
a small part of the heap by separating this small part from "F" –
the rest of the heap.
The problem is that, sometimes, we cannot cleanly separate the two
– and that is the _weakness_ of separation logic.

The solution in this paper is a new verification rule that they call
RAMIFY that provides an alternative to separation logic's FRAME rule.

    {P} c {Q}       R ⊢ P ∗ (Q ——∗ R')
    ———————————————————————————————————   RAMIFY
                 {R} c {R'}

Like the FRAME rule, this let's us use local reasoning "{P} c {Q}"
about a small part of the heap.
But, unlike the FRAME rule, it does not require that we can cleanly
separate the local part "P" from the global part "Q".
Instead, we need to reason about the relationship between
the global pre/post-conditions "R"/"R'" and the local
pre/post-conditions "P"/"Q".

This paper uses reasoning about marking nodes in a DAG as the
main example to develop/illustrate this approach.
To demonstrate the power of the technique though, they
reason about the Cheney 2-space garbage collection algorithm.



[magic wand]: #notes-magic-wand
[permission logic]: #notes-permission-logic
[separation logic]: #notes-separation-logic
[frame rule]: #notes-frame-rule
[krishnaswami:tldi:2010]: #papers-krishnaswami-tldi-2010
# The VFiasco approach for a verified operating system {#papers-hohmuth-plos-2005}


Michael Hohmuth, Hendrik Tews
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20VFiasco%20approach%20for%20a%20verified%20operating%20system)
[[DBLP]](https://dblp.org/search?q=The%20VFiasco%20approach%20for%20a%20verified%20operating%20system)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20VFiasco%20approach%20for%20a%20verified%20operating%20system)





# Applying source-code verification to a microkernel: the VFiasco project {#papers-hohmuth-sigops-2002}


Michael Hohmuth, Hendrik Tews, Shane G. Stephens
Proceedings of the 10th workshop on ACM SIGOPS European workshop
ACM
Pages 165-169
2002
[[Google Scholar]](https://scholar.google.com/scholar?q=Applying%20source-code%20verification%20to%20a%20microkernel%3A%20the%20VFiasco%20project)
[[DBLP]](https://dblp.org/search?q=Applying%20source-code%20verification%20to%20a%20microkernel%3A%20the%20VFiasco%20project)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Applying%20source-code%20verification%20to%20a%20microkernel%3A%20the%20VFiasco%20project)
[[doi]](https://doi.org/10.1145/1133373.1133405)





# FShell: Systematic test case generation for dynamic analysis and measurement {#papers-holzer-cav-2008}


Andreas Holzer, Christian Schallhart, Michael Tautschnig, Helmut Veith
Computer Aided Verification
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 209-213
2008
[[Google Scholar]](https://scholar.google.com/scholar?q=FShell%3A%20Systematic%20test%20case%20generation%20for%20dynamic%20analysis%20and%20measurement)
[[DBLP]](https://dblp.org/search?q=FShell%3A%20Systematic%20test%20case%20generation%20for%20dynamic%20analysis%20and%20measurement)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=FShell%3A%20Systematic%20test%20case%20generation%20for%20dynamic%20analysis%20and%20measurement)
[[doi]](https://doi.org/10.1007/978-3-540-70545-1_20)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-70545-1)

Notes: 
[BLAST verifier](#BLAST verifier),
[CBMC verifier](#CBMC verifier),
[FQL](#FQL),
[SV-competition](#SV-competition)\
Papers: 
[holzer:hvc:2010](#holzer-hvc-2010)\
Referenced by: 
[papers/beyer:hvc:2017](#papers-beyer-hvc-2017),
[papers/holzer:hvc:2010](#papers-holzer-hvc-2010),
[notes/fql](#notes-fql)\


FShell adapts the "program as database" metaphor previously used by the [BLAST
verifier] from model checking to test generation.
It generates families of testcases based on coverage criteria
specified using the "FShell" query language ([FQL]) that (I think) was introduced
in this paper.

([FQL] is not described in detail in this paper.)

FShell uses CBMC as a backend (FQL was later used with many other tools in
[SV-Competition]).

FShell is compared against the [BLAST verifier] on five cases ranging from
4800 to 45,000 lloc (logical lines of code == number of semicolons).
(The benchmarks come from BLAST.)
FShell is faster though the paper admits that BLAST
is really a tool for full verification whereas FShell is optimized for
generating tests.
FShell generates more tests to achieve the same basic block coverage.

Also evaluated on three sorting algorithms (bubble, insertion, selection)
while varying the input size. Presented as speedup against a model checker
(probaby CBMC?).



[BLAST verifier]: #notes-blast-verifier
[CBMC verifier]: #notes-cbmc-verifier
[FQL]: #notes-fql
[SV-competition]: #notes-sv-competition
[holzer:hvc:2010]: #papers-holzer-hvc-2010
# An introduction to test specification in FQL {#papers-holzer-hvc-2010}


Andreas Holzer, Michael Tautschnig, Christian Schallhart, Helmut Veith
Hardware and Software: Verification and Testing
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 9-22
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=An%20introduction%20to%20test%20specification%20in%20FQL)
[[DBLP]](https://dblp.org/search?q=An%20introduction%20to%20test%20specification%20in%20FQL)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=An%20introduction%20to%20test%20specification%20in%20FQL)
[[doi]](https://doi.org/10.1007/978-3-642-19583-9_5)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-19583-9)

Notes: 
[FQL](#FQL)\
Papers: 
[holzer:cav:2008](#holzer-cav-2008)\
Referenced by: 
[papers/beyer:hvc:2017](#papers-beyer-hvc-2017),
[papers/holzer:cav:2008](#papers-holzer-cav-2008),
[notes/fql](#notes-fql)\


Proposes a query language [FQL] for specifying coverage goals that can be used for

- testcase generation
- coverage measurement
- generating code (?)
- hybrid testing tools based on model checking
- distributed testcase generation
- testsuite improvement tools that detect gaps and generate tests to fill them

Path patterns is a good approach for individual tests but not for entire test
suites.
They need a language for specifying all the path patterns of interest:
a meta-regex that specifies sets of regexps using quoted regexps.

The FQL language is specified (see [FQL]) and there are a number of examples to
illustrate the language.

FShell 2 was an interactive frontend and used CBMC as a backend.
FShell 3 builds on CPAChecker and can measure the coverage of existing
testsuites.



[FQL]: #notes-fql
[holzer:cav:2008]: #papers-holzer-cav-2008
# Testing noninterference, quickly {#papers-hritcu-icfp-2013}


Cătǎlin Hriţcu, John Hughes, Benjamin C. Pierce, Antal Spector-Zabusky, Dimitrios Vytiniotis, Arthur Azevedo de Amorim, Leonidas Lampropoulos
Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming
ICFP'13
Boston, Massachusetts, USA
ACM
New York, NY, USA
Pages 455-468
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Testing%20noninterference%2C%20quickly)
[[DBLP]](https://dblp.org/search?q=Testing%20noninterference%2C%20quickly)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Testing%20noninterference%2C%20quickly)
[[doi]](https://doi.org/10.1145/2500365.2500574)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-2326-0)
[[url]](http://doi.acm.org/10.1145/2500365.2500574)

Notes: 
[information flow](#information flow),
[non-interference](#non-interference)\




[information flow]: #notes-information-flow
[non-interference]: #notes-non-interference
# Instruction-level abstraction (ILA): A uniform specification for system-on-chip (SoC) verification {#papers-huang-todaes-2019}


Bo-Yuan Huang, Hongce Zhang, Pramod Subramanyan, Yakir Vizel, Aarti Gupta, Sharad Malik
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Instruction-level%20abstraction%20%28ILA%29%3A%20A%20uniform%20specification%20for%20system-on-chip%20%28SoC%29%20verification)
[[DBLP]](https://dblp.org/search?q=Instruction-level%20abstraction%20%28ILA%29%3A%20A%20uniform%20specification%20for%20system-on-chip%20%28SoC%29%20verification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Instruction-level%20abstraction%20%28ILA%29%3A%20A%20uniform%20specification%20for%20system-on-chip%20%28SoC%29%20verification)
[[doi]](https://doi.org/10.1145/3282444)

Notes: 
[CPU verification](#CPU verification),
[ISA specification](#ISA specification)\



[CPU verification]: #notes-cpu-verification
[ISA specification]: #notes-isa-specification
# Microprocessor design verification {#papers-hunt-jar-1989}


Warren A. Hunt Jr.
Springer-Verlag New York, Inc.
Secaucus, NJ, USA
Pages 429-460
November
1989
[[Google Scholar]](https://scholar.google.com/scholar?q=Microprocessor%20design%20verification)
[[DBLP]](https://dblp.org/search?q=Microprocessor%20design%20verification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Microprocessor%20design%20verification)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# FM8501: A verified microprocessor {#papers-hunt-lncs-1994}


Warren A. Hunt Jr.
Springer
1994
[[Google Scholar]](https://scholar.google.com/scholar?q=FM8501%3A%20A%20verified%20microprocessor)
[[DBLP]](https://dblp.org/search?q=FM8501%3A%20A%20verified%20microprocessor)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=FM8501%3A%20A%20verified%20microprocessor)
[[doi]](https://doi.org/10.1007/3-540-57960-5)
[[ISBN]](http://books.google.com/books?vid=ISBN3-540-57960-5)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# Verifying the FM9801 microarchitecture {#papers-hunt-micro-1999}


Warren A. Hunt Jr., Jun Sawada
IEEE Computer Society Press
Los Alamitos, CA, USA
Pages 47-55
May
1999
[[Google Scholar]](https://scholar.google.com/scholar?q=Verifying%20the%20FM9801%20microarchitecture)
[[DBLP]](https://dblp.org/search?q=Verifying%20the%20FM9801%20microarchitecture)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Verifying%20the%20FM9801%20microarchitecture)
[[doi]](https://doi.org/10.1109/40.768503)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# Alloy: A lightweight object modelling notation {#papers-jackson-tosem-2002}


Daniel Jackson
ACM
New York, NY, USA
Pages 256-290
April
2002
[[Google Scholar]](https://scholar.google.com/scholar?q=Alloy%3A%20A%20lightweight%20object%20modelling%20notation)
[[DBLP]](https://dblp.org/search?q=Alloy%3A%20A%20lightweight%20object%20modelling%20notation)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Alloy%3A%20A%20lightweight%20object%20modelling%20notation)
[[doi]](https://doi.org/10.1145/505145.505149)

Notes: 
[Alloy verifier](#Alloy verifier),
[requirements specification](#requirements specification)\



[Alloy verifier]: #notes-alloy-verifier
[requirements specification]: #notes-requirements-specification
# VeriFast: A powerful, sound, predictable, fast verifier for C and Java {#papers-jacobs-nfm-2011}


Bart Jacobs, Jan Smans, Pieter Philippaerts, Frédéric Vogels, Willem Penninckx, Frank Piessens
NASA Formal Methods Symposium
Springer
Pages 41-55
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=VeriFast%3A%20A%20powerful%2C%20sound%2C%20predictable%2C%20fast%20verifier%20for%20C%20and%20Java)
[[DBLP]](https://dblp.org/search?q=VeriFast%3A%20A%20powerful%2C%20sound%2C%20predictable%2C%20fast%20verifier%20for%20C%20and%20Java)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=VeriFast%3A%20A%20powerful%2C%20sound%2C%20predictable%2C%20fast%20verifier%20for%20C%20and%20Java)
[[doi]](https://doi.org/10.1007/978-3-642-20398-5_4)

Notes: 
[permission logic](#permission logic),
[separation logic](#separation logic),
[fractional permissions](#fractional permissions),
[permission accounting](#permission accounting),
[VeriFast verifier](#VeriFast verifier),
[ghost code](#ghost code),
[SMT solver](#SMT solver),
[auto-active verification](#auto-active verification)\
Papers: 
[bornat:popl:2005](#bornat-popl-2005),
[jacobs:vstte:2010](#jacobs-vstte-2010),
[philippaerts:scp:2014](#philippaerts-scp-2014)\
Referenced by: 
[papers/astrauskas:oopsla:2019](#papers-astrauskas-oopsla-2019),
[papers/berdine:fmco:2005](#papers-berdine-fmco-2005),
[papers/legoues:sefm:2011](#papers-legoues-sefm-2011),
[papers/philippaerts:scp:2014](#papers-philippaerts-scp-2014),
[papers/smans:ecoop:2009](#papers-smans-ecoop-2009),
[papers/tuerk:vstte:2010](#papers-tuerk-vstte-2010),
[notes/verifast-verifier](#notes-verifast-verifier)\


VeriFast is an auto-active verification tool for C and Java based on separation
logic and SMT solvers.
This paper is a nice overview of the state of the project in 2011 when they had

- a symbolic execution based checker with a nice UI
- support for both C and Java
- support for
  [permission accounting][bornat:popl:2005]
  based on fractional permissions and an encoding of counting permissions
- support for
  [writing (recursive) lemma functions][jacobs:vstte:2010]
  to prove inductive properties
- and they were starting on some
  [industrial case studies][philippaerts:scp:2014]




[permission logic]: #notes-permission-logic
[separation logic]: #notes-separation-logic
[fractional permissions]: #notes-fractional-permissions
[permission accounting]: #notes-permission-accounting
[VeriFast verifier]: #notes-verifast-verifier
[ghost code]: #notes-ghost-code
[SMT solver]: #notes-smt-solver
[auto-active verification]: #notes-auto-active-verification
[bornat:popl:2005]: #papers-bornat-popl-2005
[jacobs:vstte:2010]: #papers-jacobs-vstte-2010
[philippaerts:scp:2014]: #papers-philippaerts-scp-2014
# VeriFast: Imperative programs as proofs {#papers-jacobs-vstte-2010}


Bart Jacobs, Jan Smans, Frank Piessens
VSTTE workshop on Tools and Experiments
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=VeriFast%3A%20Imperative%20programs%20as%20proofs)
[[DBLP]](https://dblp.org/search?q=VeriFast%3A%20Imperative%20programs%20as%20proofs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=VeriFast%3A%20Imperative%20programs%20as%20proofs)

Notes: 
[permission logic](#permission logic),
[separation logic](#separation logic),
[fractional permissions](#fractional permissions),
[permission accounting](#permission accounting),
[VeriFast verifier](#VeriFast verifier),
[ghost code](#ghost code),
[SMT solver](#SMT solver),
[auto-active verification](#auto-active verification)\
Papers: 
[reynolds:lics:2002](#reynolds-lics-2002)\
Referenced by: 
[papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011),
[papers/muller:vmcai:2016](#papers-muller-vmcai-2016),
[notes/verifast-verifier](#notes-verifast-verifier)\


[VeriFast](https://github.com/verifast/verifast)
is a symbolic evaluator based on
[Separation Logic][reynolds:lics:2002]
[(wikipedia)](https://en.wikipedia.org/wiki/Separation_logic)
for verifying C and Java code.
Specifications can use inductive datatypes,
primitive recursive functions and abstract predicates.
As the name suggests, a key feature is performance
though the abstract also mentions predictability.

Proof in VeriFast relies on symbolic evaluation (using an SMT solver)
but can be assisted by lemmas that are written as imperative
functions.
I think the essence of this is that if you can prove correctness of
a terminating lemma function with contract "requires P; ensures Q;",
then "P —∗ Q".
(Where "—∗" (pronounced "magic wand") is "separating
implication" from separation logic.)
These lemma functions are allowed to be recursive so it is possible to
write inductive proofs.



[permission logic]: #notes-permission-logic
[separation logic]: #notes-separation-logic
[fractional permissions]: #notes-fractional-permissions
[permission accounting]: #notes-permission-accounting
[VeriFast verifier]: #notes-verifast-verifier
[ghost code]: #notes-ghost-code
[SMT solver]: #notes-smt-solver
[auto-active verification]: #notes-auto-active-verification
[reynolds:lics:2002]: #papers-reynolds-lics-2002
# Microarchitecture verification by compositional model checking {#papers-jhala-cav-2001}


Ranjit Jhala, Kenneth L. McMillan
Computer Aided Verification
Lecture Notes in Computer Science, volume 2102
Springer
Pages 396-410
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=Microarchitecture%20verification%20by%20compositional%20model%20checking)
[[DBLP]](https://dblp.org/search?q=Microarchitecture%20verification%20by%20compositional%20model%20checking)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Microarchitecture%20verification%20by%20compositional%20model%20checking)
[[doi]](https://doi.org/10.1007/3-540-44585-4_40)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-42345-4)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# Software model checking {#papers-jhala-compsurv-2009}


Ranjit Jhala, Rupak Majumdar
Association for Computing Machinery
New York, NY, USA
October
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Software%20model%20checking)
[[DBLP]](https://dblp.org/search?q=Software%20model%20checking)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Software%20model%20checking)
[[doi]](https://doi.org/10.1145/1592434.1592438)
[[url]](https://doi.org/10.1145/1592434.1592438)

Notes: 
[survey](#survey),
[model checking](#model checking),
[bounded model checking](#bounded model checking),
[partial order reduction](#partial order reduction),
[symbolic evaluation](#symbolic evaluation),
[symbolic execution](#symbolic execution),
[symbolic model checking](#symbolic model checking),
[reachability](#reachability),
[separation logic](#separation logic),
[alias analysis](#alias analysis),
[shape analysis](#shape analysis),
[temporal logic](#temporal logic),
[buchi automaton](#buchi automaton),
[kripke structure](#kripke structure),
[BDD](#BDD),
[CEGAR](#CEGAR),
[BLAST verifier](#BLAST verifier),
[CBMC verifier](#CBMC verifier),
[KLEE verifier](#KLEE verifier)\
Referenced by: 
[papers/mcmillan:ecs:2003](#papers-mcmillan-ecs-2003),
[notes/bounded-model-checking](#notes-bounded-model-checking),
[notes/model-checking](#notes-model-checking)\


This 2009 [survey] of software [model checking] covers a lot of
ground from the roots in hardware model checking through to its
application to software.
A number of the key algorithms are described in pseudocode.

The sections give a good sense of what is covered

- Introduction
- Preliminary definitions
  - Simple programs
  - Properties
  - Organization
- Concrete enumerative model checking

  (For small, finite state spaces)
  - Stateful search

    Forward and backward algorithms,
    [Partial order reduction],
    compositional techniques,
    assume-guarantee
  - Systematic execution exploration

    Test amplification
  - Stateless search
  - Execution-based tools

    VeriSoft, JavaPathFinder, Cmc, MaceMC
- Concrete symbolic model checking
  - The region data structure

    SymbolicReachability algorithm,
    [reachability]
  - Example: propositional logic

    [BDD]s
  - Example: first order logic with interpreted theories
  - [Bounded model checking]

    [symbolic execution]
  - Invariants and invariant synthesis

    abstraction techniques for invariant synthesis,
    k-induction,
    template-based synthesis
- Model checking and abstraction

  [reachability],
  - Abstract reachability analysis

    Finite height domains;
    infinite height domains and widening operators
  - Example: polyhedral domains
  - Example: predicate abstraction

    SLAM verifier,
    [BLAST verifier],
    cartesian predicate abstraction
  - Example: control abstraction

    sequential programs,
    concurrent programs
  - Combined abstractions

    > Gulwani and Tiwari shows a general framework for
    > combining abstract interpretations for different
    > theories, analogous to the manner in which decision
    > procedures for different theories are combined.

- Abstraction refinement

  [CEGAR]
  - Counterexamples and refinement
    - Counterexamples
    - Trace formulas
    - Syntax-based refinement
    - Interpolation-based refinement
    - Relative completeness
    - Refining multiple paths
    - Refining other domains
  - Abstraction-refinement-based model checkers
    - SLAM verifier and BEBOP
    - [BLAST verifier] and lazy refinement
    - Magic and concurrent, message-passing C programs
    - F-Soft
    - IMPACT
    - ARMC
- Procedural abstraction
  - Programs with procedures
  - InterProcedural reachability

    memoization
    - Graph-based algorithms
    - Symbolic algorithms
    - Abstraction
    - Top-down vs. Bottom-up
    - Saturn
    - Houdini
  - Concurrency and recursion
- Heap data structures
  - [Alias analysis]
  - [Shape analysis]
  - [Separation logic]
  - Reachability predicates
  - Quantified loop invariants
- Liveness and termination
  - Finite state

    [Büchi automaton][buchi automaton],
    LTL [temporal logic],
    pushdown systems
  - Infinite state

    Program termination,
    fairness conditions
  - Nontermination
- Model checking and software quality
  - Model checking and testing

    underapproximation
    - Test generation by [symbolic evaluation]
  - Model checking and type systems
    - Typestates
    - Dependent types
    - Hybrid type checking
- Conclusion



[survey]: #notes-survey
[model checking]: #notes-model-checking
[bounded model checking]: #notes-bounded-model-checking
[partial order reduction]: #notes-partial-order-reduction
[symbolic evaluation]: #notes-symbolic-evaluation
[symbolic execution]: #notes-symbolic-execution
[symbolic model checking]: #notes-symbolic-model-checking
[reachability]: #notes-reachability
[separation logic]: #notes-separation-logic
[alias analysis]: #notes-alias-analysis
[shape analysis]: #notes-shape-analysis
[temporal logic]: #notes-temporal-logic
[buchi automaton]: #notes-buchi-automaton
[kripke structure]: #notes-kripke-structure
[BDD]: #notes-bdd
[CEGAR]: #notes-cegar
[BLAST verifier]: #notes-blast-verifier
[CBMC verifier]: #notes-cbmc-verifier
[KLEE verifier]: #notes-klee-verifier
# CRL: High-performance all-software distributed shared memory {#papers-johnson-osr-1995}


Kirk L. Johnson, M. Frans Kaashoek, Deborah A. Wallach
ACM
New York, NY, USA
Pages 213-226
December
1995
[[Google Scholar]](https://scholar.google.com/scholar?q=CRL%3A%20High-performance%20all-software%20distributed%20shared%20memory)
[[DBLP]](https://dblp.org/search?q=CRL%3A%20High-performance%20all-software%20distributed%20shared%20memory)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=CRL%3A%20High-performance%20all-software%20distributed%20shared%20memory)
[[doi]](https://doi.org/10.1145/224057.224073)

Notes: 
[distributed shared memory](#distributed shared memory)\



[distributed shared memory]: #notes-distributed-shared-memory
# Haskell 98: A non-strict, purely functional language {#papers-jones-hasklang-1999}


Simon L. Peyton Jones, Lennart Augustsson, Dave Barton, Brian Boutel, Warren Burton, Joseph Fasel, Kevin Hammond, Ralf Hinze, Paul Hudak, John Hughes, Thomas Johnsson, Mark Jones, John Launchbury, Erik Meijer, John Peterson, Alastair D. Reid, Colin Runciman, Philip Wadler
1999
[[Google Scholar]](https://scholar.google.com/scholar?q=Haskell%2098%3A%20A%20non-strict%2C%20purely%20functional%20language)
[[DBLP]](https://dblp.org/search?q=Haskell%2098%3A%20A%20non-strict%2C%20purely%20functional%20language)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Haskell%2098%3A%20A%20non-strict%2C%20purely%20functional%20language)
[[url]](https://www.haskell.org/definition/)

Notes: 
[Haskell language](#Haskell language)\




[Haskell language]: #notes-haskell-language
# Standard libraries for the Haskell 98 programming language {#papers-jones-hasklib-1999}


Simon L. Peyton Jones, Lennart Augustsson, Dave Barton, Brian Boutel, Warren Burton, Joseph Fasel, Kevin Hammond, Ralf Hinze, Paul Hudak, John Hughes, Thomas Johnsson, Mark Jones, John Launchbury, Erik Meijer, John Peterson, Alastair D. Reid, Colin Runciman, Philip Wadler
1999
[[Google Scholar]](https://scholar.google.com/scholar?q=Standard%20libraries%20for%20the%20Haskell%2098%20programming%20language)
[[DBLP]](https://dblp.org/search?q=Standard%20libraries%20for%20the%20Haskell%2098%20programming%20language)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Standard%20libraries%20for%20the%20Haskell%2098%20programming%20language)
[[url]](https://www.haskell.org/definition/)

Notes: 
[Haskell language](#Haskell language)\




[Haskell language]: #notes-haskell-language
# Green Card: a foreign-language interface for Haskell {#papers-jones-hw-1997}


Simon L. Peyton Jones, Thomas Nordin, Alastair D. Reid
Proceedings of the Haskell Workshop
Amsterdam, Netherlands
June
1997
[[Google Scholar]](https://scholar.google.com/scholar?q=Green%20Card%3A%20a%20foreign-language%20interface%20for%20Haskell)
[[DBLP]](https://dblp.org/search?q=Green%20Card%3A%20a%20foreign-language%20interface%20for%20Haskell)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Green%20Card%3A%20a%20foreign-language%20interface%20for%20Haskell)

Notes: 
[Haskell language](#Haskell language),
[foreign function interface](#foreign function interface)\
Papers: 
[chakravarty:haskffi:2003](#chakravarty-haskffi-2003),
[jones:hw:1997](#jones-hw-1997)\
Referenced by: 
[papers/chakravarty:haskffi:2003](#papers-chakravarty-haskffi-2003),
[papers/jones:hw:1997](#papers-jones-hw-1997),
[notes/foreign-function-interface](#notes-foreign-function-interface)\




[Haskell language]: #notes-haskell-language
[foreign function interface]: #notes-foreign-function-interface
[chakravarty:haskffi:2003]: #papers-chakravarty-haskffi-2003
[jones:hw:1997]: #papers-jones-hw-1997
# Playing by the rules: rewriting as a practical optimisation technique in GHC {#papers-jones-microsoft-2001}


Simon L. Peyton Jones, Andrew Tolmach, C. A. R. Hoare
Proceedings of the 2001 Haskell Workshop
September
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=Playing%20by%20the%20rules%3A%20rewriting%20as%20a%20practical%20optimisation%20technique%20in%20GHC)
[[DBLP]](https://dblp.org/search?q=Playing%20by%20the%20rules%3A%20rewriting%20as%20a%20practical%20optimisation%20technique%20in%20GHC)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Playing%20by%20the%20rules%3A%20rewriting%20as%20a%20practical%20optimisation%20technique%20in%20GHC)
[[ISBN]](http://books.google.com/books?vid=ISBN)
[[url]](https://www.microsoft.com/en-us/research/publication/playing-by-the-rules-rewriting-as-a-practical-optimisation-technique-in-ghc/)

Notes: 
[rewrite rules](#rewrite rules)\



[rewrite rules]: #notes-rewrite-rules
# A semantics for imprecise exceptions {#papers-jones-pldi-1999}


Simon L. Peyton Jones, Alastair D. Reid, Fergus Henderson, C. A. R. Hoare, Simon Marlow
Proceedings of the 1999 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI '99)
Atlanta, Georgia, USA
ACM
Pages 25-36
1-4
May
1999
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20semantics%20for%20imprecise%20exceptions)
[[DBLP]](https://dblp.org/search?q=A%20semantics%20for%20imprecise%20exceptions)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20semantics%20for%20imprecise%20exceptions)
[[doi]](https://doi.org/10.1145/301618.301637)

Notes: 
[Haskell language](#Haskell language)\




[Haskell language]: #notes-haskell-language
# Denali: A goal-directed superoptimizer {#papers-joshi-pldi-2002}


Rajeev Joshi, Greg Nelson, Keith Randall
Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation
PLDI '02
Berlin, Germany
Association for Computing Machinery
New York, NY, USA
Pages 304-314
2002
[[Google Scholar]](https://scholar.google.com/scholar?q=Denali%3A%20A%20goal-directed%20superoptimizer)
[[DBLP]](https://dblp.org/search?q=Denali%3A%20A%20goal-directed%20superoptimizer)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Denali%3A%20A%20goal-directed%20superoptimizer)
[[doi]](https://doi.org/10.1145/512529.512566)
[[ISBN]](http://books.google.com/books?vid=ISBN1581134630)
[[url]](https://doi.org/10.1145/512529.512566)

Notes: 
[superoptimizer](#superoptimizer)\



[superoptimizer]: #notes-superoptimizer
# RustBelt: Securing the foundations of the Rust programming language {#papers-jung-popl-2017}


Ralf Jung, Jacques-Henri Jourdan, Robbert Krebbers, Derek Dreyer
Association for Computing Machinery
New York, NY, USA
December
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=RustBelt%3A%20Securing%20the%20foundations%20of%20the%20Rust%20programming%20language)
[[DBLP]](https://dblp.org/search?q=RustBelt%3A%20Securing%20the%20foundations%20of%20the%20Rust%20programming%20language)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=RustBelt%3A%20Securing%20the%20foundations%20of%20the%20Rust%20programming%20language)
[[doi]](https://doi.org/10.1145/3158154)
[[url]](https://doi.org/10.1145/3158154)

Notes: 
[permission logic](#permission logic),
[Rust language](#Rust language),
[undefined behaviour](#undefined behaviour),
[mir](#mir),
[Rust unsafe code](#Rust unsafe code),
[Coq theorem prover](#Coq theorem prover)\
Referenced by: 
[papers/jung:popl:2020](#papers-jung-popl-2020),
[papers/toman:ase:2015](#papers-toman-ase-2015),
[notes/rust-language](#notes-rust-language)\


Rust aims to archive the holy grail of a language that gives low-control over resource management and safe high-level abstractions.
It does this using a type system that restricts programs to eliminate unsafe programming practices coupled with a practice of extending that type system with libraries that are observably safe but that internally use “unsafe” operations.
This paper provides a framework for proving that these libraries do not break the safety guarantees of the standard type system.
Along the way, the paper gives a nice insight into the way that the community as a whole has been developing.

This paper departs from standard practice over the last 20 or so years of using syntactic techniques to prove results about the type system.
They argue that these syntactic techniques are closed-world methods but Rust’s extensible type system requires an open-world approach.
So they revert to the older practice of proving type soundness semantically.
This is done in the Iris framework building on “step-indexed” logical relations for scalability.

After a tour of the key concepts in Rust’s ownership type system, they present lambda-rust which is at a level simile are to Rust’s Mid-level Intermediate Representations (MIR) and is (roughly) a continuation passing lambda calculus extended with lifetimes.


For a more detailed summary, I recommend [the morning
paper](https://blog.acolyer.org/2018/01/18/rustbelt-securing-the-foundations-of-the-rust-programming-language/).




[permission logic]: #notes-permission-logic
[Rust language]: #notes-rust-language
[undefined behaviour]: #notes-undefined-behaviour
[mir]: #notes-mir
[Rust unsafe code]: #notes-rust-unsafe-code
[Coq theorem prover]: #notes-coq-theorem-prover
# Stacked borrows: An aliasing model for Rust {#papers-jung-popl-2020}


Ralf Jung, Hoang-Hai Dang, Jeehoon Kang, Derek Dreyer
Association for Computing Machinery
New York, NY, USA
December
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Stacked%20borrows%3A%20An%20aliasing%20model%20for%20Rust)
[[DBLP]](https://dblp.org/search?q=Stacked%20borrows%3A%20An%20aliasing%20model%20for%20Rust)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Stacked%20borrows%3A%20An%20aliasing%20model%20for%20Rust)
[[doi]](https://doi.org/10.1145/3371109)
[[url]](https://doi.org/10.1145/3371109)

Notes: 
[Rust language](#Rust language),
[MIR interpreter](#MIR interpreter),
[undefined behaviour](#undefined behaviour),
[MIR](#MIR),
[Rust unsafe code](#Rust unsafe code),
[Coq theorem prover](#Coq theorem prover)\
Papers: 
[jung:popl:2017](#jung-popl-2017)\
Referenced by: 
[notes/mir-interpreter](#notes-mir-interpreter),
[notes/mir](#notes-mir),
[notes/ownership-types](#notes-ownership-types),
[notes/rust-language](#notes-rust-language),
[notes/rust-unsafe-code](#notes-rust-unsafe-code)\


As in [the Rustbelt paper][jung:popl:2017],
the topic of this paper is the soundness of Rust code that
is marked "unsafe" because it needs to do something that
cannot be expressed within the restrictions of Rust's type
system but that the programmer (hopefully) considers to be
ok.
In particular, this paper defines what the "unsafe" code
is and (crucially) is not allowed to do based on what
they want Rust types to mean.

There is no "right answer" in this sort of paper – you can't
prove that you have the right design.
But what they can do is
- Describe how their choice handles particular tricky cases
- Demonstrate that their choice matches people's expectations on some specific cases.
  (They go further and prove two desirable compiler transformations
  are valid under their semantics.)
- Measure the impact of the semantics on existing code to
  get a sense of whether their model fits with how most
  people in the community think.
  (In the architecture-independent part of the standard
  libraries, they found only six violations of their rules.)
- Persuade the community that any changes required by their
  semantics are acceptable.
  (All six violations have now been fixed.)
  
The major tool that they used for this work is 
"Miri" – an interpreter for Rust that tries to catch
all (most?) undefined behaviour.
They extended this interpreter with 
their semantics to let them experiment with different
variations.
This was clearly key to finding the sweet spot of
a restrictive semantics that lets you prove things
but that fits programmer's existing model of Rust.

The model itself is based on two changes to the semantics

- Tagging pointers so that it is possible to distinguish
  two pointers to the same object.
  (Surprisingly, it did not seem to be necessary to track
  provenance: how a pointer was generated.)
- For each object in memory, maintaining a stack of the
  pointers that are allowed to access it (and in what way).
  A stack of pointers is used to model nested borrowing.
  
The obvious piece of future work is to extend RustBelt
([jung:popl:2017]) with this model.



[Rust language]: #notes-rust-language
[MIR interpreter]: #notes-mir-interpreter
[undefined behaviour]: #notes-undefined-behaviour
[MIR]: #notes-mir
[Rust unsafe code]: #notes-rust-unsafe-code
[Coq theorem prover]: #notes-coq-theorem-prover
[jung:popl:2017]: #papers-jung-popl-2017
# Replacing testing with formal verification in Intel Core i7 processor execution engine validation {#papers-kaivola-cav-2009}


Roope Kaivola, Rajnish Ghughal, Naren Narasimhan, Amber Telfer, Jesse Whittemore, Sudhindra Pandav, Anna Slobodová, Christopher Taylor, Vladimir Frolov, Erik Reeber, Armaghan Naik
Proceedings of the 21st International Conference on Computer Aided Verification
CAV '09
Grenoble, France
Springer-Verlag
Berlin, Heidelberg
Pages 414-429
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Replacing%20testing%20with%20formal%20verification%20in%20Intel%20Core%20i7%20processor%20execution%20engine%20validation)
[[DBLP]](https://dblp.org/search?q=Replacing%20testing%20with%20formal%20verification%20in%20Intel%20Core%20i7%20processor%20execution%20engine%20validation)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Replacing%20testing%20with%20formal%20verification%20in%20Intel%20Core%20i7%20processor%20execution%20engine%20validation)
[[doi]](https://doi.org/10.1007/978-3-642-02658-4_32)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-02657-7)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# Dynamic frames: Support for framing, dependencies and sharing without restrictions {#papers-kassios-fm-2006}


Ioannis T. Kassios
FM 2006: Formal Methods
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 268-283
2006
[[Google Scholar]](https://scholar.google.com/scholar?q=Dynamic%20frames%3A%20Support%20for%20framing%2C%20dependencies%20and%20sharing%20without%20restrictions)
[[DBLP]](https://dblp.org/search?q=Dynamic%20frames%3A%20Support%20for%20framing%2C%20dependencies%20and%20sharing%20without%20restrictions)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Dynamic%20frames%3A%20Support%20for%20framing%2C%20dependencies%20and%20sharing%20without%20restrictions)
[[doi]](https://doi.org/10.1007/11813040_19)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-37216-5)

Notes: 
[permission logic](#permission logic),
[implicit dynamic frames](#implicit dynamic frames)\




[permission logic]: #notes-permission-logic
[implicit dynamic frames]: #notes-implicit-dynamic-frames
# An industrial strength theorem prover for a logic based on Common Lisp {#papers-kaufmann-ieeetse-1997}


Matt Kaufmann, J. Strother Moore
Pages 203-213
April
1997
[[Google Scholar]](https://scholar.google.com/scholar?q=An%20industrial%20strength%20theorem%20prover%20for%20a%20logic%20based%20on%20Common%20Lisp)
[[DBLP]](https://dblp.org/search?q=An%20industrial%20strength%20theorem%20prover%20for%20a%20logic%20based%20on%20Common%20Lisp)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=An%20industrial%20strength%20theorem%20prover%20for%20a%20logic%20based%20on%20Common%20Lisp)
[[doi]](https://doi.org/10.1109/32.588534)

Notes: 
[ACL2 theorem prover](#ACL2 theorem prover)\



[ACL2 theorem prover]: #notes-acl2-theorem-prover
# Towards a formal model of the x86 ISA {#papers-kaufmann-utaustin-2012}


Matt Kaufmann, Warren A. Hunt Jr.
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=Towards%20a%20formal%20model%20of%20the%20x86%20ISA)
[[DBLP]](https://dblp.org/search?q=Towards%20a%20formal%20model%20of%20the%20x86%20ISA)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Towards%20a%20formal%20model%20of%20the%20x86%20ISA)

Notes: 
[ISA specification](#ISA specification),
[x86 architecture](#x86 architecture),
[instruction set architecture](#instruction set architecture)\




[ISA specification]: #notes-isa-specification
[x86 architecture]: #notes-x86-architecture
[instruction set architecture]: #notes-instruction-set-architecture
# Machine assisted proof of ARMv7 instruction level isolation properties {#papers-khakpour-cpp-2013}


Narges Khakpour, Oliver Schwarz, Mads Dam
International Conference on Certified Programs and Proofs
Springer
Pages 276-291
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Machine%20assisted%20proof%20of%20ARMv7%20instruction%20level%20isolation%20properties)
[[DBLP]](https://dblp.org/search?q=Machine%20assisted%20proof%20of%20ARMv7%20instruction%20level%20isolation%20properties)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Machine%20assisted%20proof%20of%20ARMv7%20instruction%20level%20isolation%20properties)
[[doi]](https://doi.org/10.1007/978-3-319-03545-1_18)

Notes: 
[information flow](#information flow),
[Arm architecture](#Arm architecture)\




[information flow]: #notes-information-flow
[Arm architecture]: #notes-arm-architecture
# Towards a new model of abstraction in software engineering {#papers-kiczales-iwoos-1991}


Gregor Kiczales
Proceedings of the 1991 International Workshop on Object Orientation in Operating Systems
IEEE
Pages 127-128
1991
[[Google Scholar]](https://scholar.google.com/scholar?q=Towards%20a%20new%20model%20of%20abstraction%20in%20software%20engineering)
[[DBLP]](https://dblp.org/search?q=Towards%20a%20new%20model%20of%20abstraction%20in%20software%20engineering)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Towards%20a%20new%20model%20of%20abstraction%20in%20software%20engineering)
[[doi]](https://doi.org/10.1109/IWOOOS.1991.183036)

Notes: 
[Aspect oriented programming](#Aspect oriented programming)\



[Aspect oriented programming]: #notes-aspect-oriented-programming
# Flipping bits in memory without accessing them: An experimental study of DRAM disturbance errors {#papers-kim-isca-2014}


Yoongu Kim, Ross Daly, Jeremie Kim, Chris Fallin, Ji Hye Lee, Donghyuk Lee, Chris Wilkerson, Konrad Lai, Onur Mutlu
Proceeding of the 41st Annual International Symposium on Computer Architecuture
ISCA '14
Minneapolis, Minnesota, USA
IEEE Press
Piscataway, NJ, USA
Pages 361-372
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=Flipping%20bits%20in%20memory%20without%20accessing%20them%3A%20An%20experimental%20study%20of%20DRAM%20disturbance%20errors)
[[DBLP]](https://dblp.org/search?q=Flipping%20bits%20in%20memory%20without%20accessing%20them%3A%20An%20experimental%20study%20of%20DRAM%20disturbance%20errors)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Flipping%20bits%20in%20memory%20without%20accessing%20them%3A%20An%20experimental%20study%20of%20DRAM%20disturbance%20errors)
[[doi]](https://doi.org/10.1145/2678373.2665726)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4799-4394-4)

Notes: 
[microarchitecture](#microarchitecture),
[side channel](#side channel)\



[microarchitecture]: #notes-microarchitecture
[side channel]: #notes-side-channel
# Symbolic trajectory evaluation: The primary validation vehicle for next generation Intel processor graphics FPU {#papers-kirankumar-fmcad-2012}


V. M. Achutha KiranKumar, Arpan Gupta, Rajnish Ghughal
Formal Methods in Computer-Aided Design (FMCAD), 2012
IEEE
Pages 149-156
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=Symbolic%20trajectory%20evaluation%3A%20The%20primary%20validation%20vehicle%20for%20next%20generation%20Intel%20processor%20graphics%20FPU)
[[DBLP]](https://dblp.org/search?q=Symbolic%20trajectory%20evaluation%3A%20The%20primary%20validation%20vehicle%20for%20next%20generation%20Intel%20processor%20graphics%20FPU)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Symbolic%20trajectory%20evaluation%3A%20The%20primary%20validation%20vehicle%20for%20next%20generation%20Intel%20processor%20graphics%20FPU)

Notes: 
[symbolic trajectory evaluation](#symbolic trajectory evaluation),
[CPU verification](#CPU verification),
[x86 architecture](#x86 architecture)\
Papers: 
[segar:fmsd:1995](#segar-fmsd-1995)\



[symbolic trajectory evaluation]: #notes-symbolic-trajectory-evaluation
[CPU verification]: #notes-cpu-verification
[x86 architecture]: #notes-x86-architecture
[segar:fmsd:1995]: #papers-segar-fmsd-1995
# The Rust programming language {#papers-klabnik-book-2018}


Steve Klabnik, Carol Nichols
No Starch Press
USA
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20Rust%20programming%20language)
[[DBLP]](https://dblp.org/search?q=The%20Rust%20programming%20language)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20Rust%20programming%20language)
[[ISBN]](http://books.google.com/books?vid=ISBN9781593278281)

Notes: 
[Rust language](#Rust language)\



[Rust language]: #notes-rust-language
# SeL4: Formal verification of an OS kernel {#papers-klein-sosp-2009}


Gerwin Klein, Kevin Elphinstone, Gernot Heiser, June Andronick, David Cock, Philip Derrin, Dhammika Elkaduwe, Kai Engelhardt, Rafal Kolanski, Michael Norrish, Thomas Arthur Leck Sewell, Harvey Tuch, Simon Winwood
Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Principles
SOSP '09
Big Sky, Montana, USA
Association for Computing Machinery
New York, NY, USA
Pages 207-220
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=SeL4%3A%20Formal%20verification%20of%20an%20OS%20kernel)
[[DBLP]](https://dblp.org/search?q=SeL4%3A%20Formal%20verification%20of%20an%20OS%20kernel)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=SeL4%3A%20Formal%20verification%20of%20an%20OS%20kernel)
[[doi]](https://doi.org/10.1145/1629575.1629596)
[[ISBN]](http://books.google.com/books?vid=ISBN9781605587523)
[[url]](https://doi.org/10.1145/1629575.1629596)

Referenced by: 
[papers/murray:secpriv:2013](#papers-murray-secpriv-2013),
[notes/annotation-burden](#notes-annotation-burden)\




# Spectre attacks: Exploiting speculative execution {#papers-kocher-arxiv-2018}


Paul Kocher, Daniel Genkin, Daniel Gruss, Werner Haas, Mike Hamburg, Moritz Lipp, Stefan Mangard, Thomas Prescher, Michael Schwarz, Yuval Yarom
January
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=Spectre%20attacks%3A%20Exploiting%20speculative%20execution)
[[DBLP]](https://dblp.org/search?q=Spectre%20attacks%3A%20Exploiting%20speculative%20execution)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Spectre%20attacks%3A%20Exploiting%20speculative%20execution)
[[arXiv]](https://arxiv.org/1801.01203)

Notes: 
[microarchitecture](#microarchitecture),
[side channel](#side channel)\



[microarchitecture]: #notes-microarchitecture
[side channel]: #notes-side-channel
# Differential power analysis {#papers-kocher-crypto-1999}


Paul Kocher, Joshua Jaffe, Benjamin Jun
Advances in Cryptology -- CRYPTO' 99
Springer
Pages 388-397
1999
[[Google Scholar]](https://scholar.google.com/scholar?q=Differential%20power%20analysis)
[[DBLP]](https://dblp.org/search?q=Differential%20power%20analysis)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Differential%20power%20analysis)
[[doi]](https://doi.org/10.1007/3-540-48405-1_25)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-48405-9)

Notes: 
[differential power analysis](#differential power analysis),
[microarchitecture](#microarchitecture),
[side channel](#side channel),
[security](#security)\
Referenced by: 
[notes/differential-power-analysis](#notes-differential-power-analysis)\



[differential power analysis]: #notes-differential-power-analysis
[microarchitecture]: #notes-microarchitecture
[side channel]: #notes-side-channel
[security]: #notes-security
# Scalable vector media processors for embedded systems {#papers-kozyrakis-phd-2002}


Christoforos Kozyrakis
Ph.D. thesis
University of California, Berkeley
May
2002
[[Google Scholar]](https://scholar.google.com/scholar?q=Scalable%20vector%20media%20processors%20for%20embedded%20systems)
[[DBLP]](https://dblp.org/search?q=Scalable%20vector%20media%20processors%20for%20embedded%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Scalable%20vector%20media%20processors%20for%20embedded%20systems)

Notes: 
[vector architecture](#vector architecture),
[microarchitecture](#microarchitecture),
[instruction set architecture](#instruction set architecture),
[SIMD](#SIMD),
[data parallelism](#data parallelism)\



[vector architecture]: #notes-vector-architecture
[microarchitecture]: #notes-microarchitecture
[instruction set architecture]: #notes-instruction-set-architecture
[SIMD]: #notes-simd
[data parallelism]: #notes-data-parallelism
# The human in formal methods {#papers-krishnamurthi-fm-2019}


Shriram Krishnamurthi, Tim Nelson
Formal Methods - The Next 30 Years
Springer International Publishing
Cham
Pages 3-10
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20human%20in%20formal%20methods)
[[DBLP]](https://dblp.org/search?q=The%20human%20in%20formal%20methods)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20human%20in%20formal%20methods)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-030-30942-8)

Notes: 
[SAT solver](#SAT solver),
[SMT solver](#SMT solver),
[Alloy verifier](#Alloy verifier),
[Model checking](#Model checking),
[Human factors](#Human factors)\


This invited talk looks at "how to bring the other 90%
into the fold" of formal methods with a focus on
education, comfort with formal methods and effectiveness with formal methods.
This focus leads to emphasizing model finding such as the [Alloy verifier], [SAT
solver]s and [SMT solver]s over deductive methods.

User experience is briefly discussed – mentioning that model finders are "often
integrated into higher-level tools (with their output presented in
a domain-specific way)".

The main focus is on education and especially creating specifications which is
based on an analogy to the author's "How to design programs" book that breaks
creating a program into seven steps starting with designing I/O data structures and
examples and ending with testing.
Each of these steps leads to distinct artifacts.
This builds on a lot of cognitive theory from education research and the notion
of "concreteness fading" as design goes from concrete examples to more
flexible/abstract/generalized code.

In an educational setting, they can lean on the availability of "ground truth":
the instructor already understands the problem and has a solution.  This allows
any artifacts (e.g., examples) developed during the design process to be
automatically checked against the instructors solution and feedback given in
the form of new examples for the student to consider.  (The author's have
published about this before in the context of program design.)



[SAT solver]: #notes-sat-solver
[SMT solver]: #notes-smt-solver
[Alloy verifier]: #notes-alloy-verifier
[Model checking]: #notes-model-checking
[Human factors]: #notes-human-factors
# Verifying event-driven programs using ramified frame properties {#papers-krishnaswami-tldi-2010}


Neel R. Krishnaswami, Lars Birkedal, Jonathan Aldrich
Proceedings of the 5th ACM SIGPLAN Workshop on Types in Language Design and Implementation
TLDI '10
Madrid, Spain
Association for Computing Machinery
New York, NY, USA
Pages 63-76
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=Verifying%20event-driven%20programs%20using%20ramified%20frame%20properties)
[[DBLP]](https://dblp.org/search?q=Verifying%20event-driven%20programs%20using%20ramified%20frame%20properties)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Verifying%20event-driven%20programs%20using%20ramified%20frame%20properties)
[[doi]](https://doi.org/10.1145/1708016.1708025)
[[ISBN]](http://books.google.com/books?vid=ISBN9781605588919)
[[url]](https://doi.org/10.1145/1708016.1708025)

Notes: 
[permission logic](#permission logic),
[separation logic](#separation logic),
[frame rule](#frame rule),
[magic wand](#magic wand)\
Referenced by: 
[papers/hobor:popl:2013](#papers-hobor-popl-2013)\


Separation logic's strength is that it let's you reason locally
about heap-manipulating programs by letting you split the
heap into disjoint parts.
But some data structures don't easily split into parts
and you have to maintain global consistency properties
across the structure because they "use mutation
and assignment as a way of globally broadcasting information
to the rest of the program state."
This paper tackles an example of such a structure:
an instance of the subject-observer pattern like that 
found in a spreadsheet where
each node contains a list of the nodes it depends on
and also of the nodes that depend on it
so that, when a node changes value, nodes that depend on it
can be invalidated/updated.

The approach taken in this paper has many parts

1. Push the "frame rule" of separation logic into each inference
   rule by making all rules universally quantified over possible
   extensions of the heap.
   
2. Define a small domain-specific separation logic specifically
   for reasoning about cell networks.
   
3. The big problem is that a change in one part of the heap
   can change the interpretation of other parts of the heap.
   To tackle this, they define a "ramification operator" that
   transforms the rest of the heap to match that change in
   interpretation.
   (This operator is specific to cell networks.)
   
This approach is then applied to the task of verifying
an imperative implementation of Functional Reactive
Programming by reasoning about an (inefficient)
pure implementation of causal stream transducers
and an imperative implementation based on cell networks.
   

   
   

   {% include links.html %}


[permission logic]: #notes-permission-logic
[separation logic]: #notes-separation-logic
[frame rule]: #notes-frame-rule
[magic wand]: #notes-magic-wand
# Automated pipeline design {#papers-kroening-dac-2001}


Daniel Kroening, Wolfgang J. Paul
Proceedings of the 38th Design Automation Conference
ACM Press
Pages 810-815
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=Automated%20pipeline%20design)
[[DBLP]](https://dblp.org/search?q=Automated%20pipeline%20design)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automated%20pipeline%20design)
[[doi]](https://doi.org/10.1145/378239.379071)
[[ISBN]](http://books.google.com/books?vid=ISBN1-58113-297-2)

Notes: 
[CPU verification](#CPU verification),
[microarchitecture](#microarchitecture)\



[CPU verification]: #notes-cpu-verification
[microarchitecture]: #notes-microarchitecture
# Proving the correctness of pipelined micro-architectures {#papers-kroening-itg-2000}


Daniel Kroening, Wolfgang J. Paul, Silvia Mueller
Proceedings of ITG/GI/GMM-Workshop ''Methoden und Beschreibungssprachen zur Modellierung und Verifikation von Schaltungen und Systemen''
VDE Verlag
Pages 89-98
2000
[[Google Scholar]](https://scholar.google.com/scholar?q=Proving%20the%20correctness%20of%20pipelined%20micro-architectures)
[[DBLP]](https://dblp.org/search?q=Proving%20the%20correctness%20of%20pipelined%20micro-architectures)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Proving%20the%20correctness%20of%20pipelined%20micro-architectures)
[[ISBN]](http://books.google.com/books?vid=ISBN3-8007-2524-X)

Notes: 
[CPU verification](#CPU verification),
[microarchitecture](#microarchitecture)\



[CPU verification]: #notes-cpu-verification
[microarchitecture]: #notes-microarchitecture
# Information flow control for standard OS abstractions {#papers-krohn-sosp-2007}


Maxwell Krohn, Alexander Yip, Micah Brodsky, Natan Cliffer, M. Frans Kaashoek, Eddie Kohler, Robert Morris
Proceedings of Twenty-first ACM SIGOPS Symposium on Operating Systems Principles
SOSP'07
Stevenson, Washington, USA
ACM
New York, NY, USA
Pages 321-334
2007
[[Google Scholar]](https://scholar.google.com/scholar?q=Information%20flow%20control%20for%20standard%20OS%20abstractions)
[[DBLP]](https://dblp.org/search?q=Information%20flow%20control%20for%20standard%20OS%20abstractions)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Information%20flow%20control%20for%20standard%20OS%20abstractions)
[[doi]](https://doi.org/10.1145/1294261.1294293)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-59593-591-5)

Notes: 
[information flow](#information flow)\
Referenced by: 
[papers/spencer:security:1999](#papers-spencer-security-1999)\




[information flow]: #notes-information-flow
# Automated formal verification of processors based on architectural models {#papers-kuhne-fmcad-2010}


Ulrich Kühne, Sven Beyer, Jörg Bormann, John Barstow
Proceedings of the 2010 Conference on Formal Methods in Computer-Aided Design
FMCAD '10
Lugano, Switzerland
FMCAD Inc
Austin, TX
Pages 129-136
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=Automated%20formal%20verification%20of%20processors%20based%20on%20architectural%20models)
[[DBLP]](https://dblp.org/search?q=Automated%20formal%20verification%20of%20processors%20based%20on%20architectural%20models)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automated%20formal%20verification%20of%20processors%20based%20on%20architectural%20models)

Notes: 
[CPU verification](#CPU verification),
[ISA specification](#ISA specification)\



[CPU verification]: #notes-cpu-verification
[ISA specification]: #notes-isa-specification
# Single-ISA heterogeneous multi-core architectures for multithreaded workload performance {#papers-kumar-isca-2004}


Rakesh Kumar, Dean M. Tullsen, Parthasarathy Ranganathan, Norman P. Jouppi, Keith I. Farkas
Proceedings. 31st Annual International Symposium on Computer Architecture, 2004.
Pages 64-75
June
2004
[[Google Scholar]](https://scholar.google.com/scholar?q=Single-ISA%20heterogeneous%20multi-core%20architectures%20for%20multithreaded%20workload%20performance)
[[DBLP]](https://dblp.org/search?q=Single-ISA%20heterogeneous%20multi-core%20architectures%20for%20multithreaded%20workload%20performance)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Single-ISA%20heterogeneous%20multi-core%20architectures%20for%20multithreaded%20workload%20performance)
[[doi]](https://doi.org/10.1109/ISCA.2004.1310764)

Notes: 
[microarchitecture](#microarchitecture),
[parallelism](#parallelism)\



[microarchitecture]: #notes-microarchitecture
[parallelism]: #notes-parallelism
# CakeML: A verified implementation of ML {#papers-kumar-popl-2014}


Ramana Kumar, Magnus O. Myreen, Michael Norrish, Scott Owens
Principles of Programming Languages (POPL)
ACM
Pages 179-192
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=CakeML%3A%20A%20verified%20implementation%20of%20ML)
[[DBLP]](https://dblp.org/search?q=CakeML%3A%20A%20verified%20implementation%20of%20ML)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=CakeML%3A%20A%20verified%20implementation%20of%20ML)
[[doi]](https://doi.org/10.1145/2535838.2535841)





# Deductive verification of advanced out-of-order microprocessors {#papers-lahiri-cav-2003}


Shuvendu K. Lahiri, Randal E. Bryant
Computer Aided Verification, 15th International Conference, CAV 2003, Boulder, CO, USA, July 8-12, 2003, Proceedings
Pages 341-353
2003
[[Google Scholar]](https://scholar.google.com/scholar?q=Deductive%20verification%20of%20advanced%20out-of-order%20microprocessors)
[[DBLP]](https://dblp.org/search?q=Deductive%20verification%20of%20advanced%20out-of-order%20microprocessors)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Deductive%20verification%20of%20advanced%20out-of-order%20microprocessors)
[[doi]](https://doi.org/10.1007/978-3-540-45069-6_33)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# Experience with term level modeling and verification of the M* CORE microprocessor core {#papers-lahiri-hldvt-2001}


Shuvendu K. Lahiri, Carl Pixley, Kenneth L. Albin
Proceedings of the Sixth IEEE International High-Level Design Validation and Test Workshop 2001, Monterey, California, USA, November 7-9, 2001
Pages 109-114
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=Experience%20with%20term%20level%20modeling%20and%20verification%20of%20the%20M%2A%20CORE%20microprocessor%20core)
[[DBLP]](https://dblp.org/search?q=Experience%20with%20term%20level%20modeling%20and%20verification%20of%20the%20M%2A%20CORE%20microprocessor%20core)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Experience%20with%20term%20level%20modeling%20and%20verification%20of%20the%20M%2A%20CORE%20microprocessor%20core)
[[doi]](https://doi.org/10.1109/HLDVT.2001.972816)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# A solver for reachability modulo theories {#papers-lal-cav-2012}


Akash Lal, Shaz Qadeer, Shuvendu K. Lahiri
Computer Aided Verification
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 427-443
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20solver%20for%20reachability%20modulo%20theories)
[[DBLP]](https://dblp.org/search?q=A%20solver%20for%20reachability%20modulo%20theories)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20solver%20for%20reachability%20modulo%20theories)
[[doi]](https://doi.org/10.1007/978-3-642-31424-7_32)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-31424-7)

Notes: 
[Corral verifier](#Corral verifier),
[bounded verification](#bounded verification)\


This paper describes the Corral tool for finding bugs in device drivers using a variant of bounded model checking.
Like many bounded model checkers, they inline all functions and unroll all loops up to some bound – increasing the bound until some limit or until a bug is found.
What is interesting is that, instead of inlining all functions at once, they incrementally inline functions according to some heuristics.
They also use a CEGAR-like mechanism to control variable abstraction.

What I like about this paper is the discussion of several heuristics, improvements, tricks, etc.  that they use to get performance.  For example, when searching for the minimal number of variables in the abstraction, they could generate N different verification conditions VC and try each one.  Instead, they generate a single VC with additional Boolean variables to enable/disable use of each variable.  They then invoke the SMT solver N times on a single VC - potentially benefiting from anything that the solver learns that applies across multiple solutions efforts.





[Corral verifier]: #notes-corral-verifier
[bounded verification]: #notes-bounded-verification
# Powering the static driver verifier using Corral {#papers-lal-fse-2014}


Akash Lal, Shaz Qadeer
Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering
ACM
Pages 202-212
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=Powering%20the%20static%20driver%20verifier%20using%20Corral)
[[DBLP]](https://dblp.org/search?q=Powering%20the%20static%20driver%20verifier%20using%20Corral)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Powering%20the%20static%20driver%20verifier%20using%20Corral)
[[doi]](https://doi.org/10.1145/2635868.2635894)

Notes: 
[Corral verifier](#Corral verifier)\
Referenced by: 
[papers/baranowski:atva:2018](#papers-baranowski-atva-2018)\




[Corral verifier]: #notes-corral-verifier
# DAG inlining: A decision procedure for reachability-modulo-theories in hierarchical programs {#papers-lal-pldi-2015}


Akash Lal, Shaz Qadeer
Programming Language Design and Implementation (PLDI)
ACM
New York, NY, USA
Pages 280-290
June
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=DAG%20inlining%3A%20A%20decision%20procedure%20for%20reachability-modulo-theories%20in%20hierarchical%20programs)
[[DBLP]](https://dblp.org/search?q=DAG%20inlining%3A%20A%20decision%20procedure%20for%20reachability-modulo-theories%20in%20hierarchical%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=DAG%20inlining%3A%20A%20decision%20procedure%20for%20reachability-modulo-theories%20in%20hierarchical%20programs)
[[doi]](https://doi.org/10.1145/2813885.2737987)

Notes: 
[model checking](#model checking),
[SMT solver](#SMT solver)\



[model checking]: #notes-model-checking
[SMT solver]: #notes-smt-solver
# On the duality of operating system structures {#papers-lauer-osr-1979}


Hugh C. Lauer, Roger M. Needham
ACM
New York, NY, USA
Pages 3-19
April
1979
[[Google Scholar]](https://scholar.google.com/scholar?q=On%20the%20duality%20of%20operating%20system%20structures)
[[DBLP]](https://dblp.org/search?q=On%20the%20duality%20of%20operating%20system%20structures)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=On%20the%20duality%20of%20operating%20system%20structures)
[[doi]](https://doi.org/10.1145/850657.850658)

Notes: 
[operating systems](#operating systems),
[continuations](#continuations),
[threads](#threads)\
Referenced by: 
[notes/continuations](#notes-continuations),
[notes/threads](#notes-threads)\



[operating systems]: #notes-operating-systems
[continuations]: #notes-continuations
[threads]: #notes-threads
# Subword parallelism with MAX-2 {#papers-lee-micro-1996}


Ruby B. Lee
IEEE Computer Society Press
Los Alamitos, CA, USA
Pages 51-59
August
1996
[[Google Scholar]](https://scholar.google.com/scholar?q=Subword%20parallelism%20with%20MAX-2)
[[DBLP]](https://dblp.org/search?q=Subword%20parallelism%20with%20MAX-2)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Subword%20parallelism%20with%20MAX-2)
[[doi]](https://doi.org/10.1109/40.526925)

Notes: 
[vector architecture](#vector architecture),
[instruction set architecture](#instruction set architecture),
[SIMD](#SIMD)\



[vector architecture]: #notes-vector-architecture
[instruction set architecture]: #notes-instruction-set-architecture
[SIMD]: #notes-simd
# The Boogie verification debugger {#papers-legoues-sefm-2011}


Claire Le Goues, K. Rustan M. Leino, Michał Moskal
Software Engineering and Formal Methods
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 407-414
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20Boogie%20verification%20debugger)
[[DBLP]](https://dblp.org/search?q=The%20Boogie%20verification%20debugger)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20Boogie%20verification%20debugger)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-24690-6)

Notes: 
[Boogie verifier](#Boogie verifier),
[Dafny verifier](#Dafny verifier),
[VCC verifier](#VCC verifier)\
Papers: 
[barnett:fmco:2005](#barnett-fmco-2005),
[leino:lpair:2010](#leino-lpair-2010),
[cohen:cav:2010](#cohen-cav-2010),
[barnett:cacm:2011](#barnett-cacm-2011),
[jacobs:nfm:2011](#jacobs-nfm-2011)\
Referenced by: 
[notes/intermediate-verification-language](#notes-intermediate-verification-language)\


A critical part of any verification tool is a debugger that helps you understand and localise any errors detected.
For dynamic verification (i.e., testing), we typically use a debugger like gdb/lldb to halt the program at interesting points and inspect the state of the system.
For static verification (i.e., formal verification), it initially seems quite different because the verification tool typically does not run the program from the beginning and does not generate concrete values for all variables.
I think the message of this paper is that it is not as hard as it seems.

The ingredients of their solution are:
- The language specific part of the verifier generates canonical names for heap objects. e.g., for nodes of type T, it might call them T'0, T'1, etc.
- Allowing you to step through the code and showing values accessible in either the previous state or the next state as you step.  (I guess conventional dynamic debuggers do this too?)
- Supporting search for aliases (other pointers to the same location)
- Breadth first conversion of SMT solver states to source-language states
- <something> for Skolem constants
- A standard plugin interface to the language front end.  For VCC, this is 1000 lines, for Dafny, it is 400 lines.

As the title implies, this is implemented in
[Boogie][barnett:fmco:2005]
and they have implemented the frontend support for both
[Dafny][leino:lpair:2010]
and
[VCC][cohen:cav:2010].

The paper has a useful list of other work in
ESC/Modula-3,
ESC/Java,
[VCC][cohen:cav:2010],
[Spec#][barnett:cacm:2011],
[VeriFast][jacobs:nfm:2011]
and
CBMC.
This topic is not discussed often so it is super-useful to find a list of what little has been reported.




[Boogie verifier]: #notes-boogie-verifier
[Dafny verifier]: #notes-dafny-verifier
[VCC verifier]: #notes-vcc-verifier
[barnett:fmco:2005]: #papers-barnett-fmco-2005
[leino:lpair:2010]: #papers-leino-lpair-2010
[cohen:cav:2010]: #papers-cohen-cav-2010
[barnett:cacm:2011]: #papers-barnett-cacm-2011
[jacobs:nfm:2011]: #papers-jacobs-nfm-2011
# Verifying the Microsoft Hyper-V hypervisor with VCC {#papers-leinenbach-fm-2009}


Dirk Leinenbach, Thomas Santen
International Symposium on Formal Methods
Springer
Pages 806-809
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Verifying%20the%20Microsoft%20Hyper-V%20hypervisor%20with%20VCC)
[[DBLP]](https://dblp.org/search?q=Verifying%20the%20Microsoft%20Hyper-V%20hypervisor%20with%20VCC)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Verifying%20the%20Microsoft%20Hyper-V%20hypervisor%20with%20VCC)
[[doi]](https://doi.org/10.1007/978-3-642-05089-3_51)

Notes: 
[information flow](#information flow),
[VCC verifier](#VCC verifier)\
Referenced by: 
[papers/barnett:fmco:2005](#papers-barnett-fmco-2005)\


This short (3.5 page) paper gives a brief overview of Hyper-V verification.  Hyper-V is a high performance commercial hypervisor not written with verification in mind.  It is 100kloc of C plus 5kloc x86-64 assembly, uses lock free data structures, simulates 2-stage page translation.  Verification makes heavy use of “two-state invariants” and “claims”.
Useful as an overview but need to read other papers to get any detail.



[information flow]: #notes-information-flow
[VCC verifier]: #notes-vcc-verifier
# Verification of concurrent programs with Chalice {#papers-leino-fosad-2007}


K. Rustan M. Leino, Peter Müller, Jan Smans
Foundations of Security Analysis and Design V: FOSAD 2007/2008/2009 Tutorial Lectures
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 195-222
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Verification%20of%20concurrent%20programs%20with%20Chalice)
[[DBLP]](https://dblp.org/search?q=Verification%20of%20concurrent%20programs%20with%20Chalice)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Verification%20of%20concurrent%20programs%20with%20Chalice)
[[doi]](https://doi.org/10.1007/978-3-642-03829-7_7)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-03829-7)
[[url]](https://doi.org/10.1007/978-3-642-03829-7_7)

Notes: 
[permission logic](#permission logic),
[modular verification](#modular verification),
[contract driven development](#contract driven development),
[fractional permissions](#fractional permissions),
[permission accounting](#permission accounting),
[Chalice verifier](#Chalice verifier),
[ghost code](#ghost code)\
Referenced by: 
[papers/muller:vmcai:2016](#papers-muller-vmcai-2016)\


This is a tutorial on the Chalice object-oriented language and verifier.
Methods have contracts, loops have invariants,
pointers have ownership annotations,
there are threads, locks and fractional ownership,
there are lock orderings to detect deadlock
and there are ghost variables and fold/unfold ghost statements.

The language seems to have had more attention paid
to usability than normal.

- For example, fractional permissions get the job done – but
  they are a slightly obscure way to say that something is "read only"
  so Chalice has notation to say that something is read only.

- There are command line options to reduce the amount of
  annotation required:

  - unfolding and folding predicates at the start/end of each method

  - automatically trying to fold when a predicate is required

The conclusions section is great: it explains the influences,
where ideas came from, who did what and where the reader might
find more about the concepts in this language/tool.



[permission logic]: #notes-permission-logic
[modular verification]: #notes-modular-verification
[contract driven development]: #notes-contract-driven-development
[fractional permissions]: #notes-fractional-permissions
[permission accounting]: #notes-permission-accounting
[Chalice verifier]: #notes-chalice-verifier
[ghost code]: #notes-ghost-code
# Developing verified programs with Dafny {#papers-leino-icse-2013}


K. Rustan M. Leino
2013 35th International Conference on Software Engineering (ICSE)
Pages 1488-1490
May
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Developing%20verified%20programs%20with%20Dafny)
[[DBLP]](https://dblp.org/search?q=Developing%20verified%20programs%20with%20Dafny)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Developing%20verified%20programs%20with%20Dafny)
[[doi]](https://doi.org/10.1109/ICSE.2013.6606754)

Notes: 
[auto-active verification](#auto-active verification),
[Boogie verifier](#Boogie verifier),
[Dafny verifier](#Dafny verifier),
[ghost code](#ghost code),
[Z3 solver](#Z3 solver),
[SMT solver](#SMT solver)\
Papers: 
[leino:lpair:2010](#leino-lpair-2010)\
Referenced by: 
[notes/dafny-verifier](#notes-dafny-verifier)\


[Dafny][leino:lpair:2010]
is both a language and a verification tool for creating verified
programs.
The language has features of object-oriented languages and functional
languages.
The verification support is based on contract-style verification.
This short, easy read seems to be the accompaniment for a tutorial
and discusses verification of six different functions that
demonstrates contracts and the specification notation,
loop invariants, immutable inductive datatypes, mutable datatypes,
use of pure functions in specifications, classes, ghost-fields,
invariants, and lemmas.
Proofs of lemmas are especially interesting because the lemmas
are just ghost methods and the body of those methods are
the proofs of the lemmas. e.g., to write an inductive proof,
one writes a recursive function using a case split to separate
the base case from the inductive step.



[auto-active verification]: #notes-auto-active-verification
[Boogie verifier]: #notes-boogie-verifier
[Dafny verifier]: #notes-dafny-verifier
[ghost code]: #notes-ghost-code
[Z3 solver]: #notes-z3-solver
[SMT solver]: #notes-smt-solver
[leino:lpair:2010]: #papers-leino-lpair-2010
# Extended static checking: A ten-year perspective {#papers-leino-informatics-2001}


K. Rustan M. Leino
Informatics: 10 Years Back, 10 Years Ahead
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 157-175
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=Extended%20static%20checking%3A%20A%20ten-year%20perspective)
[[DBLP]](https://dblp.org/search?q=Extended%20static%20checking%3A%20A%20ten-year%20perspective)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Extended%20static%20checking%3A%20A%20ten-year%20perspective)
[[doi]](https://doi.org/10.1007/3-540-44577-3_11)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-44577-7)
[[url]](https://doi.org/10.1007/3-540-44577-3_11)

Notes: 
[extended static checking](#extended static checking),
[decidability ceiling](#decidability ceiling),
[auto-active verification](#auto-active verification),
[SMT lib format](#SMT lib format),
[annotation burden](#annotation burden)\
Papers: 
[cohen:cav:2010](#cohen-cav-2010)\


Super-interesting background and explanation of the choices made in ESC/Modula-3
and ESC/Java.
Both a form of [auto-active verifier][auto-active verification] (although that
term was not used by the author for another 10 years.

Some key themes in the paper are

- the [decidability ceiling]: the boundary between analyses that consistently
  run in reasonable time and those that are more powerful but may not be
  decidable.

- allowing 'unsoundness in just the right places' to 'achieve a better position
  in the coverage-to-effort design space'.
  This is necessary because not all analyses are decidable so you either need
  to add a lot of annotations (taking programmer effort) or accept that
  a little unsoundness (by not trying to detect certain classes of bugs).

- Exploiting / imposing programming methodology such as requiring function
  contracts, etc., restricting the language to avoid poorly defined parts of
  the language.

- The need for an escape hatch to suppress static checking (again, driven by
  decidability).

Although the paper is mostly about technical details, it does sketch how
counterexamples from the SMT solver were used to generate error messages.
This is done by labelling subexpressions so that they can be related back
to parts of the original program.
(It's not clear but it's possible that the :named feature in [SMT lib format]
is the modern version of this.)
The paper says that they are not always successful at producing useful error
messages.

In Modula-3 and Java, they took different approaches to capturing object
invariants: using a convention in Modula-3 and building in direct support in
Java.
(IIRC, [cohen:cav:2010] used the convention approach as well.)

The [annotation burden] seems to be small –around 10%– but the startup cost is
high because one must add annotations to legacy code before getting much value
back and this, together with a need for training and the risk of a new
technology, limited adoption by people outside the projects.

Modular checking was a particular problem for Java – presumably because new
subclasses are easily added.
Another problem was aliasing and checking the 'modifies' clause.



[extended static checking]: #notes-extended-static-checking
[decidability ceiling]: #notes-decidability-ceiling
[auto-active verification]: #notes-auto-active-verification
[SMT lib format]: #notes-smt-lib-format
[annotation burden]: #notes-annotation-burden
[cohen:cav:2010]: #papers-cohen-cav-2010
# Dafny: An automatic program verifier for functional correctness {#papers-leino-lpair-2010}


K. Rustan M. Leino
International Conference on Logic for Programming Artificial Intelligence and Reasoning
Springer
Pages 348-370
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=Dafny%3A%20An%20automatic%20program%20verifier%20for%20functional%20correctness)
[[DBLP]](https://dblp.org/search?q=Dafny%3A%20An%20automatic%20program%20verifier%20for%20functional%20correctness)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Dafny%3A%20An%20automatic%20program%20verifier%20for%20functional%20correctness)
[[doi]](https://doi.org/10.1007/978-3-642-17511-4_20)

Notes: 
[auto-active verification](#auto-active verification),
[Boogie verifier](#Boogie verifier),
[Dafny verifier](#Dafny verifier),
[Z3 solver](#Z3 solver),
[SMT solver](#SMT solver)\
Papers: 
[leino:tacas:2010](#leino-tacas-2010),
[demoura:tacas:2008](#demoura-tacas-2008),
[tuerk:vstte:2010](#tuerk-vstte-2010),
[barnett:fmco:2005](#barnett-fmco-2005)\
Referenced by: 
[papers/ferraiuolo:sosp:2017](#papers-ferraiuolo-sosp-2017),
[papers/legoues:sefm:2011](#papers-legoues-sefm-2011),
[papers/leino:icse:2013](#papers-leino-icse-2013),
[papers/mai:asplos:2013](#papers-mai-asplos-2013)\


Dafny is an [auto-active program verifier][auto-active verification]
for an imperative
language with functional and object oriented features
that uses
the 
[Boogie][leino:tacas:2010]
intermediate verification language
and the
[Z3][demoura:tacas:2008]
SMT solver
for automated proof.

This is one of the early papers about Dafny: before it could
actually execute the code it verifies.
(I am reminded of the Donald Knuth comment about a function that
it had been verified but not actually executed.)
It also describes 
the origins of Dafny as an exploration of dynamic frames
and some of the development of features driven
by features of the code they wanted to verify.

The main body of the paper is a description of the language
feature and how it is converted to Boogie – with some of the
author's characteristic asides about how the choices impact
verification and where the ideas were first explored.
(I really like this feature of Leino's papers.)

The big result in the paper is a verified version of
the Schorr-Waite algorithm in just 117 lines of
code, proof and comment.  Wow!
Also a nice summary of the development process.
The only thing not to like about this is the 19
loop invariants required.
(I wonder whether [loop specifications in the style of Tuerk][tuerk:vstte:2010]
would help at all?)
Also, the author admits that "deciphering the verifier's
error messages" is hard.
I wonder how much that improved in later versions
or with the development of the
[Boogie Verification Debugger][barnett:fmco:2005]?



[auto-active verification]: #notes-auto-active-verification
[Boogie verifier]: #notes-boogie-verifier
[Dafny verifier]: #notes-dafny-verifier
[Z3 solver]: #notes-z3-solver
[SMT solver]: #notes-smt-solver
[leino:tacas:2010]: #papers-leino-tacas-2010
[demoura:tacas:2008]: #papers-demoura-tacas-2008
[tuerk:vstte:2010]: #papers-tuerk-vstte-2010
[barnett:fmco:2005]: #papers-barnett-fmco-2005
# Reasoning about comprehensions with first-order SMT solvers {#papers-leino-sac-2009}


K. Rustan M. Leino, Rosemary Monahan
Proceedings of the 2009 ACM Symposium on Applied Computing
SAC '09
Honolulu, Hawaii
Association for Computing Machinery
New York, NY, USA
Pages 615-622
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Reasoning%20about%20comprehensions%20with%20first-order%20SMT%20solvers)
[[DBLP]](https://dblp.org/search?q=Reasoning%20about%20comprehensions%20with%20first-order%20SMT%20solvers)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Reasoning%20about%20comprehensions%20with%20first-order%20SMT%20solvers)
[[doi]](https://doi.org/10.1145/1529282.1529411)
[[ISBN]](http://books.google.com/books?vid=ISBN9781605581668)
[[url]](https://doi.org/10.1145/1529282.1529411)

Notes: 
[spec-sharp-project](#spec-sharp-project),
[SMT solver](#SMT solver)\




[spec-sharp-project]: #notes-spec-sharp-project
[SMT solver]: #notes-smt-solver
# A polymorphic intermediate verification language: Design and logical encoding {#papers-leino-tacas-2010}


K. Rustan M. Leino, Philipp Rümmer
Tools and Algorithms for the Construction and Analysis of Systems
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 312-327
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20polymorphic%20intermediate%20verification%20language%3A%20Design%20and%20logical%20encoding)
[[DBLP]](https://dblp.org/search?q=A%20polymorphic%20intermediate%20verification%20language%3A%20Design%20and%20logical%20encoding)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20polymorphic%20intermediate%20verification%20language%3A%20Design%20and%20logical%20encoding)
[[doi]](https://doi.org/10.1007/978-3-642-12002-2_26)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-12002-2)

Notes: 
[intermediate verification language](#intermediate verification language),
[Boogie verifier](#Boogie verifier)\
Referenced by: 
[papers/barnett:cacm:2011](#papers-barnett-cacm-2011),
[papers/leino:lpair:2010](#papers-leino-lpair-2010)\




[intermediate verification language]: #notes-intermediate-verification-language
[Boogie verifier]: #notes-boogie-verifier
# Formal verification of a realistic compiler {#papers-leroy-cacm-2009}


Xavier Leroy
Pages 107-115
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Formal%20verification%20of%20a%20realistic%20compiler)
[[DBLP]](https://dblp.org/search?q=Formal%20verification%20of%20a%20realistic%20compiler)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Formal%20verification%20of%20a%20realistic%20compiler)
[[doi]](https://doi.org/10.1145/1538788.1538814)

Notes: 
[translation validation](#translation validation),
[Coq theorem prover](#Coq theorem prover),
[CompCert compiler](#CompCert compiler)\
Referenced by: 
[notes/annotation-burden](#notes-annotation-burden),
[notes/compcert-compiler](#notes-compcert-compiler)\




[translation validation]: #notes-translation-validation
[Coq theorem prover]: #notes-coq-theorem-prover
[CompCert compiler]: #notes-compcert-compiler
# The case for writing a kernel in Rust {#papers-levy-apsys-2017}


Amit Levy, Bradford Campbell, Branden Ghena, Pat Pannuto, Prabal Dutta, Philip Levis
Proceedings of the 8th Asia-Pacific Workshop on Systems
APSys'17
Mumbai, India
Association for Computing Machinery
New York, NY, USA
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20case%20for%20writing%20a%20kernel%20in%20Rust)
[[DBLP]](https://dblp.org/search?q=The%20case%20for%20writing%20a%20kernel%20in%20Rust)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20case%20for%20writing%20a%20kernel%20in%20Rust)
[[doi]](https://doi.org/10.1145/3124680.3124717)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450351973)
[[url]](https://doi.org/10.1145/3124680.3124717)

Notes: 
[Rust language](#Rust language)\
Referenced by: 
[notes/rust-language](#notes-rust-language)\


The Rust language is increasingly being proposed as a safe
replacement for C in systems programming.
This paper (by the authors of TockOS) explores some of the
key challenges in doing so.
In particular, they are interested in how they can write
low-level code without having to weaken Rust's
safety story by using the "unsafe" feature of Rust.

The introduction talks about very minimal OSes that
rely heavily on the language guarantees as part of
the security story.
(While they talk about Spin and Singularity, I was
surprised that they did not talk about Java OSes
which were briefly popular in the late '90s.)

One of the challenges in using Rust to write an OS is that
objects have to be shared by multiple parts of the system.
They don't use the terminology but I think they mean
"top half" and "bottom half" code and, of course
device accesses.
Rust provides the "Cell" wrapper that can be used to share
mutable scalar values in a safe way.
They extend this with the "TakeCell" wrapper that provides
for atomic updates of non-scalar values (in particular, references to objects).
TakeCell uses a nice trick for this of specifying the atomic
operation to be performed using a closure (that the Rust
compiler supports as a zero-cost abstraction). 
TakeCell does not appear to be interrupt-safe or MP-safe (MP
support is future work).

The paper then discusses three challenges in building a kernel:

- DMA access.
  The challenge they discuss is that the DMA engine shares
  a buffer with the software world and so the ownership
  and lifetime of the buffer is a concern.

- USB.
  This is an example of interacting with a complex hardware
  device that requires particular memory layouts,
  has particular control requirements, etc.
  
- Doubly linked lists and other complex data structures.
  The aliasing caused by doubly linked lists is a well
  known challenge for Rust's typesystem.
  They use what I suspect is a standard trick for
  sneaking these past Rust's typesystem.
  It is not clear to me whether this merely suppresses
  Rust's warnings or is able to preserve useful safety
  guarantees.
  
  

  {% include links.html %}


[Rust language]: #notes-rust-language
# Ownership is theft: Experiences building an embedded OS in Rust {#papers-levy-plos-2015}


Amit Levy, Michael P. Andersen, Bradford Campbell, David Culler, Prabal Dutta, Branden Ghena, Philip Levis, Pat Pannuto
Proceedings of the 8th Workshop on Programming Languages and Operating Systems
PLOS '15
Monterey, California
Association for Computing Machinery
New York, NY, USA
Pages 21-26
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=Ownership%20is%20theft%3A%20Experiences%20building%20an%20embedded%20OS%20in%20Rust)
[[DBLP]](https://dblp.org/search?q=Ownership%20is%20theft%3A%20Experiences%20building%20an%20embedded%20OS%20in%20Rust)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Ownership%20is%20theft%3A%20Experiences%20building%20an%20embedded%20OS%20in%20Rust)
[[doi]](https://doi.org/10.1145/2818302.2818306)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450339421)
[[url]](https://doi.org/10.1145/2818302.2818306)

Notes: 
[Rust language](#Rust language),
[ownership types](#ownership types)\




[Rust language]: #notes-rust-language
[ownership types]: #notes-ownership-types
# Multiprogramming a 64kB computer safely and efficiently {#papers-levy-sosp-2017}


Amit Levy, Bradford Campbell, Branden Ghena, Daniel B. Giffin, Pat Pannuto, Prabal Dutta, Philip Levis
Proceedings of the 26th Symposium on Operating Systems Principles
SOSP '17
Shanghai, China
Association for Computing Machinery
New York, NY, USA
Pages 234-251
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=Multiprogramming%20a%2064kB%20computer%20safely%20and%20efficiently)
[[DBLP]](https://dblp.org/search?q=Multiprogramming%20a%2064kB%20computer%20safely%20and%20efficiently)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Multiprogramming%20a%2064kB%20computer%20safely%20and%20efficiently)
[[doi]](https://doi.org/10.1145/3132747.3132786)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450350853)
[[url]](https://doi.org/10.1145/3132747.3132786)

Notes: 
[Rust language](#Rust language)\




[Rust language]: #notes-rust-language
# Memory coherence in shared virtual memory systems {#papers-li-tocs-1989}


Kai Li, Paul Hudak
ACM
New York, NY, USA
Pages 321-359
November
1989
[[Google Scholar]](https://scholar.google.com/scholar?q=Memory%20coherence%20in%20shared%20virtual%20memory%20systems)
[[DBLP]](https://dblp.org/search?q=Memory%20coherence%20in%20shared%20virtual%20memory%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Memory%20coherence%20in%20shared%20virtual%20memory%20systems)
[[doi]](https://doi.org/10.1145/75104.75105)

Notes: 
[memory coherence](#memory coherence),
[weak memory](#weak memory),
[distributed shared memory](#distributed shared memory)\
Referenced by: 
[notes/distributed-shared-memory](#notes-distributed-shared-memory),
[notes/memory-coherence](#notes-memory-coherence)\



[memory coherence]: #notes-memory-coherence
[weak memory]: #notes-weak-memory
[distributed shared memory]: #notes-distributed-shared-memory
# Specifying and verifying hardware for tamper-resistant software {#papers-lie-secpri-2003}


David Lie, John C. Mitchell, Chandramohan A. Thekkath, Mark Horowitz
2003 Symposium on Security and Privacy, 2003.
Pages 166-177
May
2003
[[Google Scholar]](https://scholar.google.com/scholar?q=Specifying%20and%20verifying%20hardware%20for%20tamper-resistant%20software)
[[DBLP]](https://dblp.org/search?q=Specifying%20and%20verifying%20hardware%20for%20tamper-resistant%20software)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Specifying%20and%20verifying%20hardware%20for%20tamper-resistant%20software)
[[doi]](https://doi.org/10.1109/SECPRI.2003.1199335)





# Implementing an untrusted operating system on trusted hardware {#papers-lie-sosp-2003}


David Lie, Chandramohan A. Thekkath, Mark Horowitz
Proceedings of the Nineteenth ACM Symposium on Operating Systems Principles
SOSP'03
Bolton Landing, NY, USA
ACM
New York, NY, USA
Pages 178-192
2003
[[Google Scholar]](https://scholar.google.com/scholar?q=Implementing%20an%20untrusted%20operating%20system%20on%20trusted%20hardware)
[[DBLP]](https://dblp.org/search?q=Implementing%20an%20untrusted%20operating%20system%20on%20trusted%20hardware)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Implementing%20an%20untrusted%20operating%20system%20on%20trusted%20hardware)
[[doi]](https://doi.org/10.1145/945445.945463)
[[ISBN]](http://books.google.com/books?vid=ISBN1-58113-757-5)





# SPEX: A programming language for software defined radio {#papers-lin-sdr-2006}


Yuan Lin, Robert Mullenix, Mark Woh, Scott A. Mahlke, Trevor N. Mudge, Alastair D. Reid, Krisztián Flautner
Software Defined Radio Technical Conference and Product Exposition
Orlando, FL, USA
13-17
November
2006
[[Google Scholar]](https://scholar.google.com/scholar?q=SPEX%3A%20A%20programming%20language%20for%20software%20defined%20radio)
[[DBLP]](https://dblp.org/search?q=SPEX%3A%20A%20programming%20language%20for%20software%20defined%20radio)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=SPEX%3A%20A%20programming%20language%20for%20software%20defined%20radio)

Notes: 
[SIMD](#SIMD),
[Vector architecture](#Vector architecture),
[VLIW](#VLIW),
[SDR](#SDR)\
Papers: 
[reid:cases:2008](#reid-cases-2008)\




[SIMD]: #notes-simd
[Vector architecture]: #notes-vector-architecture
[VLIW]: #notes-vliw
[SDR]: #notes-sdr
[reid:cases:2008]: #papers-reid-cases-2008
# Design and implementation of turbo decoders for software defined radio {#papers-lin-sips-2006}


Yuan Lin, Scott A. Mahlke, Trevor N. Mudge, Chaitali Chakrabarti, Alastair D. Reid, Krisztián Flautner
Proceedings of the IEEE Workshop on Signal Processing Systems (SiPS 2006)
Banff, Alberta, Canada
IEEE
Pages 22-27
2-4
October
2006
[[Google Scholar]](https://scholar.google.com/scholar?q=Design%20and%20implementation%20of%20turbo%20decoders%20for%20software%20defined%20radio)
[[DBLP]](https://dblp.org/search?q=Design%20and%20implementation%20of%20turbo%20decoders%20for%20software%20defined%20radio)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Design%20and%20implementation%20of%20turbo%20decoders%20for%20software%20defined%20radio)
[[doi]](https://doi.org/10.1109/SIPS.2006.352549)

Notes: 
[vector architecture](#vector architecture),
[SIMD](#SIMD),
[VLIW](#VLIW),
[SDR](#SDR)\
Papers: 
[reid:cases:2008](#reid-cases-2008)\




[vector architecture]: #notes-vector-architecture
[SIMD]: #notes-simd
[VLIW]: #notes-vliw
[SDR]: #notes-sdr
[reid:cases:2008]: #papers-reid-cases-2008
# No panic! Verification of Rust programs by symbolic execution {#papers-lindner-indin-2018}


Marcus Lindner, Jorge Aparicius, Per Lindgren
2018 IEEE 16th International Conference on Industrial Informatics (INDIN)
Pages 108-114
July
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=No%20panic%21%20Verification%20of%20Rust%20programs%20by%20symbolic%20execution)
[[DBLP]](https://dblp.org/search?q=No%20panic%21%20Verification%20of%20Rust%20programs%20by%20symbolic%20execution)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=No%20panic%21%20Verification%20of%20Rust%20programs%20by%20symbolic%20execution)
[[doi]](https://doi.org/10.1109/INDIN.2018.8471992)

Notes: 
[Rust language](#Rust language),
[symbolic execution](#symbolic execution),
[extended static checking](#extended static checking),
[contract driven development](#contract driven development),
[modular verification](#modular verification),
[KLEE verifier](#KLEE verifier)\
Papers: 
[lindner:indin:2019](#lindner-indin-2019)\
Referenced by: 
[papers/lindner:indin:2019](#papers-lindner-indin-2019),
[notes/klee-verifier](#notes-klee-verifier)\


This paper describes the `cargo-Rust` that allows the [KLEE verifier]
to be used to verify Rust programs.
KLEE is a [symbolic execution] tool so using it to verify code leads
to a path explosion problem.
The solution taken in this paper is to use a [contract driven development]
approach to enable [modular verification].
This reduces the path explosion problem to only involve the number of
paths per function instead of the number of paths through the entire
program.

Two related approaches that are mentioned are the
[KLEE Rust crate]
and the
[Symbolic Execution Engine for Rust (SEER)][SEER].

[KLEE Rust crate]: https://github.com/jawline/klee-rust
[SEER]: https://github.com/dwrensha/seer



[Rust language]: #notes-rust-language
[symbolic execution]: #notes-symbolic-execution
[extended static checking]: #notes-extended-static-checking
[contract driven development]: #notes-contract-driven-development
[modular verification]: #notes-modular-verification
[KLEE verifier]: #notes-klee-verifier
[lindner:indin:2019]: #papers-lindner-indin-2019
# Verification of safety functions implemented in Rust: A symbolic execution based approach {#papers-lindner-indin-2019}


Marcus Lindner, Nils Fitinghoff, Johan Eriksson, Per Lindgren
Proceedings : 2019 IEEE 17th International Conference on Industrial Informatics (INDIN)
IEEE International Conference on Industrial Informatics (INDIN)
Luleå University of Technology, Computer Science
Pages 432-439
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Verification%20of%20safety%20functions%20implemented%20in%20Rust%3A%20A%20symbolic%20execution%20based%20approach)
[[DBLP]](https://dblp.org/search?q=Verification%20of%20safety%20functions%20implemented%20in%20Rust%3A%20A%20symbolic%20execution%20based%20approach)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Verification%20of%20safety%20functions%20implemented%20in%20Rust%3A%20A%20symbolic%20execution%20based%20approach)
[[doi]](https://doi.org/10.1109/INDIN41052.2019.8972014)

Notes: 
[Rust language](#Rust language),
[symbolic execution](#symbolic execution),
[extended static checking](#extended static checking),
[KLEE verifier](#KLEE verifier)\
Papers: 
[lindner:indin:2018](#lindner-indin-2018)\
Referenced by: 
[papers/lindner:indin:2018](#papers-lindner-indin-2018),
[notes/klee-verifier](#notes-klee-verifier)\


This paper looks at how to use the [KLEE verifier] to verify
code implementing a state machine written in Rust
based on their earlier work ([lindner:indin:2018]).
The challenge here is that KLEE is a [symbolic execution]
tool and does not guarantee to explore all paths through
the code to a sufficient depth to guarantee soundness.
Their solution lies in constructing an appropriate
verification harness.



[Rust language]: #notes-rust-language
[symbolic execution]: #notes-symbolic-execution
[extended static checking]: #notes-extended-static-checking
[KLEE verifier]: #notes-klee-verifier
[lindner:indin:2018]: #papers-lindner-indin-2018
# Meltdown {#papers-lipp-arxiv-2018}


Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas, Stefan Mangard, Paul Kocher, Daniel Genkin, Yuval Yarom, Mike Hamburg
January
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=Meltdown)
[[DBLP]](https://dblp.org/search?q=Meltdown)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Meltdown)
[[arXiv]](https://arxiv.org/1801.01207)

Notes: 
[side channel](#side channel)\



[side channel]: #notes-side-channel
# Secure autonomous cyber-physical systems through verifiable information flow control {#papers-liu-cpsspc-2018}


Jed Liu, Joe Corbett-Davies, Andrew Ferraiuolo, Alexander Ivanov, Mulong Luo, G. Edward Suh, Andrew C. Myers, Mark Campbell
Proceedings of the 2018 Workshop on Cyber-Physical Systems Security and Privacy,
CPS-SPC '18
ACM
Pages 48-59
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=Secure%20autonomous%20cyber-physical%20systems%20through%20verifiable%20information%20flow%20control)
[[DBLP]](https://dblp.org/search?q=Secure%20autonomous%20cyber-physical%20systems%20through%20verifiable%20information%20flow%20control)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Secure%20autonomous%20cyber-physical%20systems%20through%20verifiable%20information%20flow%20control)
[[doi]](https://doi.org/10.1145/3264888.3264889)

Notes: 
[information flow](#information flow)\


This paper ties together several different threads to create a CPS system (autonomous vehicle) that is resistant to many forms of attack.
Builds on Jif (Java with security labels), SecVerilog (HDL with security labels), Hyperflow (processor with security labels) and statistical detection of attack based on sensor fusion (sensors plus map data).
The Hyperflow processor is not used in the experiment at this stage because they need to port Java/Jif to that architecture.
Statistics try to distinguish noise (Gaussian) from attack (uniform) — not clear to me that this is sufficiently robust.




[information flow]: #notes-information-flow
# Pydgin: generating fast instruction set simulators from simple architecture descriptions with meta-tracing JIT compilers {#papers-lockhart-ispass-2015}


Derek Lockhart, Berkin Ilbeyi, Christopher Batten
2015 IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS)
Pages 256-267
March
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=Pydgin%3A%20generating%20fast%20instruction%20set%20simulators%20from%20simple%20architecture%20descriptions%20with%20meta-tracing%20JIT%20compilers)
[[DBLP]](https://dblp.org/search?q=Pydgin%3A%20generating%20fast%20instruction%20set%20simulators%20from%20simple%20architecture%20descriptions%20with%20meta-tracing%20JIT%20compilers)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Pydgin%3A%20generating%20fast%20instruction%20set%20simulators%20from%20simple%20architecture%20descriptions%20with%20meta-tracing%20JIT%20compilers)
[[doi]](https://doi.org/10.1109/ISPASS.2015.7095811)

Notes: 
[Arm architecture](#Arm architecture),
[RISCV architecture](#RISCV architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture)\




[Arm architecture]: #notes-arm-architecture
[RISCV architecture]: #notes-riscv-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
# Practical verification for the working programmer with CodeContracts and abstract interpretation {#papers-logozzo-vmcai-2011}


Francesco Logozzo
International Workshop on Verification, Model Checking, and Abstract Interpretation
Springer
Pages 19-22
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=Practical%20verification%20for%20the%20working%20programmer%20with%20CodeContracts%20and%20abstract%20interpretation)
[[DBLP]](https://dblp.org/search?q=Practical%20verification%20for%20the%20working%20programmer%20with%20CodeContracts%20and%20abstract%20interpretation)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Practical%20verification%20for%20the%20working%20programmer%20with%20CodeContracts%20and%20abstract%20interpretation)
[[doi]](https://doi.org/10.1007/978-3-642-18275-4_3)

Notes: 
[contract driven development](#contract driven development)\
Referenced by: 
[papers/barnett:cacm:2011](#papers-barnett-cacm-2011),
[notes/contract-driven-development](#notes-contract-driven-development)\




[contract driven development]: #notes-contract-driven-development
# Verified compilation on a verified processor {#papers-loow-pldi-2019}


Andreas Lööw, Ramana Kumar, Yong Kiam Tan, Magnus O. Myreen, Michael Norrish, Oskar Abrahamsson, Anthony C. J. Fox
Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation
ACM
Pages 1041-1053
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Verified%20compilation%20on%20a%20verified%20processor)
[[DBLP]](https://dblp.org/search?q=Verified%20compilation%20on%20a%20verified%20processor)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Verified%20compilation%20on%20a%20verified%20processor)
[[doi]](https://doi.org/10.1145/3314221.3314622)





# Provably correct peephole optimizations with Alive {#papers-lopes-pldi-2015}


Nuno P. Lopes, David Menendez, Santosh Nagarakatte, John Regehr
Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation
PLDI '15
Portland, OR, USA
ACM
New York, NY, USA
Pages 22-32
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=Provably%20correct%20peephole%20optimizations%20with%20Alive)
[[DBLP]](https://dblp.org/search?q=Provably%20correct%20peephole%20optimizations%20with%20Alive)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Provably%20correct%20peephole%20optimizations%20with%20Alive)
[[doi]](https://doi.org/10.1145/2737924.2737965)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-3468-6)





# Quantifying information flow {#papers-lowe-csfw-2015}


Gavin Lowe
Proceedings 15th IEEE Computer Security Foundations Workshop. CSFW-15
Pages 18-31
June
2002
[[Google Scholar]](https://scholar.google.com/scholar?q=Quantifying%20information%20flow)
[[DBLP]](https://dblp.org/search?q=Quantifying%20information%20flow)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Quantifying%20information%20flow)
[[doi]](https://doi.org/10.1109/CSFW.2002.1021804)

Notes: 
[information flow](#information flow),
[security](#security)\



[information flow]: #notes-information-flow
[security]: #notes-security
# COATCheck: Verifying memory ordering at the hardware-OS interface {#papers-lustig-asplos-2016}


Daniel Lustig, Geet Sethi, Margaret Martonosi, Abhishek Bhattacharjee
Architectural Support for Programming Languages and Operating Systems, ASPLOS
ACM
Pages 233-247
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=COATCheck%3A%20Verifying%20memory%20ordering%20at%20the%20hardware-OS%20interface)
[[DBLP]](https://dblp.org/search?q=COATCheck%3A%20Verifying%20memory%20ordering%20at%20the%20hardware-OS%20interface)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=COATCheck%3A%20Verifying%20memory%20ordering%20at%20the%20hardware-OS%20interface)
[[doi]](https://doi.org/10.1145/2872362.2872399)

Notes: 
[CPU verification](#CPU verification),
[Weak memory](#Weak memory)\



[CPU verification]: #notes-cpu-verification
[Weak memory]: #notes-weak-memory
# Test-case reduction via test-case generation: Insights from the Hypothesis reducer {#papers-maciver-ecoop-2020}


David R. MacIver, Alastair F. Donaldson
34th European Conference on Object-Oriented Programming (ECOOP 2020)
Schloss Dagstuhl, Leibniz-Zentrum für Informatik
Pages 13:1–13:28
2020
[[Google Scholar]](https://scholar.google.com/scholar?q=Test-case%20reduction%20via%20test-case%20generation%3A%20Insights%20from%20the%20Hypothesis%20reducer)
[[DBLP]](https://dblp.org/search?q=Test-case%20reduction%20via%20test-case%20generation%3A%20Insights%20from%20the%20Hypothesis%20reducer)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Test-case%20reduction%20via%20test-case%20generation%3A%20Insights%20from%20the%20Hypothesis%20reducer)

Notes: 
[fuzz testing](#fuzz testing),
[test-case reduction](#test-case reduction),
[unit tests](#unit tests),
[property-based testing](#property-based testing)\
Papers: 
[regehr:pldi:2012](#regehr-pldi-2012)\
Referenced by: 
[notes/test-case-reduction](#notes-test-case-reduction)\


This paper proposes a general purpose way of getting [test-case reduction] "for
free".  The paper shows that it "provides adequate reduction for any generated
test case, while avoiding the test-case validity problem."

There are three main ideas to achieve this.

The  key to avoiding creation of invalid values  is "internal reduction": the
reduction is integrated into the random generator instead of being performed by
an external tool as in C-reduce [regehr:pldi:2012].

The key to achieving this is to view a random generator as a "parser of choice
sequences" and to recover the structure of this parser (i.e., the generator) by
instrumenting the API. This  allows the reducer to perform optimizations such
as removing/replacing contiguous sequences of choices as seen in hierarchial
delta debugging.

The final ingredient is to have a generic notion of what makes one test-case
better than another.  This is defined as an ordering over the choice sequence
(not over some application-dependent rendering of the sequence).  They use
"shortlex order" where one sequence is ordered before another if it is shorter
or it is the same length but lexicographically earlier.

The "shortlex" order generally works well but for very carefully encoded data
types like binary floating point, you need to write a special generator to
arrange that a number like "1.0" will be preferred to a number like "5e-324".

The evaluation shows that this general purpose approach works about as well as
custom approaches on a broad range of cases.  (But the comparision with
C-reduce should be read carefully: my interpretation of the results is that _if
it really, really matters_ it may be worth putting in considerably more effort
to write a custom reducer.)

Perhaps the most important thing shown by the evaluation though is the ability
to apply the approach to many cases.

> This is an important selling point for internal reduction: it works at the
> level of choice sequences, and any randomized generator can be relatively
> easily adapted to consume a choice sequence instead of using
> a pseudo-random number generator, thus internal reduction has wide
> applicability.
> <br>
> – Section 4

The evaluation also reveals a scaling problem.  Their tool is fine generating
inputs up to about 8kB but, because the chance of triggering a bug is quite
low, CSmith is generally better with inputs of around 80kB.  It is not
completely clear whether this is fundamental to the way that Hypothesis works.



[fuzz testing]: #notes-fuzz-testing
[test-case reduction]: #notes-test-case-reduction
[unit tests]: #notes-unit-tests
[property-based testing]: #notes-property-based-testing
[regehr:pldi:2012]: #papers-regehr-pldi-2012
# API usability at scale {#papers-macvean-ppig-2016}


Andrew Macvean, John Daughtry, Luke Church, Craig Citro
Proceedings of the 26th annual workshop of the Psychology of Programming Interest Group
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=API%20usability%20at%20scale)
[[DBLP]](https://dblp.org/search?q=API%20usability%20at%20scale)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=API%20usability%20at%20scale)

Notes: 
[google papers](#google papers)\



[google papers]: #notes-google-papers
# Verifying security invariants in ExpressOS {#papers-mai-asplos-2013}


Haohui Mai, Edgar Pek, Hui Xue, Samuel Talmadge King, Parthasarathy Madhusudan
ASPLOS '13 Proceedings of the eighteenth international conference on Architectural support for programming languages and operating systems
ACM
Pages 293-304
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Verifying%20security%20invariants%20in%20ExpressOS)
[[DBLP]](https://dblp.org/search?q=Verifying%20security%20invariants%20in%20ExpressOS)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Verifying%20security%20invariants%20in%20ExpressOS)
[[doi]](https://doi.org/10.1145/2451116.2451148)

Notes: 
[abstract interpretation](#abstract interpretation),
[Dafny verifier](#Dafny verifier),
[contract driven development](#contract driven development)\
Papers: 
[leino:lpair:2010](#leino-lpair-2010)\


ExpressOS is a replacement single-threaded Android kernel written in C# running on top of L4/Fiasco.

This paper takes the interesting approach of only verifying security properties rather than full functional correctness and of building on top of untrusted file systems, etc. and relying on crypto/signing to provide confidentiality and integrity.

The verification work adds an impressively low 2.8% annotation overhead in the form of ghost state and ghost code and leverages code contracts (abstract interpretation) and [Dafny][leino:lpair:2010] (automated theorem proving) to prove properties about state machines, ownership, etc. that are reductions of the desired security invariants.

I was a little unclear about the interaction between Dafny and Code Contracts.
My best understanding is that Dafny is used to prove that methods satisfy their specification and then the specification is inserted at callsites where the abstract interpretation features of Code Contracts do the rest.
Presumably the way this works is that the abstract interpreter does its best to verify the code but, if that fails, it falls back on Dafny?

The paper notes a drawback of inserting ghost state and code: this part of the  specification ends up scattered across/interleaved with the code and is intimately tied to the code.
This raises the risk that this ghost code could contain mistakes.
They suggest that writing specs that are more independent from the code and more resilient to code changes but still enables automated theorem proving would be more robust and productive.

A number of experiments establish that the overhead of storing the additional metadata and signing/verifying/encrypting/decrypting the data is not too bad.
(The experiments are on a fairly low performance system with a slow disk – I wonder whether overhead would be larger or smaller on a modern SSD?)




[abstract interpretation]: #notes-abstract-interpretation
[Dafny verifier]: #notes-dafny-verifier
[contract driven development]: #notes-contract-driven-development
[leino:lpair:2010]: #papers-leino-lpair-2010
# Boolean satisfiability from theoretical hardness to practical success {#papers-malik-cacm-2009}


Sharad Malik, Lintao Zhang
Association for Computing Machinery
New York, NY, USA
Pages 76-82
August
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Boolean%20satisfiability%20from%20theoretical%20hardness%20to%20practical%20success)
[[DBLP]](https://dblp.org/search?q=Boolean%20satisfiability%20from%20theoretical%20hardness%20to%20practical%20success)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Boolean%20satisfiability%20from%20theoretical%20hardness%20to%20practical%20success)
[[doi]](https://doi.org/10.1145/1536616.1536637)
[[url]](https://doi.org/10.1145/1536616.1536637)

Notes: 
[SAT solver](#SAT solver),
[SMT solver](#SMT solver),
[survey](#survey)\
Papers: 
[demoura:cacm:2011](#demoura-cacm-2011)\
Referenced by: 
[papers/demoura:cacm:2011](#papers-demoura-cacm-2011),
[notes/sat-solver](#notes-sat-solver)\


This paper is a great intro/overview of SAT solving: what it is, why it is (NP)
hard, how SAT solvers work, the role of benchmarks and competitions, the
massive performance improvements in the 10 years prior to it being published
and the industrial impact.

Worth reading in conjunction with the SMT intro/overview in
[demoura:cacm:2011].




[SAT solver]: #notes-sat-solver
[SMT solver]: #notes-smt-solver
[survey]: #notes-survey
[demoura:cacm:2011]: #papers-demoura-cacm-2011
# The art, science, and engineering of fuzzing: A survey {#papers-manes-ieeetse-2019}


Valentin J.M. Manès, HyungSeok Han, Choongwoo Han, Sang Kil Cha, Manuel Egele, Edward J. Schwartz, Maverick Woo
Pages 21
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20art%2C%20science%2C%20and%20engineering%20of%20fuzzing%3A%20A%20survey)
[[DBLP]](https://dblp.org/search?q=The%20art%2C%20science%2C%20and%20engineering%20of%20fuzzing%3A%20A%20survey)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20art%2C%20science%2C%20and%20engineering%20of%20fuzzing%3A%20A%20survey)
[[doi]](https://doi.org/10.1109/TSE.2019.2946563)

Notes: 
[fuzz testing](#fuzz testing),
[symbolic execution](#symbolic execution),
[survey](#survey)\
Referenced by: 
[notes/fuzz-testing](#notes-fuzz-testing)\


This large (21 pages, 240 references) survey of [fuzz testing]
proposes a taxonomy and standardized terminology.
They use a "model fuzzer" throughout the survey to motivate/explain
fuzzer design choices.

The survey covers all fuzzing papers from 2008–2019 in 7 conferences
(CCS, S&P, NDSS, USEC, FSE, ASE and ICSE) plus additional relevant
papers.

Their terminology:

- Program Under Test (PUT)
- Fuzzing = testing with a large number of unexpected inputs
  to find security bugs
- Fuzz campaign
- Seed pool (called a corpus by AFL)
- Taint analysis = determining dependency of branches on parts of input
- Crash triage = grouping bugs.
  Can use coverage, execution counts, stack hashing, etc.
- Instrumentation – used to detect bugs and to measure coverage/etc.
  (Note: dynamic instrumentation needed for dynamic libraries, etc.)
- In-memory fuzzing is fuzzing part of the program repeatedly
  without respawning the process.
  Can lead to unrepeatable reports or false reports.
  (cf. "online" or "execution generated testing (EGT)" in [symbolic execution]).
- Seed trimming reduces the size of seeds



Their model fuzzer starts as

    Preprocess(fuzz_config)
    while t_elapsed <= t_limit:
        config = Schedule(fuzz_config, t_elapsed, t_limit)
        test_cases = InputGen(config)
        new_bugs, exec_infos = InputEval(config, test_cases, oracle)
        all_bugs = all_bugs + new_bugs
        fuzz_config = ConfigUpdate(fuzz_config, config, exec_infos)
        if !Continue(fuzz_config): break

This model allows them to classify around 100 fuzzers according to the design choices
they make in each of the functions:

- Misc:
  feedback gathering granularity (black/grey/white),
  open sourced,
  requires source code for PUT
- Preprocess: 
  supports in-memory fuzzing,
  constructs model,
  performs program analysis
- Schedule:
  performs seed scheduling
- InputGen:
  mutation,
  model-based,
  constraint-based,
  taint analysis
- InputEval:
  crash triage by stack hash,
  crash triage by coverage
- ConfigUpdate:
  evolutionaly seed pool update,
  model update,
  seed pool culling

The following sections follow the structure of the paper
(and of the paper's model fuzzer).

## Preprocess

## Scheduling

The "Fuzz Configuration Scheduling (FCS) Problem":

> Fundamentally, every scheduling algorithm confronts the same _exploration_
> vs. _exploitation_ conflict – time can either be spent on gathering more
> accurate information on each configuration to inform future decisions
> (explore), or on fuzzing the configurations that are currently believed to
> lead to more favorable outcomes (exploit).

The main choices are black/grey/white-box.
There is a table that organizes fuzzers by date and by genealogical
connections and breaks them down into

- black-box (subdivided into network, file and kernel)
- grey-box (subdivided into concurrency, file and kernel)
- white-box

Models of black-box mutational fuzzing include Bernoulli trials,
"Weighted Coupon Collector's Problem with Unknown Weights" (WCCP/UW),
"Multi-armed bandit" (MAB).
Grey-box fuzzers often use "evolutionary algorithms" (EA), may prioritize
configurations that have been used least (which encourages cycling
through configurations), use a power schedule.

## Input generation

Inputs can be generated

- according to a model: "generation-based fuzzers" or "model-based fuzzers"
  - grammar-based
  - inferring grammars from examples, source code, etc. during Preprocess
  - inferring grammars from instrumentation during ConfigUpdate
- by mutation of a seed: "mutation-based fuzzers"
  - bit-flipping
  - arithmetic mutation
  - block-based mutation
  - dictionary-based mutation

## Input evaluation

Oracles include

- instrumentation such as address/memory/UB/thread sanitizers, control-flow integrity, etc.
- detecting known insecurity vulnerability
- differential testing

Seed trimming is reducing the size of a crashing test case.
Test case minimization is reducing the size of a crashing test case
using the bug oracle. (This distinction is not clear to me.)

## Configuration updating

- Evolutionary algorithms update the seed pool and update the fitness function
- Updating the minset of testcases according to some coverage metric by
  culling weaker testcases





[fuzz testing]: #notes-fuzz-testing
[symbolic execution]: #notes-symbolic-execution
[survey]: #notes-survey
# Formal verification of a memory allocation module of Contiki with Frama-C: a case study {#papers-mangano-crisis-2016}


Frédéric Mangano, Simon Duquennoy, Nikolai Kosmatov
International Conference on Risks and Security of Internet and Systems
Springer
Pages 114-120
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Formal%20verification%20of%20a%20memory%20allocation%20module%20of%20Contiki%20with%20Frama-C%3A%20a%20case%20study)
[[DBLP]](https://dblp.org/search?q=Formal%20verification%20of%20a%20memory%20allocation%20module%20of%20Contiki%20with%20Frama-C%3A%20a%20case%20study)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Formal%20verification%20of%20a%20memory%20allocation%20module%20of%20Contiki%20with%20Frama-C%3A%20a%20case%20study)
[[doi]](https://doi.org/10.1007/978-3-319-54876-0_9)

Notes: 
[Frama-C verifier](#Frama-C verifier)\
Papers: 
[cuoq:sefm:2012](#cuoq-sefm-2012)\
Referenced by: 
[notes/annotation-burden](#notes-annotation-burden)\


This paper describes the use of [Frama-C][cuoq:sefm:2012] to specify and verify the
Contiki memory allocator.
The description is very clear and contains enough of the specification that
it should be easy to reproduce or adapt to other allocators.
Use of the specification is demonstrated on a simple program that allocates
two objects and then frees them.
The annotation burden is about 154 lines to 139 lines of code (around 110%) – which seems to be about normal for Frama-C.

One minor complaint is that,
although it describes in detail an inductive definition for calculating the number of free blocks,
it does not contain the definition.
And, it relies on some auxiliary lemmas proved in Coq but does not show the details to better explain how Coq and Frama-C are used together.
(However, it does cite a paper [2] that may contain that detail.)

Overall, a short, easy and rewarding read.



[Frama-C verifier]: #notes-frama-c-verifier
[cuoq:sefm:2012]: #papers-cuoq-sefm-2012
# Detecting critical bugs in SMT solvers using blackbox mutational fuzzing {#papers-mansur-arxiv-2020}


Muhammad Numair Mansur, Maria Christakis, Valentin Wüstholz, Fuyuan Zhang
2020
[[Google Scholar]](https://scholar.google.com/scholar?q=Detecting%20critical%20bugs%20in%20SMT%20solvers%20using%20blackbox%20mutational%20fuzzing)
[[DBLP]](https://dblp.org/search?q=Detecting%20critical%20bugs%20in%20SMT%20solvers%20using%20blackbox%20mutational%20fuzzing)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Detecting%20critical%20bugs%20in%20SMT%20solvers%20using%20blackbox%20mutational%20fuzzing)
[[arXiv]](https://arxiv.org/2004.05934)

Notes: 
[SMT solver](#SMT solver)\
Papers: 
[brummayer:sat:2010](#brummayer-sat-2010),
[stump:fmsd:2013](#stump-fmsd-2013)\
Referenced by: 
[papers/barrett:mlf:2015](#papers-barrett-mlf-2015),
[papers/brummayer:sat:2010](#papers-brummayer-sat-2010),
[papers/stump:fmsd:2013](#papers-stump-fmsd-2013),
[notes/smt-solver](#notes-smt-solver)\



[SMT solver]: #notes-smt-solver
[brummayer:sat:2010]: #papers-brummayer-sat-2010
[stump:fmsd:2013]: #papers-stump-fmsd-2013
# Controlling the what and where of declassification in language-based security {#papers-mantel-pls-2007}


Heiko Mantel, Alexander Reinhard
Programming Languages and Systems
Springer
Pages 141-156
2007
[[Google Scholar]](https://scholar.google.com/scholar?q=Controlling%20the%20what%20and%20where%20of%20declassification%20in%20language-based%20security)
[[DBLP]](https://dblp.org/search?q=Controlling%20the%20what%20and%20where%20of%20declassification%20in%20language-based%20security)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Controlling%20the%20what%20and%20where%20of%20declassification%20in%20language-based%20security)
[[doi]](https://doi.org/10.1007/978-3-540-71316-6_11)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-71316-6)

Notes: 
[information flow](#information flow)\




[information flow]: #notes-information-flow
# Preserving information flow properties under refinement {#papers-mantel-sp-2001}


Heiko Mantel
Proceedings 2001 IEEE Symposium on Security and Privacy. S&P 2001
IEEE
Pages 78-91
2000
[[Google Scholar]](https://scholar.google.com/scholar?q=Preserving%20information%20flow%20properties%20under%20refinement)
[[DBLP]](https://dblp.org/search?q=Preserving%20information%20flow%20properties%20under%20refinement)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Preserving%20information%20flow%20properties%20under%20refinement)
[[doi]](https://doi.org/10.1109/SECPRI.2001.924289)

Notes: 
[information flow](#information flow)\




[information flow]: #notes-information-flow
# Path-exploration lifting: Hi-fi tests for lo-fi emulators {#papers-martignoni-asplos-2012}


Lorenzo Martignoni, Stephen McCamant, Pongsin Poosankam, Dawn Song, Petros Maniatis
Proceedings of the Seventeenth International Conference on Architectural Support for Programming Languages and Operating Systems
ASPLOS XVII
London, England, UK
ACM
New York, NY, USA
Pages 337-348
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=Path-exploration%20lifting%3A%20Hi-fi%20tests%20for%20lo-fi%20emulators)
[[DBLP]](https://dblp.org/search?q=Path-exploration%20lifting%3A%20Hi-fi%20tests%20for%20lo-fi%20emulators)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Path-exploration%20lifting%3A%20Hi-fi%20tests%20for%20lo-fi%20emulators)
[[doi]](https://doi.org/10.1145/2150976.2151012)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-0759-8)

Notes: 
[x86 architecture](#x86 architecture)\




[x86 architecture]: #notes-x86-architecture
# Superoptimizer: A look at the smallest program {#papers-massalin-asplos-1987}


Alexia Massalin
Proceedings of the Second International Conference on Architectual Support for Programming Languages and Operating Systems
ASPLOS II
Palo Alto, California, USA
IEEE Computer Society Press
Washington, DC, USA
Pages 122-126
1987
[[Google Scholar]](https://scholar.google.com/scholar?q=Superoptimizer%3A%20A%20look%20at%20the%20smallest%20program)
[[DBLP]](https://dblp.org/search?q=Superoptimizer%3A%20A%20look%20at%20the%20smallest%20program)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Superoptimizer%3A%20A%20look%20at%20the%20smallest%20program)
[[doi]](https://doi.org/10.1145/36206.36194)
[[ISBN]](http://books.google.com/books?vid=ISBN0818608056)
[[url]](https://doi.org/10.1145/36206.36194)

Notes: 
[superoptimizer](#superoptimizer)\
Referenced by: 
[notes/superoptimizer](#notes-superoptimizer)\



[superoptimizer]: #notes-superoptimizer
# RustHorn: CHC-based verification for Rust programs {#papers-matsushita-esop-2020}


Yusuke Matsushita, Takeshi Tsukada, Naoki Kobayashi
Programming Languages and Systems
Springer International Publishing
Cham
Pages 484-514
2020
[[Google Scholar]](https://scholar.google.com/scholar?q=RustHorn%3A%20CHC-based%20verification%20for%20Rust%20programs)
[[DBLP]](https://dblp.org/search?q=RustHorn%3A%20CHC-based%20verification%20for%20Rust%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=RustHorn%3A%20CHC-based%20verification%20for%20Rust%20programs)
[[doi]](https://doi.org/10.1007/978-3-030-44914-8_18)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-030-44914-8)

Notes: 
[Rust language](#Rust language),
[MIR](#MIR)\
Papers: 
[gurfinkel:cav:2015](#gurfinkel-cav-2015),
[astrauskas:oopsla:2019](#astrauskas-oopsla-2019),
[baranowski:atva:2018](#baranowski-atva-2018),
[ullrich:msc:2016](#ullrich-msc-2016)\
Referenced by: 
[papers/ullrich:msc:2016](#papers-ullrich-msc-2016)\


Verifies Rust programs by converting basic blocks in the [MIR] representation
of the code into Constrained Horn Clauses (CHCs) that
are then verified using Horn clause support in Z3 or HoIce.

The conversion reminds me of [Electrolysis][ullrich:msc:2016]
(that translates Rust to Lean functions)
while the use of Horn clauses reminds me of [SeaHorn][gurfinkel:cav:2015]
(that translates LLVM IR to Horn clauses).

The implementation is [here](https://github.com/hopv/rust-horn).



[Rust language]: #notes-rust-language
[MIR]: #notes-mir
[gurfinkel:cav:2015]: #papers-gurfinkel-cav-2015
[astrauskas:oopsla:2019]: #papers-astrauskas-oopsla-2019
[baranowski:atva:2018]: #papers-baranowski-atva-2018
[ullrich:msc:2016]: #papers-ullrich-msc-2016
# Vx86: x86 assembler simulated in C powered by automated theorem proving {#papers-maus-amast-2008}


Stefan Maus, Michał Moskal, Wolfram Schulte
Algebraic Methodology and Software Technology: 12th International Conference, AMAST 2008 Urbana, IL, USA, July 28-31, 2008 Proceedings
Springer
Berlin, Heidelberg
Pages 284-298
2008
[[Google Scholar]](https://scholar.google.com/scholar?q=Vx86%3A%20x86%20assembler%20simulated%20in%20C%20powered%20by%20automated%20theorem%20proving)
[[DBLP]](https://dblp.org/search?q=Vx86%3A%20x86%20assembler%20simulated%20in%20C%20powered%20by%20automated%20theorem%20proving)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Vx86%3A%20x86%20assembler%20simulated%20in%20C%20powered%20by%20automated%20theorem%20proving)
[[doi]](https://doi.org/10.1007/978-3-540-79980-1_22)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-79980-1)

Notes: 
[x86 architecture](#x86 architecture),
[binary analysis](#binary analysis)\



[x86 architecture]: #notes-x86-architecture
[binary analysis]: #notes-binary-analysis
# Easy approach to requirements syntax (EARS) {#papers-mavin-isre-2009}


Alistair Mavin, Philip Wilkinson, Adrian Harwood, Mark Novak
17th IEEE International Requirements Engineering Conference (RE'09)
IEEE
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Easy%20approach%20to%20requirements%20syntax%20%28EARS%29)
[[DBLP]](https://dblp.org/search?q=Easy%20approach%20to%20requirements%20syntax%20%28EARS%29)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Easy%20approach%20to%20requirements%20syntax%20%28EARS%29)
[[doi]](https://doi.org/10.1109/RE.2009.9)

Notes: 
[formal specification](#formal specification)\



[formal specification]: #notes-formal-specification
# Spectre is here to stay: An analysis of side-channels and speculative execution {#papers-mcilroy-arxiv-2019}


Ross Mcilroy, Jaroslav Sevcik, Tobias Tebbi, Ben L. Titzer, Toon Verwaest
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Spectre%20is%20here%20to%20stay%3A%20An%20analysis%20of%20side-channels%20and%20speculative%20execution)
[[DBLP]](https://dblp.org/search?q=Spectre%20is%20here%20to%20stay%3A%20An%20analysis%20of%20side-channels%20and%20speculative%20execution)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Spectre%20is%20here%20to%20stay%3A%20An%20analysis%20of%20side-channels%20and%20speculative%20execution)
[[arXiv]](https://arxiv.org/1902.05178)

Notes: 
[side channel](#side channel),
[speculative execution](#speculative execution),
[security](#security)\



[side channel]: #notes-side-channel
[speculative execution]: #notes-speculative-execution
[security]: #notes-security
# Verification of an implementation of Tomasulo's algorithm by compositional model checking {#papers-mcmillan-cav-1998}


Kenneth L. McMillan
Computer Aided Verification: 10th International Conference, CAV'98 Vancouver, BC, Canada, June 28 - July 2, 1998 Proceedings
Springer
Berlin, Heidelberg
Pages 110-121
1998
[[Google Scholar]](https://scholar.google.com/scholar?q=Verification%20of%20an%20implementation%20of%20Tomasulo%27s%20algorithm%20by%20compositional%20model%20checking)
[[DBLP]](https://dblp.org/search?q=Verification%20of%20an%20implementation%20of%20Tomasulo%27s%20algorithm%20by%20compositional%20model%20checking)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Verification%20of%20an%20implementation%20of%20Tomasulo%27s%20algorithm%20by%20compositional%20model%20checking)
[[doi]](https://doi.org/10.1007/BFb0028738)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-69339-0)

Notes: 
[CPU verification](#CPU verification),
[model checking](#model checking)\
Referenced by: 
[notes/symbolic-model-checking](#notes-symbolic-model-checking)\



[CPU verification]: #notes-cpu-verification
[model checking]: #notes-model-checking
# Model checking {#papers-mcmillan-ecs-2003}


Kenneth L. McMillan
Encyclopedia of Computer Science
John Wiley and Sons Ltd.
GBR
Pages 1177-1181
2003
[[Google Scholar]](https://scholar.google.com/scholar?q=Model%20checking)
[[DBLP]](https://dblp.org/search?q=Model%20checking)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Model%20checking)
[[ISBN]](http://books.google.com/books?vid=ISBN0470864125)

Notes: 
[survey](#survey),
[model checking](#model checking),
[symbolic model checking](#symbolic model checking),
[partial order reduction](#partial order reduction),
[temporal logic](#temporal logic)\
Papers: 
[jhala:compsurv:2009](#jhala-compsurv-2009),
[clarke:cacm:2009](#clarke-cacm-2009)\
Referenced by: 
[notes/model-checking](#notes-model-checking)\


This is a good survey of model checking that lays out the main concepts and
why they matter:

- specification
  - [temporal logic]
    - branching time logic (BTL)
      - computation tree logic (CTL)
    - linear temporal logic (LTL)
  - automata-based specification and verification
- scaling and performance of implementation
  - the state explosion problem
  - [symbolic model checking]
  - exploitation of symmetry
  - [partial order-based reductions][partial order reduction]
  - abstraction and compositional methods
    - abstraction
    - compositional methods

While this all remains very relevant, this article is from 2003 and the most
recent citation is from 1998 and most of them are from the '80s so this survey
needs to be supplemented with an update on the last 20 years.
(It also doesn't say much about how a model checker works internally.)



[survey]: #notes-survey
[model checking]: #notes-model-checking
[symbolic model checking]: #notes-symbolic-model-checking
[partial order reduction]: #notes-partial-order-reduction
[temporal logic]: #notes-temporal-logic
[jhala:compsurv:2009]: #papers-jhala-compsurv-2009
[clarke:cacm:2009]: #papers-clarke-cacm-2009
# LLBMC: Bounded model checking of C and C++ programs using a compiler IR {#papers-merz-vstte-2012}


Florian Merz, Stephan Falke, Carsten Sinz
Verified Software: Theories, Tools, Experiments
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 146-161
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=LLBMC%3A%20Bounded%20model%20checking%20of%20C%20and%20C%2B%2B%20programs%20using%20a%20compiler%20IR)
[[DBLP]](https://dblp.org/search?q=LLBMC%3A%20Bounded%20model%20checking%20of%20C%20and%20C%2B%2B%20programs%20using%20a%20compiler%20IR)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=LLBMC%3A%20Bounded%20model%20checking%20of%20C%20and%20C%2B%2B%20programs%20using%20a%20compiler%20IR)
[[doi]](https://doi.org/10.1007/978-3-642-27705-4_12)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-27705-4)

Notes: 
[LLVM compiler](#LLVM compiler),
[bounded model checking](#bounded model checking)\




[LLVM compiler]: #notes-llvm-compiler
[bounded model checking]: #notes-bounded-model-checking
# An empirical study of the reliability of UNIX utilities {#papers-miller-cacm-1990}


Barton P. Miller, Louis Fredriksen, Bryan So
Association for Computing Machinery
New York, NY, USA
Pages 32-44
December
1990
[[Google Scholar]](https://scholar.google.com/scholar?q=An%20empirical%20study%20of%20the%20reliability%20of%20UNIX%20utilities)
[[DBLP]](https://dblp.org/search?q=An%20empirical%20study%20of%20the%20reliability%20of%20UNIX%20utilities)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=An%20empirical%20study%20of%20the%20reliability%20of%20UNIX%20utilities)
[[doi]](https://doi.org/10.1145/96267.96279)
[[url]](https://doi.org/10.1145/96267.96279)

Notes: 
[fuzz testing](#fuzz testing)\
Referenced by: 
[notes/fuzz-testing](#notes-fuzz-testing)\


This is the paper that started the field of [fuzz testing], coined
the name, and tells the origin story.

> On a  dark and stormy night one of the  authors was logged on to his
> workstation on a dial-up line from home and the rain had affected the phone
> lines; there were frequent spurious characters on the line.  The author had to
> race to see if he could type a sensible sequence of characters before the noise
> scrambled the command. This line noise was not surprising; but we were
> surprised that these spurious characters were causing programs to crash.

They went on to test almost 90 Unix utilities on seven versions of Unix
using by piping random characters into them and found that 24% of them
failed.

The programs failed for a range of reasons that is depressingly familiar
30 years later

- buffer overflow errors
- dereferencing null and invalid pointers
- not checking return codes
- not using bounds with fscanf
- invoking vulnerable programs as subprocesses
- using user-input as the first argument to printf
- bugs in error handling code
- assuming 'char' is unsigned
- race conditinos with signal handlers

As one would expect, the biggest source was buffer overflows, pointer
dereferences and input errors (e.g., fscanf).

The paper also makes recommendations, suggests that the way Unix was developed
and the fact that it is easier to work round a bug than to report it makes
these bugs common.
They report that their "jigs" (fuzzing harnesses) are available for others to
try using.

Although they compare with traditional testing, they make a surprising number
of references to formal verification such as

> ... our simple testing technique has discovered a wealth of errors and is
> likely to be more commonly used (at least in the near term) than more formal
> procedures.




[fuzz testing]: #notes-fuzz-testing
# A theory of type polymorphism in programming {#papers-milner-jcss-1978}


Robin Milner
Pages 348 - 375
1978
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20theory%20of%20type%20polymorphism%20in%20programming)
[[DBLP]](https://dblp.org/search?q=A%20theory%20of%20type%20polymorphism%20in%20programming)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20theory%20of%20type%20polymorphism%20in%20programming)
[[doi]](https://doi.org/10.1016/0022-0000(78)90014-4)

Notes: 
[type inference](#type inference)\



[type inference]: #notes-type-inference
# Processor description languages {#papers-mishra-book-2008}


Prabhat Mishra, Nikil Dutt
Morgan Kaufmann Publishers Inc.
San Francisco, CA, USA
2008
[[Google Scholar]](https://scholar.google.com/scholar?q=Processor%20description%20languages)
[[DBLP]](https://dblp.org/search?q=Processor%20description%20languages)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Processor%20description%20languages)
[[ISBN]](http://books.google.com/books?vid=ISBN9780080558370%2C%209780123742872)

Notes: 
[ISA specification](#ISA specification)\



[ISA specification]: #notes-isa-specification
# Boost the impact of continuous formal verification in industry {#papers-monteiro-arxiv-2019}


Felipe R. Monteiro, Mikhail R. Gadelha, Lucas C. Cordeiro
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Boost%20the%20impact%20of%20continuous%20formal%20verification%20in%20industry)
[[DBLP]](https://dblp.org/search?q=Boost%20the%20impact%20of%20continuous%20formal%20verification%20in%20industry)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Boost%20the%20impact%20of%20continuous%20formal%20verification%20in%20industry)



Proposes a way to use model checking on large codebases when CI is used and lots of regression tests are available (at least one per C function).
Like fb-infer, focusses on verifying changes.
Approach is to use equivalence checking to find which functions may have changed, select regression tests relevant to those functions and then to generalise inputs of regression tests to increase their coverage.

I think this differs from fb-infer by using tests and model checking - but similar goals in terms of where it fits in developer workflow.

Final sentences say that they are working with AWS and Samsung to evaluate/apply their approach and tools.



# RockSalt: Better, faster, stronger SFI for the x86 {#papers-morrisett-pldi-2012}


Greg Morrisett, Gang Tan, Joseph Tassarotti, Jean-Baptiste Tristan, Edward Gan
Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation
PLDI '12
Beijing, China
ACM
New York, NY, USA
Pages 395-404
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=RockSalt%3A%20Better%2C%20faster%2C%20stronger%20SFI%20for%20the%20x86)
[[DBLP]](https://dblp.org/search?q=RockSalt%3A%20Better%2C%20faster%2C%20stronger%20SFI%20for%20the%20x86)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=RockSalt%3A%20Better%2C%20faster%2C%20stronger%20SFI%20for%20the%20x86)
[[doi]](https://doi.org/10.1145/2254064.2254111)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-1205-9)

Notes: 
[ISA specification](#ISA specification),
[x86 architecture](#x86 architecture),
[instruction set architecture](#instruction set architecture)\




[ISA specification]: #notes-isa-specification
[x86 architecture]: #notes-x86-architecture
[instruction set architecture]: #notes-instruction-set-architecture
# TALx86: A realistic typed assembly language {#papers-morrisett-wcsss-1999}


Greg Morrisett, Karl Crary, Neal Glew, Dan Grossman, Richard Samuels, Frederick Smith, David Walker, Stephanie Weirich, Steve Zdancewic
In Second Workshop on Compiler Support for System Software
Pages 25-35
1999
[[Google Scholar]](https://scholar.google.com/scholar?q=TALx86%3A%20A%20realistic%20typed%20assembly%20language)
[[DBLP]](https://dblp.org/search?q=TALx86%3A%20A%20realistic%20typed%20assembly%20language)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=TALx86%3A%20A%20realistic%20typed%20assembly%20language)

Notes: 
[x86 architecture](#x86 architecture),
[instruction set architecture](#instruction set architecture),
[typed assembly language](#typed assembly language),
[linear logic](#linear logic)\
Referenced by: 
[papers/smith:esop:2000](#papers-smith-esop-2000),
[papers/walker:popl:2000](#papers-walker-popl-2000),
[notes/annotation-burden](#notes-annotation-burden),
[notes/typed-assembly-language](#notes-typed-assembly-language)\


Typed assembly language is normal assembly language (x86 in this case) where any branch targets are labelled with the type of
all the registers.
The main purpose of the types is to make the assembly code type/memory
safe and so the focus is on distinguishing pointers from
non-pointers and distinguishing the size and type of what each
pointer points to.
This paper is one of the later papers in a series on typed assembly language and also related to the Cyclone language: a type/memory-safe C substitute.

To demonstrate that their type system is expressive enough, they describe 'Popcorn' - a small C-like language that they can compile to TALx86.
Compared with C, some major differences are that Popcorn

* includes memory allocation
* distinguishes between pointers that can be null and pointers that cannot be null
* provides tagged union types that resemble the algebraic data types found in functional languages
* supports parametric polymorphism

The essence of TALx86's type system is that you can give a code label a type like "{eax: B4, ebx: B4, ebp: {eax:B4}}" that says that eax and ebx are 4-byte values and ebp is a pointer to code that expects a 4-byte value in eax.
Building on top of that, they also have

* the type of a stack is a list of types like "sptr {eax:B4}::B4::B4::rho" which gives the type of the top three entries on the stack
* parametric polymorphism is used to express the idea that a function will work on any stack shape
  by letting us write
  "forall rho:Ts. {esp:sptr{eax:B4, esp:sptr B4::rho}::B4::rho"
* return addresses are treated as continuations - so there is no need for function types
* fields of structs have a "variance" u, r, w or rw to indicate whether it is uninitialized (really important!) or is readable/writable (in the absence of alias tracking in the type system, this can cause false positives)
* arrays are handled using singleton types like {5} to express
  the type that must have the value 5 and using existentials
  to associate the size of an array with the array.
  The neat thing about this is that the size information
  doesn't have to be in a pre-determined position in memory.
* support for the tagged union types from Popcorn
* they have various forms of inference, etc. to reduce the annotation burden


Although they come very close, they can't quite allow arbitrary assembly.

* memory allocation and array index checks are performed using macros
* memory deallocation is performed using conservative garbage collection.
* the Popcorn runtime is not written in TALx86



[x86 architecture]: #notes-x86-architecture
[instruction set architecture]: #notes-instruction-set-architecture
[typed assembly language]: #notes-typed-assembly-language
[linear logic]: #notes-linear-logic
# Viper: A verification infrastructure for permission-based reasoning {#papers-muller-vmcai-2016}


Peter Müller, Malte Schwerhoff, Alexander J. Summers
Verification, Model Checking, and Abstract Interpretation
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 41-62
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Viper%3A%20A%20verification%20infrastructure%20for%20permission-based%20reasoning)
[[DBLP]](https://dblp.org/search?q=Viper%3A%20A%20verification%20infrastructure%20for%20permission-based%20reasoning)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Viper%3A%20A%20verification%20infrastructure%20for%20permission-based%20reasoning)
[[doi]](https://doi.org//10.1007/978-3-662-49122-5_2)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-662-49122-5)

Notes: 
[permission logic](#permission logic),
[Viper verifier](#Viper verifier),
[intermediate verification language](#intermediate verification language),
[magic wand](#magic wand),
[SMT solver](#SMT solver)\
Papers: 
[barnett:fmco:2005](#barnett-fmco-2005),
[jacobs:vstte:2010](#jacobs-vstte-2010),
[bornat:popl:2005](#bornat-popl-2005),
[leino:fosad:2007](#leino-fosad-2007)\
Referenced by: 
[papers/astrauskas:oopsla:2019](#papers-astrauskas-oopsla-2019)\


[Viper][Viper verifier] is like [Boogie][barnett:fmco:2005]
in that it is an [intermediate verification language] (IVL)
that can support multiple language frontends and also
multiple verification backends.
The most important difference is that Viper is based on a form of
[permission logic] that is well suited to reasoning about
heap based data structures.

The Viper language is an sequential, imperative, object-based
language with impure procedures (called "methods")
and pure functions and supporting loops and recursion.
Methods and functions have contracts consisting of
requires/ensures predicates and all reasoning
about method calls is based on instantiating the contract
at the call site.
Loops also have invariants (it is not clear whether they also
have variants to let you prove termination).

Methods serve two purposes: they can represent the code that
you want to reason about but they can also be used to
prove lemmas.
An example lemma in the paper is "concat" that relates
two parts of a linked list to the entire list.
I have seen the same trick being used in
[VeriFast][jacobs:vstte:2010]
but, since VeriFast is not an IVL, it keeps
C functions we are reasoning about separate from
lemma functions used to reason about them.

Predicates can describe the fields of an object that can be accessed
and [fractional permissions][bornat:popl:2005]
can be used to allow shared read-only access.

A relatively unusual feature of Viper is that it has first-class
support for [magic wand]s "——∗" (the implication operator from
separation logic).
There is a nice discussion of how using magic wands simplifies
reasoning about partial verisons of data structures and,
in their example, avoids the need to introduce recursive definitions
such as "concat" to combine parts of data structures.

Another unusual thing about Viper is that you can define
"domains" consisting of some uninterpreted functions plus some
axioms.
For example, arrays are defined in this way instead of being
built into Viper.
It seems that this approach lets them keep the Viper core
quite small and lean.

Finally, there is an evaluation and comparision with
[Chalice][leino:fosad:2007]
and
[Boogie][barnett:fmco:2005].



[permission logic]: #notes-permission-logic
[Viper verifier]: #notes-viper-verifier
[intermediate verification language]: #notes-intermediate-verification-language
[magic wand]: #notes-magic-wand
[SMT solver]: #notes-smt-solver
[barnett:fmco:2005]: #papers-barnett-fmco-2005
[jacobs:vstte:2010]: #papers-jacobs-vstte-2010
[bornat:popl:2005]: #papers-bornat-popl-2005
[leino:fosad:2007]: #papers-leino-fosad-2007
# seL4: from general purpose to a proof of information flow enforcement {#papers-murray-secpriv-2013}


Toby Murray, Daniel Matichuk, Matthew Brassil, Peter Gammie, Timothy Bourke, Sean Seefried, Corey Lewis, Xin Gao, Gerwin Klein
2013 IEEE Symposium on Security and Privacy
IEEE
Pages 415-429
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=seL4%3A%20from%20general%20purpose%20to%20a%20proof%20of%20information%20flow%20enforcement)
[[DBLP]](https://dblp.org/search?q=seL4%3A%20from%20general%20purpose%20to%20a%20proof%20of%20information%20flow%20enforcement)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=seL4%3A%20from%20general%20purpose%20to%20a%20proof%20of%20information%20flow%20enforcement)
[[doi]](https://doi.org/10.1109/SP.2013.35)

Notes: 
[information flow](#information flow)\
Papers: 
[klein:sosp:2009](#klein-sosp-2009),
[costanzo:pldi:2016](#costanzo-pldi-2016)\


Most operating systems do two things:
they isolate processes from each other;
and
they allow some limited communication between processes.
There have been multiple attempts over more
than 30 years to prove
that an operating system actually achieves these goals;
this is the first really convincing such proof.
The proof is about the seL4 microkernel that had
already been
[formally verified][klein:sosp:2009]
as implementing its formal specification.
The paper takes us step by step through the proof
as well as being very clear about the assumptions and gaps
in the verification and the effort required for the verification.

Besides the proof, the paper focusses on three tricky areas:

1. Information flow through the scheduler.
   To avoid information flow, they took the common step of replacing
   the scheduler with a simple static round-robin scheduler between
   partitions.
   They then had to prove that this was sufficient to eliminate
   information flow.

2. Directional communication between processes.
   They need to show that there is no back-channel that allows
   bidirectional information flow.

3. What is the formal security specification?
   Given a set of processes, communication channels between them,
   etc. how do we formally state what can and cannot happen?
   There are many subtleties here that the paper walk us through.
   (But reference [36] promises to have even more detail.)

The paper ends with a lengthy discussion of the strength of the
proof.
There is little concern about the proof since it is machine-checked
and it is based on the actual C code rather than a hand-written
model of the C code.
(Around the same time, the group was also working on translation validation
to show that the C code matched the compiled binary.)
They acknowledge gaps around their model of the hardware.
The most significant issue, of course, is around covert
channels – a problem that we the field has no good solutions
for at present.

They also discuss ways in which they changed the design of seL4,
surprising information leaks they discovered and which parts
of the proof were hardest to complete.

This paper should be compared with the later work
on [verifying information flow properties of the mCertiKOS separation kernel][costanzo:pldi:2016].
The big difference between the two is that this paper proves
results in the presence of communication between different
processes while the mCertiKOS paper proves results about
a system in which inter-process communication has been
disabled.



[information flow]: #notes-information-flow
[klein:sosp:2009]: #papers-klein-sosp-2009
[costanzo:pldi:2016]: #papers-costanzo-pldi-2016
# Type-based decompilation (or program reconstruction via type reconstruction) {#papers-mycroft-esop-1999}


Alan Mycroft
Programming Languages and Systems
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 208-223
1999
[[Google Scholar]](https://scholar.google.com/scholar?q=Type-based%20decompilation%20%28or%20program%20reconstruction%20via%20type%20reconstruction%29)
[[DBLP]](https://dblp.org/search?q=Type-based%20decompilation%20%28or%20program%20reconstruction%20via%20type%20reconstruction%29)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Type-based%20decompilation%20%28or%20program%20reconstruction%20via%20type%20reconstruction%29)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-49099-9)

Notes: 
[typed assembly language](#typed assembly language)\
Referenced by: 
[notes/typed-assembly-language](#notes-typed-assembly-language)\




[typed assembly language]: #notes-typed-assembly-language
# Enforcing robust declassification {#papers-myers-csfw-2004}


Andrew C. Myers, Andrei Sabelfeld, Steve Zdancewic
Proceedings 17th IEEE Computer Security Foundations Workshop
Pages 172-186
June
2004
[[Google Scholar]](https://scholar.google.com/scholar?q=Enforcing%20robust%20declassification)
[[DBLP]](https://dblp.org/search?q=Enforcing%20robust%20declassification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Enforcing%20robust%20declassification)
[[doi]](https://doi.org/10.1109/CSFW.2004.1310740)

Notes: 
[information flow](#information flow)\




[information flow]: #notes-information-flow
# Functional programs: Conversions between deep and shallow embeddings {#papers-myreen-itp-2012}


Magnus O. Myreen
Interactive Theorem Proving: Third International Conference, ITP 2012, Princeton, NJ, USA, August 13-15, 2012. Proceedings
Springer
Berlin, Heidelberg
Pages 412-417
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=Functional%20programs%3A%20Conversions%20between%20deep%20and%20shallow%20embeddings)
[[DBLP]](https://dblp.org/search?q=Functional%20programs%3A%20Conversions%20between%20deep%20and%20shallow%20embeddings)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Functional%20programs%3A%20Conversions%20between%20deep%20and%20shallow%20embeddings)
[[doi]](https://doi.org/10.1007/978-3-642-32347-8_29)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-32347-8)





# Verified LISP Implementations on ARM, x86 and PowerPC {#papers-myreen-tphols-2009}


Magnus O. Myreen, Michael J. C. Gordon
Theorem Proving in Higher Order Logics (TPHOLs)
Springer
Pages 359-374
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Verified%20LISP%20Implementations%20on%20ARM%2C%20x86%20and%20PowerPC)
[[DBLP]](https://dblp.org/search?q=Verified%20LISP%20Implementations%20on%20ARM%2C%20x86%20and%20PowerPC)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Verified%20LISP%20Implementations%20on%20ARM%2C%20x86%20and%20PowerPC)
[[doi]](https://doi.org/10.1007/978-3-642-03359-9_25)

Notes: 
[Arm architecture](#Arm architecture),
[x86 architecture](#x86 architecture),
[PowerPC architecture](#PowerPC architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture)\




[Arm architecture]: #notes-arm-architecture
[x86 architecture]: #notes-x86-architecture
[PowerPC architecture]: #notes-powerpc-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
# Abstractions from tests {#papers-naik-popl-2012}


Mayur Naik, Hongseok Yang, Ghila Castelnuovo, Mooly Sagiv
Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
POPL '12
Philadelphia, PA, USA
ACM
New York, NY, USA
Pages 373-386
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=Abstractions%20from%20tests)
[[DBLP]](https://dblp.org/search?q=Abstractions%20from%20tests)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Abstractions%20from%20tests)
[[doi]](https://doi.org/10.1145/2103656.2103701)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-1083-3)




# Ynot: Dependent types for imperative programs {#papers-nanevski-icfp-2008}


Aleksandar Nanevski, Greg Morrisett, Avraham Shinnar, Paul Govereau, Lars Birkedal
Proceedings of the 13th ACM SIGPLAN International Conference on Functional Programming
ICFP '08
Victoria, BC, Canada
Association for Computing Machinery
New York, NY, USA
Pages 229–240
2008
[[Google Scholar]](https://scholar.google.com/scholar?q=Ynot%3A%20Dependent%20types%20for%20imperative%20programs)
[[DBLP]](https://dblp.org/search?q=Ynot%3A%20Dependent%20types%20for%20imperative%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Ynot%3A%20Dependent%20types%20for%20imperative%20programs)
[[doi]](https://doi.org/10.1145/1411204.1411237)
[[ISBN]](http://books.google.com/books?vid=ISBN9781595939197)
[[url]](https://doi.org/10.1145/1411204.1411237)

Notes: 
[linear logic](#linear logic),
[dependent type](#dependent type),
[permission logic](#permission logic)\




[linear logic]: #notes-linear-logic
[dependent type]: #notes-dependent-type
[permission logic]: #notes-permission-logic
# Specifying concurrent programs in separation logic: Morphisms and simulations {#papers-nanevski-oopsla-2019}


Aleksandar Nanevski, Anindya Banerjee, Germán Andrés Delbianco, Ignacio Fábregas
Association for Computing Machinery
New York, NY, USA
October
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Specifying%20concurrent%20programs%20in%20separation%20logic%3A%20Morphisms%20and%20simulations)
[[DBLP]](https://dblp.org/search?q=Specifying%20concurrent%20programs%20in%20separation%20logic%3A%20Morphisms%20and%20simulations)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Specifying%20concurrent%20programs%20in%20separation%20logic%3A%20Morphisms%20and%20simulations)
[[doi]](https://doi.org/10.1145/3360587)
[[url]](https://doi.org/10.1145/3360587)

Notes: 
[dependent type](#dependent type),
[permission logic](#permission logic),
[separation logic](#separation logic)\




[dependent type]: #notes-dependent-type
[permission logic]: #notes-permission-logic
[separation logic]: #notes-separation-logic
# RedLeaf: Towards an operating system for safe and verified firmware {#papers-narayanan-hotos-2019}


Vikram Narayanan, Marek S. Baranowski, Leonid Ryzhyk, Zvonimir Rakamarić, Anton Burtsev
Proceedings of the Workshop on Hot Topics in Operating Systems
ACM
Pages 37-44
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=RedLeaf%3A%20Towards%20an%20operating%20system%20for%20safe%20and%20verified%20firmware)
[[DBLP]](https://dblp.org/search?q=RedLeaf%3A%20Towards%20an%20operating%20system%20for%20safe%20and%20verified%20firmware)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=RedLeaf%3A%20Towards%20an%20operating%20system%20for%20safe%20and%20verified%20firmware)
[[doi]](https://doi.org/10.1145/3317550.3321449)

Notes: 
[Rust language](#Rust language)\




[Rust language]: #notes-rust-language
# Assertion-based encapsulation, object invariants and simulations {#papers-naumann-fmco-2004}


David A. Naumann
Formal Methods for Components and Objects
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 251-273
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=Assertion-based%20encapsulation%2C%20object%20invariants%20and%20simulations)
[[DBLP]](https://dblp.org/search?q=Assertion-based%20encapsulation%2C%20object%20invariants%20and%20simulations)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Assertion-based%20encapsulation%2C%20object%20invariants%20and%20simulations)
[[doi]](https://doi.org/10.1007/11561163_11)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-31939-9)





# CIL: Intermediate language and tools for analysis and transformation of C programs {#papers-necula-cc-2002}


George C. Necula, Scott McPeak, Shree P. Rahul, Westley Weimer
Compiler Construction
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 213-228
2002
[[Google Scholar]](https://scholar.google.com/scholar?q=CIL%3A%20Intermediate%20language%20and%20tools%20for%20analysis%20and%20transformation%20of%20C%20programs)
[[DBLP]](https://dblp.org/search?q=CIL%3A%20Intermediate%20language%20and%20tools%20for%20analysis%20and%20transformation%20of%20C%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=CIL%3A%20Intermediate%20language%20and%20tools%20for%20analysis%20and%20transformation%20of%20C%20programs)
[[doi]](https://doi.org/10.1007/3-540-45937-5_16)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-45937-8)

Notes: 
[CIL tool](#CIL tool)\
Referenced by: 
[papers/henzinger:spin:2003](#papers-henzinger-spin-2003),
[notes/blast-verifier](#notes-blast-verifier),
[notes/cil-tool](#notes-cil-tool),
[notes/cpachecker-verifier](#notes-cpachecker-verifier)\



[CIL tool]: #notes-cil-tool
# Translation validation for an optimizing compiler {#papers-necula-pldi-2000}


George C. Necula
Proceedings of the ACM SIGPLAN 2000 Conference on Programming Language Design and Implementation
PLDI '00
Vancouver, British Columbia, Canada
ACM
Pages 83-94
2000
[[Google Scholar]](https://scholar.google.com/scholar?q=Translation%20validation%20for%20an%20optimizing%20compiler)
[[DBLP]](https://dblp.org/search?q=Translation%20validation%20for%20an%20optimizing%20compiler)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Translation%20validation%20for%20an%20optimizing%20compiler)
[[doi]](https://doi.org/10.1145/349299.349314)
[[ISBN]](http://books.google.com/books?vid=ISBN1-58113-199-2)

Notes: 
[translation validation](#translation validation)\
Papers: 
[pnueli:tacas:1998](#pnueli-tacas-1998)\
Referenced by: 
[notes/translation-validation](#notes-translation-validation)\




[translation validation]: #notes-translation-validation
[pnueli:tacas:1998]: #papers-pnueli-tacas-1998
# Proof-carrying code {#papers-necula-popl-1997}


George C. Necula
Proceedings of the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
POPL '97
Paris, France
Association for Computing Machinery
New York, NY, USA
Pages 106-119
1997
[[Google Scholar]](https://scholar.google.com/scholar?q=Proof-carrying%20code)
[[DBLP]](https://dblp.org/search?q=Proof-carrying%20code)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Proof-carrying%20code)
[[doi]](https://doi.org/10.1145/263699.263712)
[[ISBN]](http://books.google.com/books?vid=ISBN0897918533)
[[url]](https://doi.org/10.1145/263699.263712)

Notes: 
[proof carrying code](#proof carrying code)\
Referenced by: 
[notes/proof-carrying-code](#notes-proof-carrying-code)\




[proof carrying code]: #notes-proof-carrying-code
# Hyperkernel: Push-button verification of an OS kernel {#papers-nelson-sosp-2017}


Luke Nelson, Helgi Sigurbjarnarson, Kaiyuan Zhang, Dylan Johnson, James Bornholt, Emina Torlak, Xi Wang
Proceedings of the 26th Symposium on Operating Systems Principles
ACM
Pages 252-269
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=Hyperkernel%3A%20Push-button%20verification%20of%20an%20OS%20kernel)
[[DBLP]](https://dblp.org/search?q=Hyperkernel%3A%20Push-button%20verification%20of%20an%20OS%20kernel)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Hyperkernel%3A%20Push-button%20verification%20of%20an%20OS%20kernel)
[[doi]](https://doi.org/10.1145/3132747.3132748)

Referenced by: 
[papers/nelson:sosp:2019](#papers-nelson-sosp-2019)\




# Scaling symbolic evaluation for automated verification of systems code with Serval {#papers-nelson-sosp-2019}


Luke Nelson, James Bornholt, Ronghui Gu, Andrew Baumann, Emina Torlak, Xi Wang
Proceedings of the 27th ACM Symposium on Operating Systems Principles (SOSP)
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Scaling%20symbolic%20evaluation%20for%20automated%20verification%20of%20systems%20code%20with%20Serval)
[[DBLP]](https://dblp.org/search?q=Scaling%20symbolic%20evaluation%20for%20automated%20verification%20of%20systems%20code%20with%20Serval)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Scaling%20symbolic%20evaluation%20for%20automated%20verification%20of%20systems%20code%20with%20Serval)
[[doi]](https://doi.org/10.1145/3341301.3359641)

Notes: 
[information flow](#information flow),
[Rosette solver](#Rosette solver),
[LLVM compiler](#LLVM compiler),
[RISCV architecture](#RISCV architecture),
[symbolic evaluation](#symbolic evaluation)\
Papers: 
[nelson:sosp:2017](#nelson-sosp-2017),
[sigurbjarnarson:osdi:2016](#sigurbjarnarson-osdi-2016),
[sigurbjarnarson:osdi:2018](#sigurbjarnarson-osdi-2018),
[demoura:tacas:2008](#demoura-tacas-2008),
[torlak:pldi:2014](#torlak-pldi-2014)\
Referenced by: 
[papers/ferraiuolo:sosp:2017](#papers-ferraiuolo-sosp-2017),
[papers/torlak:pldi:2014](#papers-torlak-pldi-2014),
[notes/auto-active-verification](#notes-auto-active-verification),
[notes/bounded-model-checking](#notes-bounded-model-checking),
[notes/non-interference](#notes-non-interference),
[notes/rosette-solver](#notes-rosette-solver),
[notes/symbolic-evaluation](#notes-symbolic-evaluation),
[notes/symbolic-execution](#notes-symbolic-execution)\


This paper continues the theme of "push-button automation" from the UNSAT group's earlier work on
[Hyperkernel][nelson:sosp:2017],
[Yggadrisil][sigurbjarnarson:osdi:2016]
and [Nickel][sigurbjarnarson:osdi:2018].
Like the earlier work, they are using the [Z3 SMT solver][demoura:tacas:2008] to verify systems code automatically 
and they are avoiding adding annotations ("auto-active verification") to help the verification 
by restricting the code they verify to "finite interfaces" so that all loops are bounded.
The big difference is that the earlier works wrote specifications in Python using the Z3Py library whereas this paper uses
[Rosette][torlak:pldi:2014]'s symbolic execution support.

They demonstrate the approach by porting Komodo and CertiKOS to RISC-V, rewriting the specs in Serval and reverifying their functional correctness and security properties on the binaries.  This process took an impressive 4 person-weeks each!
In addition, they created partial specifications of Linux BPF and the Keystone TEE and found bugs both in the artifacts they were verifying and in processors and other RISC-V specs.
(They also reveal that the CertiKOS verification excluded verification of the ELF loader.  Interesting omission.)

The basic idea in Serval is to write an interpreter for an instruction set (eg RISC-V, BPF, ...) and then lift this interpreter to create a symbolic execution engine (requires some annotations and performance tuning).  This symbolic execution engine generates SMT that is fed to Z3. Serval includes libraries for specifying non-interference and state-machine refinement.

Serval is impressively small: 4400 lines for Serval + RISC-V (subset) + x86-32 (subset) + LLVM (subset) + BPF.  That is tiny!



[information flow]: #notes-information-flow
[Rosette solver]: #notes-rosette-solver
[LLVM compiler]: #notes-llvm-compiler
[RISCV architecture]: #notes-riscv-architecture
[symbolic evaluation]: #notes-symbolic-evaluation
[nelson:sosp:2017]: #papers-nelson-sosp-2017
[sigurbjarnarson:osdi:2016]: #papers-sigurbjarnarson-osdi-2016
[sigurbjarnarson:osdi:2018]: #papers-sigurbjarnarson-osdi-2018
[demoura:tacas:2008]: #papers-demoura-tacas-2008
[torlak:pldi:2014]: #papers-torlak-pldi-2014
# Boolector 2.0 {#papers-niemetz-jsat-2015}


Aina Niemetz, Mathias Preiner, Armin Biere
Pages 53-58
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=Boolector%202.0)
[[DBLP]](https://dblp.org/search?q=Boolector%202.0)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Boolector%202.0)
[[doi]](https://doi.org/10.3233/SAT190101)
[[url]](https://satassociation.org/jsat/index.php/jsat/article/view/120)

Notes: 
[SMT solver](#SMT solver)\




[SMT solver]: #notes-smt-solver
# Rigorous engineering for hardware security: Formal modelling and proof in the CHERI design and implementation process {#papers-nienhuis-secpriv-2020}


Kyndylan Nienhuis, Alexandre Joannou, Thomas Bauereiss, Anthony C. J. Fox, Michael Roe, Brian Campbell, Matthew Naylor, Robert M. Norton, Simon W. Moore, Peter G. Neumann, Ian Stark, Robert N. M. Watson, Peter Sewell
2020 IEEE Symposium on Security and Privacy (SP)
IEEE Computer Society
Los Alamitos, CA, USA
Pages 1007-1024
May
2020
[[Google Scholar]](https://scholar.google.com/scholar?q=Rigorous%20engineering%20for%20hardware%20security%3A%20Formal%20modelling%20and%20proof%20in%20the%20CHERI%20design%20and%20implementation%20process)
[[DBLP]](https://dblp.org/search?q=Rigorous%20engineering%20for%20hardware%20security%3A%20Formal%20modelling%20and%20proof%20in%20the%20CHERI%20design%20and%20implementation%20process)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Rigorous%20engineering%20for%20hardware%20security%3A%20Formal%20modelling%20and%20proof%20in%20the%20CHERI%20design%20and%20implementation%20process)
[[doi]](https://doi.org/10.1109/SP40000.2020.00055)
[[url]](https://doi.ieeecomputersociety.org/10.1109/SP40000.2020.00055)

Notes: 
[CHERI architecture](#CHERI architecture),
[capabilities](#capabilities)\
Papers: 
[woodruff:isca:2014](#woodruff-isca-2014),
[skorstengaard:popl:2019](#skorstengaard-popl-2019),
[skorstengaard:esop:2018](#skorstengaard-esop-2018)\
Referenced by: 
[papers/woodruff:isca:2014](#papers-woodruff-isca-2014),
[notes/capabilities](#notes-capabilities),
[notes/cheri-architecture](#notes-cheri-architecture)\



[CHERI architecture]: #notes-cheri-architecture
[capabilities]: #notes-capabilities
[woodruff:isca:2014]: #papers-woodruff-isca-2014
[skorstengaard:popl:2019]: #papers-skorstengaard-popl-2019
[skorstengaard:esop:2018]: #papers-skorstengaard-esop-2018
# Isabelle/HOL: A proof assistant for higher-order logic {#papers-nipkow-book-2002}


Tobias Nipkow, Markus Wenzel, Lawrence C. Paulson
Springer-Verlag
Berlin, Heidelberg
2002
[[Google Scholar]](https://scholar.google.com/scholar?q=Isabelle/HOL%3A%20A%20proof%20assistant%20for%20higher-order%20logic)
[[DBLP]](https://dblp.org/search?q=Isabelle/HOL%3A%20A%20proof%20assistant%20for%20higher-order%20logic)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Isabelle/HOL%3A%20A%20proof%20assistant%20for%20higher-order%20logic)
[[doi]](https://doi.org/10.1007/3-540-45949-9)
[[ISBN]](http://books.google.com/books?vid=ISBN3-540-43376-7)

Notes: 
[interactive theorem prover](#interactive theorem prover)\




[interactive theorem prover]: #notes-interactive-theorem-prover
# Polymorphic type inference for machine code {#papers-noonan-pldi-2016}


Matt Noonan, Alexey Loginov, David R. Cok
Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation
PLDI '16
Santa Barbara, CA, USA
Association for Computing Machinery
New York, NY, USA
Pages 27-41
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Polymorphic%20type%20inference%20for%20machine%20code)
[[DBLP]](https://dblp.org/search?q=Polymorphic%20type%20inference%20for%20machine%20code)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Polymorphic%20type%20inference%20for%20machine%20code)
[[doi]](https://doi.org/10.1145/2908080.2908119)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450342612)
[[url]](https://doi.org/10.1145/2908080.2908119)

Notes: 
[binary analysis](#binary analysis),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture)\



[binary analysis]: #notes-binary-analysis
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
# Benchmarking solvers, SAT-style {#papers-nyxbrain-sc2-2017}


Martin Nyx Brain, James H. Davenport, Alberto Griggio
Proceedings of the 2nd International Workshop on Satisfiability Checking and Symbolic Computation (SC-Square 2017)
July
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=Benchmarking%20solvers%2C%20SAT-style)
[[DBLP]](https://dblp.org/search?q=Benchmarking%20solvers%2C%20SAT-style)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Benchmarking%20solvers%2C%20SAT-style)
[[url]](http://ceur-ws.org/Vol-1974/)

Notes: 
[verification competition](#verification competition)\



Written as an encouragement to the computer algebra community to create
a [verification competition].  It explains why [verification competition]s are
designed the way they are.  It also has an analysis of how improving time to
solve affects scores where improvements might be shaving a second off the time,
adding parallelism, random variations in time, etc.



[verification competition]: #notes-verification-competition
# Theoretical analysis of gate level information flow tracking {#papers-oberg-dac-2010}


Jason Oberg, Wei Hu, Ali Irturk, Mohit Tiwari, Timothy Sherwood, Ryan Kastner
Proceedings of the 47th Design Automation Conference
ACM
Pages 244-247
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=Theoretical%20analysis%20of%20gate%20level%20information%20flow%20tracking)
[[DBLP]](https://dblp.org/search?q=Theoretical%20analysis%20of%20gate%20level%20information%20flow%20tracking)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Theoretical%20analysis%20of%20gate%20level%20information%20flow%20tracking)
[[doi]](https://doi.org/10.1145/1837274.1837337)

Notes: 
[information flow](#information flow)\


GLIFT (Gate Level Information Flow Tracking) calculates a precise "taint" bit for every signal indicating whether the signal depends on some input signals.  GLIFT is added by calculating taint for each primitive gate type (and, or, XOR, not) with an assumption of linearity.  This paper looks at how the number of midterms grows with circuit complexity for 1-8 bit adder, multiplier, comparator, shifter and multiplexer.  All costs are exponential and quite high.

Questions: Can linearity assumption be justified?  Is number of midterms the right metric?



[information flow]: #notes-information-flow
# Separation logic {#papers-ohearn-cacm-2019}


Peter W. O'Hearn
Association for Computing Machinery
New York, NY, USA
Pages 86-95
January
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Separation%20logic)
[[DBLP]](https://dblp.org/search?q=Separation%20logic)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Separation%20logic)
[[doi]](https://doi.org/10.1145/3211968)
[[url]](https://doi.org/10.1145/3211968)

Notes: 
[separation logic](#separation logic),
[permission logic](#permission logic),
[concurrent-separation logic](#concurrent-separation logic),
[survey](#survey)\
Papers: 
[reynolds:lics:2002](#reynolds-lics-2002)\
Referenced by: 
[papers/astrauskas:oopsla:2019](#papers-astrauskas-oopsla-2019),
[papers/smans:ecoop:2009](#papers-smans-ecoop-2009)\


This survey paper updates
[Reynolds 2002 survey of Separation Logic][reynolds:lics:2002]
with an overview of the developments, applications
and extensions in Separation Logic and
Concurrent Separation Logic over the last
20 years.

If you want an overview of the development of Separation Logic,
this paper is a good one.
(If you want more detail of the basics, Reynolds has more
worked examples.)



[separation logic]: #notes-separation-logic
[permission logic]: #notes-permission-logic
[concurrent-separation logic]: #notes-concurrent-separation-logic
[survey]: #notes-survey
[reynolds:lics:2002]: #papers-reynolds-lics-2002
# Resources, concurrency, and local reasoning {#papers-ohearn-tcs-2007}


Peter W. O'Hearn
Elsevier
Pages 271-307
2007
[[Google Scholar]](https://scholar.google.com/scholar?q=Resources%2C%20concurrency%2C%20and%20local%20reasoning)
[[DBLP]](https://dblp.org/search?q=Resources%2C%20concurrency%2C%20and%20local%20reasoning)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Resources%2C%20concurrency%2C%20and%20local%20reasoning)

Notes: 
[permission logic](#permission logic),
[concurrent separation logic](#concurrent separation logic),
[separation logic](#separation logic)\




[permission logic]: #notes-permission-logic
[concurrent separation logic]: #notes-concurrent-separation-logic
[separation logic]: #notes-separation-logic
# Why threads are a bad idea (for most purposes) (Invited talk) {#papers-ousterhout-usenix-1996}


John Ousterhout
USENIX 1996 Technical Conference
June
1996
[[Google Scholar]](https://scholar.google.com/scholar?q=Why%20threads%20are%20a%20bad%20idea%20%28for%20most%20purposes%29%20%28Invited%20talk%29)
[[DBLP]](https://dblp.org/search?q=Why%20threads%20are%20a%20bad%20idea%20%28for%20most%20purposes%29%20%28Invited%20talk%29)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Why%20threads%20are%20a%20bad%20idea%20%28for%20most%20purposes%29%20%28Invited%20talk%29)

Notes: 
[threads](#threads)\
Referenced by: 
[notes/events](#notes-events),
[notes/threads](#notes-threads)\



[threads]: #notes-threads
# Low-cost techniques for reducing branch context pollution in a soft realtime embedded multithreaded processor {#papers-ozer-sbacpad-2007}


Emre Özer, Alastair D. Reid, Stuart Biles
19th Symposium on Computer Architecture and High Performance Computing (SBAC-PAD 2007)
Gramado, RS, Brazil
IEEE Computer Society
Pages 37-44
24-27
October
2007
[[Google Scholar]](https://scholar.google.com/scholar?q=Low-cost%20techniques%20for%20reducing%20branch%20context%20pollution%20in%20a%20soft%20realtime%20embedded%20multithreaded%20processor)
[[DBLP]](https://dblp.org/search?q=Low-cost%20techniques%20for%20reducing%20branch%20context%20pollution%20in%20a%20soft%20realtime%20embedded%20multithreaded%20processor)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Low-cost%20techniques%20for%20reducing%20branch%20context%20pollution%20in%20a%20soft%20realtime%20embedded%20multithreaded%20processor)
[[doi]](https://doi.org/10.1109/SBAC-PAD.2007.15)

Notes: 
[threads](#threads)\




[threads]: #notes-threads
# Decoupling integer execution in superscalar processors {#papers-palacharla-micro-1995}


Subbarao Palacharla, James E. Smith
MICRO 28: Proceedings of International Symposium on Microarchitecture
Ann Arbor, Michigan, United States
Pages 285-290
1995
[[Google Scholar]](https://scholar.google.com/scholar?q=Decoupling%20integer%20execution%20in%20superscalar%20processors)
[[DBLP]](https://dblp.org/search?q=Decoupling%20integer%20execution%20in%20superscalar%20processors)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Decoupling%20integer%20execution%20in%20superscalar%20processors)
[[doi]](https://doi.org/10.1109/MICRO.1995.476836)
[[ISBN]](http://books.google.com/books?vid=ISBN0-8186-7349-4)

Notes: 
[pipeline parallelism](#pipeline parallelism),
[decoupling](#decoupling),
[microarchitecture](#microarchitecture),
[CRAY architecture](#CRAY architecture)\
Referenced by: 
[notes/decoupling](#notes-decoupling)\



[pipeline parallelism]: #notes-pipeline-parallelism
[decoupling]: #notes-decoupling
[microarchitecture]: #notes-microarchitecture
[CRAY architecture]: #notes-cray-architecture
# Separation logic and abstraction {#papers-parkinson-popl-2005}


Matthew Parkinson, Gavin Bierman
Association for Computing Machinery
New York, NY, USA
Pages 247-258
January
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=Separation%20logic%20and%20abstraction)
[[DBLP]](https://dblp.org/search?q=Separation%20logic%20and%20abstraction)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Separation%20logic%20and%20abstraction)
[[doi]](https://doi.org/10.1145/1047659.1040326)
[[url]](https://doi.org/10.1145/1047659.1040326)

Notes: 
[permission logic](#permission logic),
[separation logic](#separation logic)\
Referenced by: 
[papers/berdine:fmco:2005](#papers-berdine-fmco-2005)\


This paper tackles three problems:

- Supporting user-defined predicates in separation logic,
  adding OPEN and CLOSE rules to unfold and fold
  their definitions.

- Placing restrictions on where OPEN/CLOSE can be used
  in order to enforce data abstractions.

- Generalizing abstract predicates to support object-oriented
  languages by adding abstract predicate families that can be
  indexed by the class.

There are a number of examples manually proved in this paper.



[permission logic]: #notes-permission-logic
[separation logic]: #notes-separation-logic
# Reduced instruction set computers {#papers-patterson-cacm-1985}


David A. Patterson
ACM
New York, NY, USA
Pages 8-21
January
1985
[[Google Scholar]](https://scholar.google.com/scholar?q=Reduced%20instruction%20set%20computers)
[[DBLP]](https://dblp.org/search?q=Reduced%20instruction%20set%20computers)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Reduced%20instruction%20set%20computers)
[[doi]](https://doi.org/10.1145/2465.214917)

Notes: 
[RISC architecture](#RISC architecture),
[instruction set architecture](#instruction set architecture)\
Referenced by: 
[notes/risc-architecture](#notes-risc-architecture)\



[RISC architecture]: #notes-risc-architecture
[instruction set architecture]: #notes-instruction-set-architecture
# The case for the reduced instruction set computer {#papers-patterson-sigarch-1980}


David A. Patterson, David R. Ditzel
ACM
New York, NY, USA
Pages 25-33
October
1980
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20case%20for%20the%20reduced%20instruction%20set%20computer)
[[DBLP]](https://dblp.org/search?q=The%20case%20for%20the%20reduced%20instruction%20set%20computer)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20case%20for%20the%20reduced%20instruction%20set%20computer)
[[doi]](https://doi.org/10.1145/641914.641917)

Notes: 
[RISC architecture](#RISC architecture),
[instruction set architecture](#instruction set architecture)\
Referenced by: 
[notes/risc-architecture](#notes-risc-architecture)\



[RISC architecture]: #notes-risc-architecture
[instruction set architecture]: #notes-instruction-set-architecture
# PDP-11/45 processor handbook {#papers-pdp11-book-1973}


Digital Equipment Corporation
Digital Equipment Corporation
1973
[[Google Scholar]](https://scholar.google.com/scholar?q=PDP-11/45%20processor%20handbook)
[[DBLP]](https://dblp.org/search?q=PDP-11/45%20processor%20handbook)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=PDP-11/45%20processor%20handbook)

Notes: 
[instruction set architecture](#instruction set architecture),
[ISA specification](#ISA specification),
[PDP11 architecture](#PDP11 architecture),
[ISPS](#ISPS)\



[instruction set architecture]: #notes-instruction-set-architecture
[ISA specification]: #notes-isa-specification
[PDP11 architecture]: #notes-pdp11-architecture
[ISPS]: #notes-isps
# Virtualization: Issues, security threats, and solutions {#papers-pearce-compsurv-2013}


Michael Pearce, Sherali Zeadally, Ray Hunt
ACM
New York, NY, USA
Pages 17:1-17:39
March
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Virtualization%3A%20Issues%2C%20security%20threats%2C%20and%20solutions)
[[DBLP]](https://dblp.org/search?q=Virtualization%3A%20Issues%2C%20security%20threats%2C%20and%20solutions)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Virtualization%3A%20Issues%2C%20security%20threats%2C%20and%20solutions)
[[doi]](https://doi.org/10.1145/2431211.2431216)
[[url]](http://doi.acm.org/10.1145/2431211.2431216)





# MMX technology extension to the Intel architecture {#papers-peleg-micro-1996}


Alex Peleg, Uri Weiser
IEEE Computer Society Press
Los Alamitos, CA, USA
Pages 42-50
August
1996
[[Google Scholar]](https://scholar.google.com/scholar?q=MMX%20technology%20extension%20to%20the%20Intel%20architecture)
[[DBLP]](https://dblp.org/search?q=MMX%20technology%20extension%20to%20the%20Intel%20architecture)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=MMX%20technology%20extension%20to%20the%20Intel%20architecture)
[[doi]](https://doi.org/10.1109/40.526924)

Notes: 
[x86 architecture](#x86 architecture),
[instruction set architecture](#instruction set architecture),
[vector architecture](#vector architecture)\



[x86 architecture]: #notes-x86-architecture
[instruction set architecture]: #notes-instruction-set-architecture
[vector architecture]: #notes-vector-architecture
# Sound formal verification of Linux's USB BP keyboard driver {#papers-penninckx-nfm-2012}


Willem Penninckx, Jan Tobias Mühlberg, Jan Smans, Bart Jacobs, Frank Piessens
NASA Formal Methods
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 210-215
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=Sound%20formal%20verification%20of%20Linux%27s%20USB%20BP%20keyboard%20driver)
[[DBLP]](https://dblp.org/search?q=Sound%20formal%20verification%20of%20Linux%27s%20USB%20BP%20keyboard%20driver)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Sound%20formal%20verification%20of%20Linux%27s%20USB%20BP%20keyboard%20driver)
[[doi]](https://doi.org/10.1007/978-3-642-28891-3_21)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-28891-3)

Notes: 
[permission logic](#permission logic),
[separation logic](#separation logic),
[concurrent-separation logic](#concurrent-separation logic),
[VeriFast verifier](#VeriFast verifier)\
Referenced by: 
[papers/philippaerts:scp:2014](#papers-philippaerts-scp-2014),
[notes/verifast-verifier](#notes-verifast-verifier)\


This paper reports on verification of a simple Linux USB
keyboard driver using
[VeriFast](https://github.com/verifast/verifast).
Except, of course, Linux drivers are not simple:
they have asynchronous callbacks, dynamically allocated
memory, synchronization and interact with complex
Linux driver APIs including USB, input and spinlocks.
This work found bugs in the driver and the fixes have been
accepted by the maintainer.

The properties verified include freedom of data races,
freedom of illegal memory accesses and correct API
usage.
(Though, as they point out themselves, the API spec could have
bugs.)

The driver is 426 lines long, of which there are 329 lines of
non-blank, non-comment code.
To this, they add 769 lines of reusable API specifications
and 53 lines of annotation (or maybe it is 822 lines – it
is not clear whether the 822 lines of annotations includes the 769 lines of spec
or not).
Verification takes about 1 second.

They report that some of the concurrency patterns
involved in LED handling was tricky to verify and
required the introduction of "ghost counters".
They also had to reason about permissions passed between
callbacks.






[permission logic]: #notes-permission-logic
[separation logic]: #notes-separation-logic
[concurrent-separation logic]: #notes-concurrent-separation-logic
[VeriFast verifier]: #notes-verifast-verifier
# Adding records to Haskell {#papers-peterson-hw-1995}


John Peterson, Alastair D. Reid
Proceedings of the Haskell Workshop 1995, Yale University Research Report YALE/DCS/RR-1075
Portland, Oregon, USA
1995
[[Google Scholar]](https://scholar.google.com/scholar?q=Adding%20records%20to%20Haskell)
[[DBLP]](https://dblp.org/search?q=Adding%20records%20to%20Haskell)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Adding%20records%20to%20Haskell)
[[url]](https://www.haskell.org/haskell-workshop/1995/HW1995-Proceedings.pdf)

Notes: 
[Haskell language](#Haskell language)\




[Haskell language]: #notes-haskell-language
# FVision: A declarative language for visual tracking {#papers-peterson-padl-2001}


John Peterson, Paul Hudak, Alastair D. Reid, Gregory D. Hager
Practical Aspects of Declarative Languages, Third International Symposium (PADL 2001)
Lecture Notes in Computer Science, volume 1990
Las Vegas, Nevada, USA
Springer
Pages 304-321
11-12
March
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=FVision%3A%20A%20declarative%20language%20for%20visual%20tracking)
[[DBLP]](https://dblp.org/search?q=FVision%3A%20A%20declarative%20language%20for%20visual%20tracking)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=FVision%3A%20A%20declarative%20language%20for%20visual%20tracking)
[[doi]](https://doi.org/10.1007/3-540-45241-9_21)

Notes: 
[Haskell language](#Haskell language),
[Functional Reactive Programming](#Functional Reactive Programming),
[Domain Specific Language](#Domain Specific Language)\




[Haskell language]: #notes-haskell-language
[Functional Reactive Programming]: #notes-functional-reactive-programming
[Domain Specific Language]: #notes-domain-specific-language
# Software verification with VeriFast: Industrial case studies {#papers-philippaerts-scp-2014}


Pieter Philippaerts, Jan Tobias Mühlberg, Willem Penninckx, Jan Smans, Bart Jacobs, Frank Piessens
North-Holland Pub. Co.
Pages 77-97
3
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=Software%20verification%20with%20VeriFast%3A%20Industrial%20case%20studies)
[[DBLP]](https://dblp.org/search?q=Software%20verification%20with%20VeriFast%3A%20Industrial%20case%20studies)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Software%20verification%20with%20VeriFast%3A%20Industrial%20case%20studies)
[[doi]](https://doi.org/10.1016/j.scico.2013.01.006)
[[url]](https://lirias.kuleuven.be/95711)

Notes: 
[permission logic](#permission logic),
[separation logic](#separation logic),
[VeriFast verifier](#VeriFast verifier)\
Papers: 
[jacobs:nfm:2011](#jacobs-nfm-2011),
[penninckx:nfm:2012](#penninckx-nfm-2012),
[filliatre:fem:2004](#filliatre-fem-2004),
[vogels:fmoods:2011](#vogels-fmoods-2011),
[cohen:cav:2010](#cohen-cav-2010)\
Referenced by: 
[papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011),
[notes/verifast-verifier](#notes-verifast-verifier)\


This paper reports on four case studies using
[VeriFast][jacobs:nfm:2011]
to verify real code for an absence of safety violations
such as illegal memory accesses or data races.

The paper starts with a very nice overview of the features
of VeriFast and then describes the four case studies

- eID (Java)
  The Belgian Electronic Identity Card.
- PEP (C)
  Embedded Linux Network Management Software.
- USB BP (C)
  The Linux USB BP Keyboard Driver
  (brief description because it has been described
  [elsewhere][penninckx:nfm:2012])
- SECURECHANGE (Java)
  (brief description because it has been described elsewhere)

An interesting thing found in the SECURECHANGE study was that,
despite previously having been verified using [Why/Krakatoa/Caduceus][filliatre:fem:2004]
bugs were found.
They say "Clearly, the tool used earlier was not sound or was not
used in a sound way."

This kind of case study paper is really useful because it gives some
insight into how to tackle an unverified piece of code.

- Start by adding pre/post-conditions of true/true to all functions.
  (This will gradually flush out some more realistic conditions.
- Create specifications of all the libraries used.
  One technique used was to use "gcc -E" to make a header file
  for all the system library imports and delete everything that
  is not used.
- Delay handling threads by initially specifying that
  "pthread_create" immediately calls its function argument
  and runs it until it terminates.

This was also useful because they document the amount of
annotation required in each case.

| Program      |  Language | loc   |  annotations | overhead | #bugs |
|:------------ | :-------- | ----: | -----------: | -------: | ----: |
| eID          |  Java     | 1004  | 684          | 68%      | 38    |
| SECURECHANGE |  Java     |  251  | 205          | 80%      | some  |
| PEP          |  C        |  429  | 450          | 105%     | 41    |
| USB BP       |  C        |  329  | 822          | 250%     | ?     |

Note that they also did some work on
[annotation inference][vogels:fmoods:2011]
and I don't think all the data reflects those improvements.
In the related work section, they suggest that other tools
such as
[VCC][cohen:cav:2010]
would not need as much annotation but at the expense of
less predictable search time.



[permission logic]: #notes-permission-logic
[separation logic]: #notes-separation-logic
[VeriFast verifier]: #notes-verifast-verifier
[jacobs:nfm:2011]: #papers-jacobs-nfm-2011
[penninckx:nfm:2012]: #papers-penninckx-nfm-2012
[filliatre:fem:2004]: #papers-filliatre-fem-2004
[vogels:fmoods:2011]: #papers-vogels-fmoods-2011
[cohen:cav:2010]: #papers-cohen-cav-2010
# Software foundations {#papers-pierce-book-2016}


Benjamin C. Pierce, Arthur Azevedo de Amorim, Chris Casinghino, Marco Gaboardi, Michael Greenberg, Cătǎlin Hriţcu, Vilhelm Sjöberg, Brent Yorgey
Electronic textbook
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Software%20foundations)
[[DBLP]](https://dblp.org/search?q=Software%20foundations)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Software%20foundations)
[[url]](http://www.cis.upenn.edu/~bcpierce/sf)

Notes: 
[Coq theorem prover](#Coq theorem prover)\



[Coq theorem prover]: #notes-coq-theorem-prover
# The temporal logic of programs {#papers-pnueli-sfcs-1977}


Amir Pnueli
18th Annual Symposium on Foundations of Computer Science (sfcs 1977)
Pages 46-57
Oct
1977
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20temporal%20logic%20of%20programs)
[[DBLP]](https://dblp.org/search?q=The%20temporal%20logic%20of%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20temporal%20logic%20of%20programs)
[[doi]](https://doi.org/10.1109/SFCS.1977.32)

Notes: 
[temporal logic](#temporal logic),
[model checking](#model checking)\
Referenced by: 
[notes/temporal-logic](#notes-temporal-logic)\



[temporal logic]: #notes-temporal-logic
[model checking]: #notes-model-checking
# Translation validation {#papers-pnueli-tacas-1998}


Amir Pnueli, Michael Siegel, Eli Singerman
Tools and Algorithms for the Construction and Analysis of Systems
Springer
Pages 151-166
1998
[[Google Scholar]](https://scholar.google.com/scholar?q=Translation%20validation)
[[DBLP]](https://dblp.org/search?q=Translation%20validation)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Translation%20validation)
[[doi]](https://doi.org/10.1007/BFb0054170)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-69753-4)

Notes: 
[translation validation](#translation validation)\
Referenced by: 
[papers/necula:pldi:2000](#papers-necula-pldi-2000),
[notes/translation-validation](#notes-translation-validation)\




[translation validation]: #notes-translation-validation
# Why Google stores billions of lines of code in a single repository {#papers-potvin-cacm-2016}


Rachel Potvin, Josh Levenberg
Association for Computing Machinery
New York, NY, USA
Pages 78-87
June
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Why%20Google%20stores%20billions%20of%20lines%20of%20code%20in%20a%20single%20repository)
[[DBLP]](https://dblp.org/search?q=Why%20Google%20stores%20billions%20of%20lines%20of%20code%20in%20a%20single%20repository)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Why%20Google%20stores%20billions%20of%20lines%20of%20code%20in%20a%20single%20repository)
[[doi]](https://doi.org/10.1145/2854146)
[[url]](https://doi.org/10.1145/2854146)

Notes: 
[google papers](#google papers),
[google infrastructure](#google infrastructure)\



[google papers]: #notes-google-papers
[google infrastructure]: #notes-google-infrastructure
# SMACK: Decoupling source language details from verifier implementations {#papers-rakamaric-cav-2014}


Zvonimir Rakamarić, Michael Emmi
International Conference on Computer Aided Verification
Springer
Pages 106-113
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=SMACK%3A%20Decoupling%20source%20language%20details%20from%20verifier%20implementations)
[[DBLP]](https://dblp.org/search?q=SMACK%3A%20Decoupling%20source%20language%20details%20from%20verifier%20implementations)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=SMACK%3A%20Decoupling%20source%20language%20details%20from%20verifier%20implementations)
[[doi]](https://doi.org/10.1007/978-3-319-08867-9_7)

Notes: 
[Boogie verifier](#Boogie verifier),
[intermediate verification language](#intermediate verification language),
[SMACK verifier](#SMACK verifier),
[LLVM compiler](#LLVM compiler)\
Referenced by: 
[papers/almeida:security:2016](#papers-almeida-security-2016),
[papers/baranowski:atva:2018](#papers-baranowski-atva-2018),
[papers/barnett:fmco:2005](#papers-barnett-fmco-2005),
[notes/smack-verifier](#notes-smack-verifier)\


SMACK translates LLVM bitcode files to the [Boogie language][Boogie verifier]
(an [intermediate verification language])
allowing it to support any language that LLVM supports (mostly C/C++ in this
paper).

SMACK implements one key optimization: using alias analysis to partition the
heap (and pointers into the heap) so that objects that could not be confused
are in separate sub-heaps.



[Boogie verifier]: #notes-boogie-verifier
[intermediate verification language]: #notes-intermediate-verification-language
[SMACK verifier]: #notes-smack-verifier
[LLVM compiler]: #notes-llvm-compiler
# Machine descriptions to build tools for embedded systems {#papers-ramsey-lctes-1998}


Norman Ramsey, Jack W. Davidson
Languages, Compilers, and Tools for Embedded Systems
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 176-192
1998
[[Google Scholar]](https://scholar.google.com/scholar?q=Machine%20descriptions%20to%20build%20tools%20for%20embedded%20systems)
[[DBLP]](https://dblp.org/search?q=Machine%20descriptions%20to%20build%20tools%20for%20embedded%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Machine%20descriptions%20to%20build%20tools%20for%20embedded%20systems)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-49673-1)

Notes: 
[ISA specification](#ISA specification),
[SLED](#SLED)\



[ISA specification]: #notes-isa-specification
[SLED]: #notes-sled
# Specifying representations of machine instructions {#papers-ramsey-toplas-1997}


Norman Ramsey, Mary F. Fernández
Association for Computing Machinery
New York, NY, USA
Pages 492-524
May
1997
[[Google Scholar]](https://scholar.google.com/scholar?q=Specifying%20representations%20of%20machine%20instructions)
[[DBLP]](https://dblp.org/search?q=Specifying%20representations%20of%20machine%20instructions)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Specifying%20representations%20of%20machine%20instructions)
[[doi]](https://doi.org/10.1145/256167.256225)
[[url]](https://doi.org/10.1145/256167.256225)

Notes: 
[ISA specification](#ISA specification),
[SLED](#SLED)\



[ISA specification]: #notes-isa-specification
[SLED]: #notes-sled
# Lock inference for systems software {#papers-regehr-acp4is-2003}


John Regehr, Alastair D. Reid
Proceedings of the Second AOSD Workshop on Aspects, Components, and Patterns for Infrastructure Software (ACP4IS)
Boston, MA, USA
17
March
2003
[[Google Scholar]](https://scholar.google.com/scholar?q=Lock%20inference%20for%20systems%20software)
[[DBLP]](https://dblp.org/search?q=Lock%20inference%20for%20systems%20software)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Lock%20inference%20for%20systems%20software)

Notes: 
[operating systems](#operating systems)\




[operating systems]: #notes-operating-systems
# HOIST: a system for automatically deriving static analyzers for embedded systems {#papers-regehr-asplos-2004}


John Regehr, Alastair D. Reid
Proceedings of the 11th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2004)
Boston, MA, USA
ACM
Pages 133-143
7-13
October
2004
[[Google Scholar]](https://scholar.google.com/scholar?q=HOIST%3A%20a%20system%20for%20automatically%20deriving%20static%20analyzers%20for%20embedded%20systems)
[[DBLP]](https://dblp.org/search?q=HOIST%3A%20a%20system%20for%20automatically%20deriving%20static%20analyzers%20for%20embedded%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=HOIST%3A%20a%20system%20for%20automatically%20deriving%20static%20analyzers%20for%20embedded%20systems)
[[doi]](https://doi.org/10.1145/1024393.1024410)

Notes: 
[abstract interpretation](#abstract interpretation),
[ISA specification](#ISA specification),
[BDD](#BDD)\




[abstract interpretation]: #notes-abstract-interpretation
[ISA specification]: #notes-isa-specification
[BDD]: #notes-bdd
# Eliminating stack overflow by abstract interpretation {#papers-regehr-emsoft-2003}


John Regehr, Alastair D. Reid, Kirk Webb
Embedded Software, Third International Conference (EMSOFT 2003)
Lecture Notes in Computer Science, volume 2855
Philadelphia, PA, USA
Springer
Pages 306-322
13-15
October
2003
[[Google Scholar]](https://scholar.google.com/scholar?q=Eliminating%20stack%20overflow%20by%20abstract%20interpretation)
[[DBLP]](https://dblp.org/search?q=Eliminating%20stack%20overflow%20by%20abstract%20interpretation)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Eliminating%20stack%20overflow%20by%20abstract%20interpretation)
[[doi]](https://doi.org/10.1007/978-3-540-45212-6_20)

Notes: 
[abstract interpretation](#abstract interpretation),
[ISA specification](#ISA specification)\


John Regehr described the "correctness argument" in this paper in his blog post
[Who verifies the verifiers?]https://blog.regehr.org/archives/370).



[abstract interpretation]: #notes-abstract-interpretation
[ISA specification]: #notes-isa-specification
# Deriving abstract transfer functions for analyzing embedded software {#papers-regehr-lctes-2006}


John Regehr, Usit Duongsaa
Proceedings of the 2006 ACM SIGPLAN/SIGBED Conference on Language, Compilers, and Tool Support for Embedded Systems
LCTES '06
Ottawa, Ontario, Canada
ACM
New York, NY, USA
Pages 34-43
2006
[[Google Scholar]](https://scholar.google.com/scholar?q=Deriving%20abstract%20transfer%20functions%20for%20analyzing%20embedded%20software)
[[DBLP]](https://dblp.org/search?q=Deriving%20abstract%20transfer%20functions%20for%20analyzing%20embedded%20software)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Deriving%20abstract%20transfer%20functions%20for%20analyzing%20embedded%20software)
[[doi]](https://doi.org/10.1145/1134650.1134657)
[[ISBN]](http://books.google.com/books?vid=ISBN1-59593-362-X)

Notes: 
[abstract interpretation](#abstract interpretation),
[ISA specification](#ISA specification),
[BDD](#BDD)\




[abstract interpretation]: #notes-abstract-interpretation
[ISA specification]: #notes-isa-specification
[BDD]: #notes-bdd
# Test-case reduction for C compiler bugs {#papers-regehr-pldi-2012}


John Regehr, Yang Chen, Pascal Cuoq, Eric Eide, Chucky Ellison, Xuejun Yang
Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation
PLDI '12
Beijing, China
Association for Computing Machinery
New York, NY, USA
Pages 335-346
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=Test-case%20reduction%20for%20C%20compiler%20bugs)
[[DBLP]](https://dblp.org/search?q=Test-case%20reduction%20for%20C%20compiler%20bugs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Test-case%20reduction%20for%20C%20compiler%20bugs)
[[doi]](https://doi.org/10.1145/2254064.2254104)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450312059)
[[url]](https://doi.org/10.1145/2254064.2254104)

Notes: 
[test-case reduction](#test-case reduction),
[fuzz testing](#fuzz testing)\
Referenced by: 
[papers/maciver:ecoop:2020](#papers-maciver-ecoop-2020),
[notes/test-case-reduction](#notes-test-case-reduction)\



[test-case reduction]: #notes-test-case-reduction
[fuzz testing]: #notes-fuzz-testing
# Evolving real-time systems using hierarchical scheduling and concurrency analysis {#papers-regehr-rtss-2003}


John Regehr, Alastair D. Reid, Kirk Webb, Michael A. Parker, Jay Lepreau
Proceedings of the 24th IEEE Real-Time Systems Symposium (RTSS 2003)
Cancun, Mexico
IEEE Computer Society
Pages 25-36
3-5
December
2003
[[Google Scholar]](https://scholar.google.com/scholar?q=Evolving%20real-time%20systems%20using%20hierarchical%20scheduling%20and%20concurrency%20analysis)
[[DBLP]](https://dblp.org/search?q=Evolving%20real-time%20systems%20using%20hierarchical%20scheduling%20and%20concurrency%20analysis)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Evolving%20real-time%20systems%20using%20hierarchical%20scheduling%20and%20concurrency%20analysis)
[[doi]](https://doi.org/10.1109/REAL.2003.1253251)





# Eliminating stack overflow by abstract interpretation {#papers-regehr-tecs-2005}


John Regehr, Alastair D. Reid, Kirk Webb
Pages 751-778
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=Eliminating%20stack%20overflow%20by%20abstract%20interpretation)
[[DBLP]](https://dblp.org/search?q=Eliminating%20stack%20overflow%20by%20abstract%20interpretation)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Eliminating%20stack%20overflow%20by%20abstract%20interpretation)
[[doi]](https://doi.org/10.1145/1113830.1113833)

Notes: 
[abstract interpretation](#abstract interpretation),
[ISA specification](#ISA specification)\




[abstract interpretation]: #notes-abstract-interpretation
[ISA specification]: #notes-isa-specification
# SoC-C: efficient programming abstractions for heterogeneous multicore systems on chip {#papers-reid-cases-2008}


Alastair D. Reid, Krisztián Flautner, Edmund Grimley-Evans, Yuan Lin
Proceedings of the 2008 International Conference on Compilers, Architecture, and Synthesis for Embedded Systems (CASES 2008)
Atlanta, GA, USA
ACM
Pages 95-104
19-24
October
2008
[[Google Scholar]](https://scholar.google.com/scholar?q=SoC-C%3A%20efficient%20programming%20abstractions%20for%20heterogeneous%20multicore%20systems%20on%20chip)
[[DBLP]](https://dblp.org/search?q=SoC-C%3A%20efficient%20programming%20abstractions%20for%20heterogeneous%20multicore%20systems%20on%20chip)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=SoC-C%3A%20efficient%20programming%20abstractions%20for%20heterogeneous%20multicore%20systems%20on%20chip)
[[doi]](https://doi.org/10.1145/1450095.1450112)

Notes: 
[remote procedure call](#remote procedure call),
[pipeline parallelism](#pipeline parallelism),
[continuations](#continuations),
[threads](#threads),
[decoupling](#decoupling),
[SIMD](#SIMD),
[vector architecture](#vector architecture),
[VLIW](#VLIW)\
Papers: 
[woh:micro:2008](#woh-micro-2008)\
Referenced by: 
[papers/lin:sdr:2006](#papers-lin-sdr-2006),
[papers/lin:sips:2006](#papers-lin-sips-2006),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[papers/woh:micro:2008](#papers-woh-micro-2008)\




[remote procedure call]: #notes-remote-procedure-call
[pipeline parallelism]: #notes-pipeline-parallelism
[continuations]: #notes-continuations
[threads]: #notes-threads
[decoupling]: #notes-decoupling
[SIMD]: #notes-simd
[vector architecture]: #notes-vector-architecture
[VLIW]: #notes-vliw
[woh:micro:2008]: #papers-woh-micro-2008
# End-to-end verification of ARM processors with ISA-formal {#papers-reid-cav-2016}


Alastair D. Reid, Rick Chen, Anastasios Deligiannis, David Gilday, David Hoyes, Will Keen, Ashan Pathirane, Erin Shepherd, Peter Vrabel, Ali Zaidi
Proceedings of the 2016 International Conference on Computer Aided Verification (CAV'16)
Lecture Notes in Computer Science, volume 9780
Toronto, Canada
Springer Verlag
Pages 42-58
July
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=End-to-end%20verification%20of%20ARM%20processors%20with%20ISA-formal)
[[DBLP]](https://dblp.org/search?q=End-to-end%20verification%20of%20ARM%20processors%20with%20ISA-formal)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=End-to-end%20verification%20of%20ARM%20processors%20with%20ISA-formal)
[[doi]](https://doi.org/10.1007/978-3-319-41540-6_3)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-319-41539-0)

Notes: 
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture),
[bounded model checking](#bounded model checking),
[dependent type](#dependent type),
[ASL](#ASL),
[CPU verification](#CPU verification)\
Papers: 
[reid:fmcad:2016](#reid-fmcad-2016),
[reid:oopsla:2017](#reid-oopsla-2017)\
Referenced by: 
[papers/reid:fmcad:2016](#papers-reid-fmcad-2016),
[papers/reid:oopsla:2017](#papers-reid-oopsla-2017),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[notes/asl](#notes-asl)\



[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
[bounded model checking]: #notes-bounded-model-checking
[dependent type]: #notes-dependent-type
[ASL]: #notes-asl
[CPU verification]: #notes-cpu-verification
[reid:fmcad:2016]: #papers-reid-fmcad-2016
[reid:oopsla:2017]: #papers-reid-oopsla-2017
# Trustworthy specifications of ARM v8-A and v8-M system level architecture {#papers-reid-fmcad-2016}


Alastair D. Reid
Proceedings of Formal Methods in Computer-Aided Design (FMCAD 2016)
Mountain View, CA, USA
Pages 161-168
October
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Trustworthy%20specifications%20of%20ARM%20v8-A%20and%20v8-M%20system%20level%20architecture)
[[DBLP]](https://dblp.org/search?q=Trustworthy%20specifications%20of%20ARM%20v8-A%20and%20v8-M%20system%20level%20architecture)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Trustworthy%20specifications%20of%20ARM%20v8-A%20and%20v8-M%20system%20level%20architecture)
[[doi]](https://doi.org/10.1109/FMCAD.2016.7886675)
[[ISBN]](http://books.google.com/books?vid=ISBN978-0-9835678-6-8)
[[url]](https://alastairreid.github.io/papers/fmcad2016-trustworthy.pdf)

Notes: 
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture),
[dependent type](#dependent type),
[type inference](#type inference),
[ASL](#ASL),
[formal specification](#formal specification)\
Papers: 
[reid:cav:2016](#reid-cav-2016),
[reid:oopsla:2017](#reid-oopsla-2017)\
Referenced by: 
[papers/reid:cav:2016](#papers-reid-cav-2016),
[papers/reid:oopsla:2017](#papers-reid-oopsla-2017),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[notes/asl](#notes-asl)\




[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
[dependent type]: #notes-dependent-type
[type inference]: #notes-type-inference
[ASL]: #notes-asl
[formal specification]: #notes-formal-specification
[reid:cav:2016]: #papers-reid-cav-2016
[reid:oopsla:2017]: #papers-reid-oopsla-2017
# Designing data structures {#papers-reid-gfpw-1989}


Alastair D. Reid
Proceedings of the 1989 Glasgow Workshop on Functional Programming
Workshops in Computing
Fraserburgh, Scotland, UK
Springer
Pages 170-181
21-23
August
1989
[[Google Scholar]](https://scholar.google.com/scholar?q=Designing%20data%20structures)
[[DBLP]](https://dblp.org/search?q=Designing%20data%20structures)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Designing%20data%20structures)





# Implementing Fudgets with standard widget sets {#papers-reid-gfpw-1993}


Alastair D. Reid, Satnam Singh
Proceedings of the 1993 Glasgow Workshop on Functional Programming
Ayr, Scotland
Springer London
London
Pages 222-235
5-7
July
1993
[[Google Scholar]](https://scholar.google.com/scholar?q=Implementing%20Fudgets%20with%20standard%20widget%20sets)
[[DBLP]](https://dblp.org/search?q=Implementing%20Fudgets%20with%20standard%20widget%20sets)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Implementing%20Fudgets%20with%20standard%20widget%20sets)
[[doi]](https://doi.org/10.1007/978-1-4471-3236-3_18)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4471-3236-3)

Notes: 
[Haskell language](#Haskell language)\




[Haskell language]: #notes-haskell-language
# Malloc pointers and stable pointers: Improving Haskell's foreign language interface {#papers-reid-gfpw-1994}


Alastair D. Reid
Draft Proceedings of the Glasgow Functional Programming Workshop
Ayr, Scotland
12-14
September
1994
[[Google Scholar]](https://scholar.google.com/scholar?q=Malloc%20pointers%20and%20stable%20pointers%3A%20Improving%20Haskell%27s%20foreign%20language%20interface)
[[DBLP]](https://dblp.org/search?q=Malloc%20pointers%20and%20stable%20pointers%3A%20Improving%20Haskell%27s%20foreign%20language%20interface)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Malloc%20pointers%20and%20stable%20pointers%3A%20Improving%20Haskell%27s%20foreign%20language%20interface)

Notes: 
[Haskell language](#Haskell language),
[foreign function interface](#foreign function interface)\




[Haskell language]: #notes-haskell-language
[foreign function interface]: #notes-foreign-function-interface
# A proposal for the standard Haskell libraries {#papers-reid-hw-1995}


Alastair D. Reid, John Peterson
Proceedings of the Haskell Workshop 1995, Yale University Research Report YALE/DCS/RR-1075
Portland, Oregon, USA
1995
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20proposal%20for%20the%20standard%20Haskell%20libraries)
[[DBLP]](https://dblp.org/search?q=A%20proposal%20for%20the%20standard%20Haskell%20libraries)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20proposal%20for%20the%20standard%20Haskell%20libraries)
[[url]](https://www.haskell.org/haskell-workshop/1995/HW1995-Proceedings.pdf)

Notes: 
[Haskell language](#Haskell language)\




[Haskell language]: #notes-haskell-language
# Prototyping real-time vision systems: An experiment in DSL design {#papers-reid-icse-1999}


Alastair D. Reid, John Peterson, Gregory D. Hager, Paul Hudak
Proceedings of the 1999 International Conference on Software Engineering (ICSE '99)
Los Angeles, CA, USA
ACM
Pages 484-493
16-22
May
1999
[[Google Scholar]](https://scholar.google.com/scholar?q=Prototyping%20real-time%20vision%20systems%3A%20An%20experiment%20in%20DSL%20design)
[[DBLP]](https://dblp.org/search?q=Prototyping%20real-time%20vision%20systems%3A%20An%20experiment%20in%20DSL%20design)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Prototyping%20real-time%20vision%20systems%3A%20An%20experiment%20in%20DSL%20design)
[[doi]](https://doi.org/10.1109/icse.1999.841038)

Notes: 
[Haskell language](#Haskell language),
[Functional Reactive Programming](#Functional Reactive Programming),
[Domain Specific Language](#Domain Specific Language)\




[Haskell language]: #notes-haskell-language
[Functional Reactive Programming]: #notes-functional-reactive-programming
[Domain Specific Language]: #notes-domain-specific-language
# Putting the spine back in the Spineless Tagless G-Machine: An implementation of resumable black-holes {#papers-reid-ifl-1998}


Alastair D. Reid
Implementation of Functional Languages, 10th International Workshop (IFL'98) Selected Papers
Lecture Notes in Computer Science, volume 1595
London, UK
Springer
Pages 186-199
9-11
September
1998
[[Google Scholar]](https://scholar.google.com/scholar?q=Putting%20the%20spine%20back%20in%20the%20Spineless%20Tagless%20G-Machine%3A%20An%20implementation%20of%20resumable%20black-holes)
[[DBLP]](https://dblp.org/search?q=Putting%20the%20spine%20back%20in%20the%20Spineless%20Tagless%20G-Machine%3A%20An%20implementation%20of%20resumable%20black-holes)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Putting%20the%20spine%20back%20in%20the%20Spineless%20Tagless%20G-Machine%3A%20An%20implementation%20of%20resumable%20black-holes)
[[doi]](https://doi.org/10.1007/3-540-48515-5_12)

Notes: 
[Haskell language](#Haskell language)\




[Haskell language]: #notes-haskell-language
# A precise semantics for ultraloose specifications {#papers-reid-msc-1993}


Alastair D. Reid
Glasgow School of Computing Science
Glasgow, Scotland
1993
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20precise%20semantics%20for%20ultraloose%20specifications)
[[DBLP]](https://dblp.org/search?q=A%20precise%20semantics%20for%20ultraloose%20specifications)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20precise%20semantics%20for%20ultraloose%20specifications)

Notes: 
[formal specification](#formal specification)\




[formal specification]: #notes-formal-specification
# Who guards the guards? Formal validation of the ARM v8-M architecture specification {#papers-reid-oopsla-2017}


Alastair D. Reid
Vancouver, BC, Canada
ACM
New York, NY, USA
Pages 88:1-88:24
22-27
October
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=Who%20guards%20the%20guards%3F%20Formal%20validation%20of%20the%20ARM%20v8-M%20architecture%20specification)
[[DBLP]](https://dblp.org/search?q=Who%20guards%20the%20guards%3F%20Formal%20validation%20of%20the%20ARM%20v8-M%20architecture%20specification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Who%20guards%20the%20guards%3F%20Formal%20validation%20of%20the%20ARM%20v8-M%20architecture%20specification)
[[doi]](https://doi.org/10.1145/3133912)

Notes: 
[ASL](#ASL),
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture),
[dependent type](#dependent type),
[natural language](#natural language),
[requirements specification](#requirements specification)\
Papers: 
[reid:fmcad:2016](#reid-fmcad-2016),
[reid:cav:2016](#reid-cav-2016)\
Referenced by: 
[papers/reid:cav:2016](#papers-reid-cav-2016),
[papers/reid:fmcad:2016](#papers-reid-fmcad-2016),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[notes/asl](#notes-asl)\



[ASL]: #notes-asl
[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
[dependent type]: #notes-dependent-type
[natural language]: #notes-natural-language
[requirements specification]: #notes-requirements-specification
[reid:fmcad:2016]: #papers-reid-fmcad-2016
[reid:cav:2016]: #papers-reid-cav-2016
# Knit: Component composition for systems software {#papers-reid-osdi-2000}


Alastair D. Reid, Matthew Flatt, Leigh Stoller, Jay Lepreau, Eric Eide
4th Symposium on Operating System Design and Implementation (OSDI 2000)
San Diego, California, USA
USENIX Association
Pages 347-360
23-25
October
2000
[[Google Scholar]](https://scholar.google.com/scholar?q=Knit%3A%20Component%20composition%20for%20systems%20software)
[[DBLP]](https://dblp.org/search?q=Knit%3A%20Component%20composition%20for%20systems%20software)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Knit%3A%20Component%20composition%20for%20systems%20software)
[[url]](http://dl.acm.org/citation.cfm?id=1251253)

Notes: 
[operating systems](#operating systems)\
Referenced by: 
[papers/eide:aspse:2001](#papers-eide-aspse-2001),
[papers/eide:icse:2002](#papers-eide-icse-2002)\




[operating systems]: #notes-operating-systems
# Defining interfaces between hardware and software: Quality and performance {#papers-reid-phd-2019}


Alastair D. Reid
Ph.D. thesis
School of Computing Science, University of Glasgow
Glasgow, Scotland
March
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Defining%20interfaces%20between%20hardware%20and%20software%3A%20Quality%20and%20performance)
[[DBLP]](https://dblp.org/search?q=Defining%20interfaces%20between%20hardware%20and%20software%3A%20Quality%20and%20performance)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Defining%20interfaces%20between%20hardware%20and%20software%3A%20Quality%20and%20performance)

Notes: 
[ASL](#ASL),
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture),
[CPU verification](#CPU verification),
[model checking](#model checking),
[bounded model checking](#bounded model checking),
[RTL](#RTL),
[requirements specification](#requirements specification),
[remote procedure call](#remote procedure call),
[pipeline parallelism](#pipeline parallelism),
[continuations](#continuations),
[threads](#threads),
[decoupling](#decoupling),
[SIMD](#SIMD),
[vector architecture](#vector architecture)\
Papers: 
[reid:fmcad:2016](#reid-fmcad-2016),
[reid:cav:2016](#reid-cav-2016),
[reid:oopsla:2017](#reid-oopsla-2017),
[reid:cases:2008](#reid-cases-2008)\
Referenced by: 
[notes/asl](#notes-asl)\




[ASL]: #notes-asl
[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
[CPU verification]: #notes-cpu-verification
[model checking]: #notes-model-checking
[bounded model checking]: #notes-bounded-model-checking
[RTL]: #notes-rtl
[requirements specification]: #notes-requirements-specification
[remote procedure call]: #notes-remote-procedure-call
[pipeline parallelism]: #notes-pipeline-parallelism
[continuations]: #notes-continuations
[threads]: #notes-threads
[decoupling]: #notes-decoupling
[SIMD]: #notes-simd
[vector architecture]: #notes-vector-architecture
[reid:fmcad:2016]: #papers-reid-fmcad-2016
[reid:cav:2016]: #papers-reid-cav-2016
[reid:oopsla:2017]: #papers-reid-oopsla-2017
[reid:cases:2008]: #papers-reid-cases-2008
# Designing the standard Haskell libraries {#papers-reid-yale-1998}


Alastair D. Reid, John Peterson
1998
[[Google Scholar]](https://scholar.google.com/scholar?q=Designing%20the%20standard%20Haskell%20libraries)
[[DBLP]](https://dblp.org/search?q=Designing%20the%20standard%20Haskell%20libraries)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Designing%20the%20standard%20Haskell%20libraries)

Notes: 
[Haskell language](#Haskell language)\




[Haskell language]: #notes-haskell-language
# The Hugs graphics library (version 2.0) {#papers-reid-yale-2001}


Alastair D. Reid
New Haven, CT, USA
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20Hugs%20graphics%20library%20%28version%202.0%29)
[[DBLP]](https://dblp.org/search?q=The%20Hugs%20graphics%20library%20%28version%202.0%29)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20Hugs%20graphics%20library%20%28version%202.0%29)

Notes: 
[Haskell language](#Haskell language)\




[Haskell language]: #notes-haskell-language
# Separation logic: a logic for shared mutable data structures {#papers-reynolds-lics-2002}


John C. Reynolds
Proceedings 17th Annual IEEE Symposium on Logic in Computer Science
Pages 55-74
July
2002
[[Google Scholar]](https://scholar.google.com/scholar?q=Separation%20logic%3A%20a%20logic%20for%20shared%20mutable%20data%20structures)
[[DBLP]](https://dblp.org/search?q=Separation%20logic%3A%20a%20logic%20for%20shared%20mutable%20data%20structures)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Separation%20logic%3A%20a%20logic%20for%20shared%20mutable%20data%20structures)
[[doi]](https://doi.org/10.1109/LICS.2002.1029817)

Notes: 
[separation logic](#separation logic),
[permission logic](#permission logic)\
Referenced by: 
[papers/jacobs:vstte:2010](#papers-jacobs-vstte-2010),
[papers/ohearn:cacm:2019](#papers-ohearn-cacm-2019)\


Separation logic is an extension of Hoare logic for reasoning about
programs that use pointers.
In particular, it copes well with aliasing (by providing
a compact way of saying that a set of pointers do not alias)
and a "frame rule" that lets you reason locally about a piece of
code without getting bogged down in the surrounding context.
This paper introduces separation logic,
illustrates its use to verify
 a number of list, tree and dag algorithms
 [this is one of the real strengths of this paper]
and discusses a lot of the work by the author and others
on developing, defining, using and extending 
the different forms of separation logic that existed at the
time (2002).



[separation logic]: #notes-separation-logic
[permission logic]: #notes-permission-logic
# Usability evaluation with the cognitive walkthrough {#papers-rieman-chi-1995}


John Rieman, Marita Franzke, David Redmiles
Conference Companion on Human Factors in Computing Systems
CHI '95
Denver, Colorado, USA
Association for Computing Machinery
New York, NY, USA
Pages 387-388
1995
[[Google Scholar]](https://scholar.google.com/scholar?q=Usability%20evaluation%20with%20the%20cognitive%20walkthrough)
[[DBLP]](https://dblp.org/search?q=Usability%20evaluation%20with%20the%20cognitive%20walkthrough)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Usability%20evaluation%20with%20the%20cognitive%20walkthrough)
[[doi]](https://doi.org/10.1145/223355.223735)
[[ISBN]](http://books.google.com/books?vid=ISBN0897917553)
[[url]](https://doi.org/10.1145/223355.223735)




# Formally verified big step semantics out of x86-64 binaries {#papers-roessle-cpp-2019}


Ian Roessle, Freek Verbeek, Binoy Ravindran
Proceedings of the 8th ACM SIGPLAN International Conference on Certified Programs and Proofs
CPP 2019
Cascais, Portugal
ACM
New York, NY, USA
Pages 181-195
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Formally%20verified%20big%20step%20semantics%20out%20of%20x86-64%20binaries)
[[DBLP]](https://dblp.org/search?q=Formally%20verified%20big%20step%20semantics%20out%20of%20x86-64%20binaries)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Formally%20verified%20big%20step%20semantics%20out%20of%20x86-64%20binaries)
[[doi]](https://doi.org/10.1145/3293880.3294102)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-6222-1)

Notes: 
[x86 architecture](#x86 architecture),
[ISA specification](#ISA specification)\



[x86 architecture]: #notes-x86-architecture
[ISA specification]: #notes-isa-specification
# Noninterference, transitivity, and channel-control security policies {#papers-rushby-sri-1992}


Report
SRI International, Computer Science Laboratory Menlo Park
1992
[[Google Scholar]](https://scholar.google.com/scholar?q=Noninterference%2C%20transitivity%2C%20and%20channel-control%20security%20policies)
[[DBLP]](https://dblp.org/search?q=Noninterference%2C%20transitivity%2C%20and%20channel-control%20security%20policies)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Noninterference%2C%20transitivity%2C%20and%20channel-control%20security%20policies)

Notes: 
[information flow](#information flow)\
Papers: 
[goguen:secpriv:1982](#goguen-secpriv-1982)\
Referenced by: 
[notes/non-interference](#notes-non-interference)\


This very highly cited report provides (what I think is) the accepted extension of [Goguen and Meseguer's notion of interference][goguen:secpriv:1982] to handle intransitive security policies.

The report is written in the style of a tutorial that discusses a range of competing/contributing ideas from the time, combines them into a consistent framework, proves results about the definitions and illustrates strengths/weaknesses with examples.
Some important results relate their definitions to multilevel security policies (MLS).

One of the key examples for intransitivity involves a 4-level security policy with a component that is able to downgrade top-secret documents to confidential.
Clearly, it is ok for top-secret documents to be sent to the downgrader and for the downgrader to send documents to confidential locations but it is not ok to send top-secret documents directly to confidential locations.

In addition to the basic definitions, they provide the "unwinding conditions" required to prove that a system satisfies a given security policy and all formal statements are backed up by mechanised proofs (in a companion report).

One purpose of the report to provide a definition of intransitive interference for which it is easy to show that transitive interference is a special case.



[information flow]: #notes-information-flow
[goguen:secpriv:1982]: #papers-goguen-secpriv-1982
# The CRAY-1 computer system {#papers-russell-cacm-1978}


Richard M. Russell
ACM
New York, NY, USA
Pages 63-72
January
1978
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20CRAY-1%20computer%20system)
[[DBLP]](https://dblp.org/search?q=The%20CRAY-1%20computer%20system)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20CRAY-1%20computer%20system)
[[doi]](https://doi.org/10.1145/359327.359336)

Notes: 
[Cray architecture](#Cray architecture),
[instruction set architecture](#instruction set architecture)\
Referenced by: 
[notes/cray-architecture](#notes-cray-architecture)\



[Cray architecture]: #notes-cray-architecture
[instruction set architecture]: #notes-instruction-set-architecture
# Declassification: Dimensions and principles {#papers-sabelfield-jcs-2009}


Andrei Sabelfeld, David Sands
IOS Press
Pages 517-548
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Declassification%3A%20Dimensions%20and%20principles)
[[DBLP]](https://dblp.org/search?q=Declassification%3A%20Dimensions%20and%20principles)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Declassification%3A%20Dimensions%20and%20principles)
[[doi]](https://doi.org/10.3233/JCS-2009-0352)

Notes: 
[information flow](#information flow)\




[information flow]: #notes-information-flow
# Lessons from building static analysis tools at Google {#papers-sadowski-cacm-2018}


Caitlin Sadowski, Edward Aftandilian, Alex Eagle, Liam Miller-Cushon, Ciera Jaspan
Association for Computing Machinery
New York, NY, USA
Pages 58-66
March
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=Lessons%20from%20building%20static%20analysis%20tools%20at%20Google)
[[DBLP]](https://dblp.org/search?q=Lessons%20from%20building%20static%20analysis%20tools%20at%20Google)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Lessons%20from%20building%20static%20analysis%20tools%20at%20Google)
[[doi]](https://doi.org/10.1145/3188720)
[[url]](https://doi.org/10.1145/3188720)

Notes: 
[google papers](#google papers),
[google infrastructure](#google infrastructure)\



[google papers]: #notes-google-papers
[google infrastructure]: #notes-google-infrastructure
# Modern code review: A case study at Google {#papers-sadowski-icse-seip-2018}


Caitlin Sadowski, Emma Söderberg, Luke Church, Michal Sipko, Alberto Bacchelli
Proceedings of the 40th International Conference on Software Engineering: Software Engineering in Practice
ICSE-SEIP '18
Gothenburg, Sweden
Association for Computing Machinery
New York, NY, USA
Pages 181-190
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=Modern%20code%20review%3A%20A%20case%20study%20at%20Google)
[[DBLP]](https://dblp.org/search?q=Modern%20code%20review%3A%20A%20case%20study%20at%20Google)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Modern%20code%20review%3A%20A%20case%20study%20at%20Google)
[[doi]](https://doi.org/10.1145/3183519.3183525)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450356596)
[[url]](https://doi.org/10.1145/3183519.3183525)

Notes: 
[google papers](#google papers),
[google infrastructure](#google infrastructure)\



[google papers]: #notes-google-papers
[google infrastructure]: #notes-google-infrastructure
# Tricorder: Building a program analysis ecosystem {#papers-sadowski-icse-2015}


Caitlin Sadowski, Jeffrey van Gogh, Ciera Jaspan, Emma Söderberg, Collin Winter
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
Pages 598-608
May
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=Tricorder%3A%20Building%20a%20program%20analysis%20ecosystem)
[[DBLP]](https://dblp.org/search?q=Tricorder%3A%20Building%20a%20program%20analysis%20ecosystem)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Tricorder%3A%20Building%20a%20program%20analysis%20ecosystem)
[[doi]](https://doi.org/10.1109/ICSE.2015.76)

Notes: 
[google papers](#google papers),
[google infrastructure](#google infrastructure)\



[google papers]: #notes-google-papers
[google infrastructure]: #notes-google-infrastructure
# A machine description facility for compiler testing {#papers-samet-ieeetse-1977}


Hanan Samet
Pages 343-351
September
1977
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20machine%20description%20facility%20for%20compiler%20testing)
[[DBLP]](https://dblp.org/search?q=A%20machine%20description%20facility%20for%20compiler%20testing)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20machine%20description%20facility%20for%20compiler%20testing)
[[doi]](https://doi.org/10.1109/TSE.1977.231159)

Notes: 
[ISA specification](#ISA specification),
[translation validation](#translation validation)\



[ISA specification]: #notes-isa-specification
[translation validation]: #notes-translation-validation
# Automatically proving the correctness of translations involving optimized code. {#papers-samet-phd-1975}


Hanan Samet
Ph.D. thesis
Stanford University
Stanford, CA, USA
1975
[[Google Scholar]](https://scholar.google.com/scholar?q=Automatically%20proving%20the%20correctness%20of%20translations%20involving%20optimized%20code.)
[[DBLP]](https://dblp.org/search?q=Automatically%20proving%20the%20correctness%20of%20translations%20involving%20optimized%20code.)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automatically%20proving%20the%20correctness%20of%20translations%20involving%20optimized%20code.)

Notes: 
[translation validation](#translation validation)\
Referenced by: 
[notes/translation-validation](#notes-translation-validation)\




[translation validation]: #notes-translation-validation
# Understanding POWER multiprocessors {#papers-sarkar-pldi-2011}


Susmit Sarkar, Peter Sewell, Jade Alglave, Luc Maranget, Derek Williams
Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2011, San Jose, CA, USA, June 4-8, 2011
Pages 175-186
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=Understanding%20POWER%20multiprocessors)
[[DBLP]](https://dblp.org/search?q=Understanding%20POWER%20multiprocessors)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Understanding%20POWER%20multiprocessors)
[[doi]](https://doi.org/10.1145/1993498.1993520)

Notes: 
[PowerPC architecture](#PowerPC architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture)\




[PowerPC architecture]: #notes-powerpc-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
# The semantics of x86-CC multiprocessor machine code {#papers-sarkar-popl-2009}


Susmit Sarkar, Peter Sewell, Francesco Zappa Nardelli, Scott Owens, Tom Ridge, Thomas Braibant, Magnus O. Myreen, Jade Alglave
Proceedings of the 36th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
POPL '09
Savannah, GA, USA
ACM
New York, NY, USA
Pages 379-391
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20semantics%20of%20x86-CC%20multiprocessor%20machine%20code)
[[DBLP]](https://dblp.org/search?q=The%20semantics%20of%20x86-CC%20multiprocessor%20machine%20code)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20semantics%20of%20x86-CC%20multiprocessor%20machine%20code)
[[doi]](https://doi.org/10.1145/1480881.1480929)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-60558-379-2)

Notes: 
[x86 architecture](#x86 architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture)\




[x86 architecture]: #notes-x86-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
# Integrated semantics of intermediate-language C and macro-assembler for pervasive formal verification of operating systems and hypervisors from VerisoftXT {#papers-schmaltz-vstte-2012}


Sabine Schmaltz, Andrey Shadrin
Verified Software: Theories, Tools, Experiments
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 18-33
2012
[[Google Scholar]](https://scholar.google.com/scholar?q=Integrated%20semantics%20of%20intermediate-language%20C%20and%20macro-assembler%20for%20pervasive%20formal%20verification%20of%20operating%20systems%20and%20hypervisors%20from%20VerisoftXT)
[[DBLP]](https://dblp.org/search?q=Integrated%20semantics%20of%20intermediate-language%20C%20and%20macro-assembler%20for%20pervasive%20formal%20verification%20of%20operating%20systems%20and%20hypervisors%20from%20VerisoftXT)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Integrated%20semantics%20of%20intermediate-language%20C%20and%20macro-assembler%20for%20pervasive%20formal%20verification%20of%20operating%20systems%20and%20hypervisors%20from%20VerisoftXT)
[[doi]](https://doi.org/10.1007/978-3-642-27705-4_3)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-27705-4)

Notes: 
[ISA specification](#ISA specification)\



[ISA specification]: #notes-isa-specification
# All you ever wanted to know about dynamic taint analysis and forward symbolic execution (but might have been afraid to ask) {#papers-schwartz-sp-2010}


Edward J. Schwartz, Thanassis Avgerinos, David Brumley
Proceedings of the 2010 IEEE Symposium on Security and Privacy
SP '10
IEEE Computer Society
USA
Pages 317-331
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=All%20you%20ever%20wanted%20to%20know%20about%20dynamic%20taint%20analysis%20and%20forward%20symbolic%20execution%20%28but%20might%20have%20been%20afraid%20to%20ask%29)
[[DBLP]](https://dblp.org/search?q=All%20you%20ever%20wanted%20to%20know%20about%20dynamic%20taint%20analysis%20and%20forward%20symbolic%20execution%20%28but%20might%20have%20been%20afraid%20to%20ask%29)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=All%20you%20ever%20wanted%20to%20know%20about%20dynamic%20taint%20analysis%20and%20forward%20symbolic%20execution%20%28but%20might%20have%20been%20afraid%20to%20ask%29)
[[doi]](https://doi.org/10.1109/SP.2010.26)
[[ISBN]](http://books.google.com/books?vid=ISBN9780769540351)
[[url]](https://doi.org/10.1109/SP.2010.26)

Notes: 
[symbolic execution](#symbolic execution)\



[symbolic execution]: #notes-symbolic-execution
# Automatic derivation of platform noninterference properties {#papers-schwarz-sefm-2016}


Oliver Schwarz, Mads Dam
Proceedings Software Engineering and Formal Methods - 14th International Conference, SEFM 2016
Pages 27-44
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Automatic%20derivation%20of%20platform%20noninterference%20properties)
[[DBLP]](https://dblp.org/search?q=Automatic%20derivation%20of%20platform%20noninterference%20properties)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automatic%20derivation%20of%20platform%20noninterference%20properties)
[[doi]](https://doi.org/10.1007/978-3-319-41591-8_3)

Notes: 
[non-interference](#non-interference),
[ARM architecture](#ARM architecture)\



[non-interference]: #notes-non-interference
[ARM architecture]: #notes-arm-architecture
# Lightweight support for magic wands in an automatic verifier {#papers-schwerhoff-ecoop-2015}


Malte Schwerhoff, Alexander J. Summers
29th European Conference on Object-Oriented Programming (ECOOP 2015)
Schloss Dagstuhl, Leibniz-Zentrum für Informatik
Pages 614-638
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=Lightweight%20support%20for%20magic%20wands%20in%20an%20automatic%20verifier)
[[DBLP]](https://dblp.org/search?q=Lightweight%20support%20for%20magic%20wands%20in%20an%20automatic%20verifier)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Lightweight%20support%20for%20magic%20wands%20in%20an%20automatic%20verifier)

Notes: 
[permission logic](#permission logic),
[separation logic](#separation logic),
[magic wand](#magic wand),
[Viper verifier](#Viper verifier),
[Prusti verifier](#Prusti verifier)\
Referenced by: 
[papers/hehner:vstte:2008](#papers-hehner-vstte-2008),
[papers/tuerk:vstte:2010](#papers-tuerk-vstte-2010),
[notes/magic-wand](#notes-magic-wand),
[notes/prusti-verifier](#notes-prusti-verifier)\


Verifying a loop that walks over a heap data structure is tricky.  At the
start, we might have a pointer to the root of the structure; in some
intermediate iteration of the loop, we have a pointer into the middle of the
structure and the nodes we have visited so far have been changed in some way;
and then, at the end, the entire structure from the root down has been fully
changed.  The difficulty is that, to verify the loop, we have to write an
invariant that describes the changes to the nodes that we have visited so far.
That is, we have to describe a partial data structure: from the root down to
the current position in the list.

There is a well understood way of doing this for lists: we write a “list
segment” predicate “lseg(p,q)” describing the list nodes from node “p” down to
node “q”, we prove some lemmas such as “lseg(p, q) ∗ lseg(q,r) ==> lseg(p, r)”
that say that if you have a list from p to q and a list from q to r then you
have a list from p to r.  And now we can talk about the partial list from the
root down to the current position in the list and we can talk about the
unvisited remainder of the list.

The problem with this is that (1)  we need to add these extra predicates and
lemmas; and (2) it only works for simple (linear?) data structures.  (I am not
sure what the appropriate variant would be for a binary tree.)

The solution is to use “magic wands” Magic wands are the “—∗” separated
implication operator of permission logics such as separation logic or dynamic
frame logic.  Suppose that our loop starts with the root satisfying some
recursive property “P” (i.e., “P(root)” holds) and, at the end of the loop, we
want some recursive property “Q” (i.e., “Q(root)” holds).  Using magic wands,
we would use a list invariant of the form:


P(rest) ∗ (Q(rest) ––∗ Q(root))

This says that

1. We know that the rest of the data structure (still) satisfies P.

2. Once we have transformed the rest of the structure (so that “Q(rest)”
   holds), we will be able to show that the entire structure has been
   transformed (so that “Q(root)” holds).

I think that this has been understood for a while now.  The problem is that it
has also been understood that supporting magic wands makes your logic
undecidable.  The contribution of this paper is

- explicit operations to introduce and eliminate magic wands (analogous to the
  fold/unfold operations used with recursive predicates.
- heuristics for automatically calculating the “footprint” of a magic wand

The “footprint” of a wand “A ––∗ B”

This support for [magic wand]s has been implemented in the [Viper verifier] (an
[intermediate verification language]) and is used in the [Prusti verifier].



[permission logic]: #notes-permission-logic
[separation logic]: #notes-separation-logic
[magic wand]: #notes-magic-wand
[Viper verifier]: #notes-viper-verifier
[Prusti verifier]: #notes-prusti-verifier
# ARM Architecture Reference Manual (ARMv5 edition) {#papers-seal-book-2000}


David Seal
Addison-Wesley Longman Publishing Co., Inc.
Boston, MA, USA
2000
[[Google Scholar]](https://scholar.google.com/scholar?q=ARM%20Architecture%20Reference%20Manual%20%28ARMv5%20edition%29)
[[DBLP]](https://dblp.org/search?q=ARM%20Architecture%20Reference%20Manual%20%28ARMv5%20edition%29)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=ARM%20Architecture%20Reference%20Manual%20%28ARMv5%20edition%29)
[[ISBN]](http://books.google.com/books?vid=ISBN0201737191)

Notes: 
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[RISC architecture](#RISC architecture),
[instruction set architecture](#instruction set architecture)\



[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[RISC architecture]: #notes-risc-architecture
[instruction set architecture]: #notes-instruction-set-architecture
# Formal verification by symbolic evaluation of partially-ordered trajectories {#papers-segar-fmsd-1995}


Carl-Johan H. Seger, Randal E. Bryant
Pages 147-189
1995
[[Google Scholar]](https://scholar.google.com/scholar?q=Formal%20verification%20by%20symbolic%20evaluation%20of%20partially-ordered%20trajectories)
[[DBLP]](https://dblp.org/search?q=Formal%20verification%20by%20symbolic%20evaluation%20of%20partially-ordered%20trajectories)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Formal%20verification%20by%20symbolic%20evaluation%20of%20partially-ordered%20trajectories)
[[doi]](https://doi.org/10.1007/BF01383966)
[[url]](https://doi.org/10.1007/BF01383966)

Notes: 
[Symbolic trajectory evaluation](#Symbolic trajectory evaluation),
[CPU verification](#CPU verification)\
Referenced by: 
[papers/kirankumar:fmcad:2012](#papers-kirankumar-fmcad-2012),
[notes/symbolic-trajectory-evaluation](#notes-symbolic-trajectory-evaluation)\



[Symbolic trajectory evaluation]: #notes-symbolic-trajectory-evaluation
[CPU verification]: #notes-cpu-verification
# SecVisor: A tiny hypervisor to provide lifetime kernel code integrity for commodity OSes {#papers-seshadri-sosp-2007}


Arvind Seshadri, Mark Luk, Ning Qu, Adrian Perrig
SOSP
ACM
Pages 335-350
2007
[[Google Scholar]](https://scholar.google.com/scholar?q=SecVisor%3A%20A%20tiny%20hypervisor%20to%20provide%20lifetime%20kernel%20code%20integrity%20for%20commodity%20OSes)
[[DBLP]](https://dblp.org/search?q=SecVisor%3A%20A%20tiny%20hypervisor%20to%20provide%20lifetime%20kernel%20code%20integrity%20for%20commodity%20OSes)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=SecVisor%3A%20A%20tiny%20hypervisor%20to%20provide%20lifetime%20kernel%20code%20integrity%20for%20commodity%20OSes)
[[doi]](https://doi.org/10.1145/1323293.1294294)

Papers: 
[franklin:cmu:2008](#franklin-cmu-2008)\
Referenced by: 
[papers/franklin:cmu:2008](#papers-franklin-cmu-2008)\


SecVisor is a hypervisor that virtualizes physical RAM, the MMU and the IO-MMU
in order to protect the kernel executable code from modification.
It uses the AMD architectural support for hypervisors to provide most of the
protection and switches memory protection on every entry/exit from kernel.
And it requires small changes to parts of Linux that normally load/modify the
kernel executable: boot  and module load/unload.

Although it is a hypervisor, only one virtual machine is supported – this keeps
SecVisor small.
Small kernel, lots of great detail about implementation, option to rely more on
software (for use on older hardware that lacks virtualization support) and good
benchmarking.

Limitations:
- It seems that this paper came out more or less simultaneously with ROP/JOP attacks
  and, by itself, this work does not protect against these attacks since they do
  not modify the kernel code – they just repurpose it.

- This is a uniprocessor hypervisor – discussion of MP support sounds plausible
  (although I worry about how switching protection on entry/exit could work?)

- Self-modifying code is a major issue.  The easy case is code that patches
  itself against known bugs.

See [later paper by Franklin, et al.][franklin:cmu:2008]
that describes security issues in design, use of formal verification to model
design, fixes and performance impact.



[franklin:cmu:2008]: #papers-franklin-cmu-2008
# Translation validation for a verified OS kernel {#papers-sewell-pldi-2013}


Thomas Arthur Leck Sewell, Magnus O. Myreen, Gerwin Klein
ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI '13, Seattle, WA, USA, June 16-19, 2013
Pages 471-482
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Translation%20validation%20for%20a%20verified%20OS%20kernel)
[[DBLP]](https://dblp.org/search?q=Translation%20validation%20for%20a%20verified%20OS%20kernel)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Translation%20validation%20for%20a%20verified%20OS%20kernel)
[[doi]](https://doi.org/10.1145/2462156.2462183)

Notes: 
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture),
[translation validation](#translation validation)\




[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
[translation validation]: #notes-translation-validation
# Data-driven equivalence checking {#papers-sharma-oopsla-2012}


Rahul Sharma, Eric Schkufza, Berkeley Churchill, Alex Aiken
Proceedings of the 2013 ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages and Applications
OOPSLA '13
Indianapolis, Indiana, USA
ACM
New York, NY, USA
Pages 391-406
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Data-driven%20equivalence%20checking)
[[DBLP]](https://dblp.org/search?q=Data-driven%20equivalence%20checking)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Data-driven%20equivalence%20checking)
[[doi]](https://doi.org/10.1145/2509136.2509509)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-2374-1)





# A data driven approach for algebraic loop invariants {#papers-sharma-pls-2013}


Rahul Sharma, Saurabh Gupta, Bharath Hariharan, Alex Aiken, Percy Liang, Aditya V. Nori
Programming Languages and Systems
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 574-592
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20data%20driven%20approach%20for%20algebraic%20loop%20invariants)
[[DBLP]](https://dblp.org/search?q=A%20data%20driven%20approach%20for%20algebraic%20loop%20invariants)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20data%20driven%20approach%20for%20algebraic%20loop%20invariants)
[[doi]](https://doi.org/10.1007/978-3-642-37036-6_31)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-37036-6)

Notes: 
[loop invariant](#loop invariant)\




[loop invariant]: #notes-loop-invariant
# Certification of an instruction set simulator {#papers-shi-phd-2013}


Xiaomu Shi
Ph.D. thesis
Université de Grenoble
July
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Certification%20of%20an%20instruction%20set%20simulator)
[[DBLP]](https://dblp.org/search?q=Certification%20of%20an%20instruction%20set%20simulator)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Certification%20of%20an%20instruction%20set%20simulator)
[[url]](https://tel.archives-ouvertes.fr/tel-00937524)

Notes: 
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture)\




[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
# SOK: (state of) the art of war: Offensive techniques in binary analysis {#papers-shoshitaishvili-sp-2016}


Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario Polino, Andrew Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher Kruegel, Giovanni Vigna
2016 IEEE Symposium on Security and Privacy (SP)
Pages 138-157
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=SOK%3A%20%28state%20of%29%20the%20art%20of%20war%3A%20Offensive%20techniques%20in%20binary%20analysis)
[[DBLP]](https://dblp.org/search?q=SOK%3A%20%28state%20of%29%20the%20art%20of%20war%3A%20Offensive%20techniques%20in%20binary%20analysis)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=SOK%3A%20%28state%20of%29%20the%20art%20of%20war%3A%20Offensive%20techniques%20in%20binary%20analysis)
[[doi]](https://doi.org/10.1109/SP.2016.17)

Notes: 
[binary analysis](#binary analysis)\
Referenced by: 
[notes/systematization-of-knowledge](#notes-systematization-of-knowledge)\



[binary analysis]: #notes-binary-analysis
# CIVL: the concurrency intermediate verification language {#papers-siegel-sc-2015}


Stephen F. Siegel, Manchun Zheng, Ziqing Luo, Timothy K. Zirkel, Andre V. Marianiello, John G. Edenhofner, Matthew B. Dwyer, Michael S. Rogers
SC '15: Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis
Pages 1-12
Nov
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=CIVL%3A%20the%20concurrency%20intermediate%20verification%20language)
[[DBLP]](https://dblp.org/search?q=CIVL%3A%20the%20concurrency%20intermediate%20verification%20language)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=CIVL%3A%20the%20concurrency%20intermediate%20verification%20language)
[[doi]](https://doi.org/10.1145/2807591.2807635)

Notes: 
[CIVL verifier](#CIVL verifier),
[intermediate verification language](#intermediate verification language)\




[CIVL verifier]: #notes-civl-verifier
[intermediate verification language]: #notes-intermediate-verification-language
# Push-button verification of file systems via crash refinement {#papers-sigurbjarnarson-osdi-2016}


Helgi Sigurbjarnarson, James Bornholt, Emina Torlak, Xi Wang
12th USENIX Symposium on Operating Systems Design and Implementation (OSDI 16)
Pages 1-16
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Push-button%20verification%20of%20file%20systems%20via%20crash%20refinement)
[[DBLP]](https://dblp.org/search?q=Push-button%20verification%20of%20file%20systems%20via%20crash%20refinement)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Push-button%20verification%20of%20file%20systems%20via%20crash%20refinement)

Referenced by: 
[papers/nelson:sosp:2019](#papers-nelson-sosp-2019)\




# Nickel: A framework for design and verification of information flow control systems {#papers-sigurbjarnarson-osdi-2018}


Helgi Sigurbjarnarson, Luke Nelson, Bruno Castro-Karney, James Bornholt, Emina Torlak, Xi Wang
OSDI
USENIX Association
Pages 287-305
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=Nickel%3A%20A%20framework%20for%20design%20and%20verification%20of%20information%20flow%20control%20systems)
[[DBLP]](https://dblp.org/search?q=Nickel%3A%20A%20framework%20for%20design%20and%20verification%20of%20information%20flow%20control%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Nickel%3A%20A%20framework%20for%20design%20and%20verification%20of%20information%20flow%20control%20systems)

Notes: 
[information flow](#information flow)\
Referenced by: 
[papers/nelson:sosp:2019](#papers-nelson-sosp-2019)\




[information flow]: #notes-information-flow
# A comparative study of SYCL, OpenCL, and OpenMP {#papers-silva-sbac-2016}


Hércules Cardoso da Silva, Flávia Pisani, Edson Borin
2016 International Symposium on Computer Architecture and High Performance Computing Workshops (SBAC-PADW)
Pages 61-66
October
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20comparative%20study%20of%20SYCL%2C%20OpenCL%2C%20and%20OpenMP)
[[DBLP]](https://dblp.org/search?q=A%20comparative%20study%20of%20SYCL%2C%20OpenCL%2C%20and%20OpenMP)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20comparative%20study%20of%20SYCL%2C%20OpenCL%2C%20and%20OpenMP)
[[doi]](https://doi.org/10.1109/SBAC-PADW.2016.19)

Notes: 
[data parallelism](#data parallelism)\



[data parallelism]: #notes-data-parallelism
# Reasoning about a machine with local capabilities {#papers-skorstengaard-esop-2018}


Lau Skorstengaard, Dominique Devriese, Lars Birkedal
Programming Languages and Systems
Springer International Publishing
Cham
Pages 475-501
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=Reasoning%20about%20a%20machine%20with%20local%20capabilities)
[[DBLP]](https://dblp.org/search?q=Reasoning%20about%20a%20machine%20with%20local%20capabilities)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Reasoning%20about%20a%20machine%20with%20local%20capabilities)
[[doi]](https://doi.org/10.1007/978-3-319-89884-1_17)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-319-89884-1)

Notes: 
[CHERI architecture](#CHERI architecture),
[capabilities](#capabilities)\
Papers: 
[skorstengaard:popl:2019](#skorstengaard-popl-2019)\
Referenced by: 
[papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020),
[papers/skorstengaard:popl:2019](#papers-skorstengaard-popl-2019),
[papers/woodruff:isca:2014](#papers-woodruff-isca-2014),
[notes/capabilities](#notes-capabilities),
[notes/cheri-architecture](#notes-cheri-architecture)\


This paper is concerned with reasoning about software running
on a capability machine such as CHERI and, in particular,
proving that the calling convention ensures proper
nesting of function calls no matter how buggy or malicious
the function you're calling may be.
It enforces that, if a function returns,
it can only return to the return address it was given,
with the stack pointer it was given and that it cannot
use some other address or stack pointer or even
re-use values from some earlier invocation of the
function.

The threat model is that neither the caller nor the
callee completely trust each other not to be malicious.
This requires that the caller and callee respect a new
calling convention where the caller is responsible
for creating a suitably restricted environment from
which to call the callee and the callee is responsible
for cleaning up their state before returning to the
callee.

The key to implementing this is a new restricted form
of capability that can only exist in registers or
on the stack (or, more accurately, regions of the
memory that have permission to store these capabilities).

The paper explains and motivates the calling convention
and then describes proofs that the calling convention
achieves the intended goals.
It assumes one new hardware primitive that it requires
to be efficient: clearing a contiguous region of the stack
to prevent capabilities held by a function from leaking
into other functions that happen to share the stack.



[CHERI architecture]: #notes-cheri-architecture
[capabilities]: #notes-capabilities
[skorstengaard:popl:2019]: #papers-skorstengaard-popl-2019
# StkTokens: Enforcing well-bracketed control flow and stack encapsulation using linear capabilities {#papers-skorstengaard-popl-2019}


Lau Skorstengaard, Dominique Devriese, Lars Birkedal
Association for Computing Machinery
New York, NY, USA
January
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=StkTokens%3A%20Enforcing%20well-bracketed%20control%20flow%20and%20stack%20encapsulation%20using%20linear%20capabilities)
[[DBLP]](https://dblp.org/search?q=StkTokens%3A%20Enforcing%20well-bracketed%20control%20flow%20and%20stack%20encapsulation%20using%20linear%20capabilities)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=StkTokens%3A%20Enforcing%20well-bracketed%20control%20flow%20and%20stack%20encapsulation%20using%20linear%20capabilities)
[[doi]](https://doi.org/10.1145/3290332)
[[url]](https://doi.org/10.1145/3290332)

Notes: 
[CHERI architecture](#CHERI architecture),
[capabilities](#capabilities)\
Papers: 
[skorstengaard:esop:2018](#skorstengaard-esop-2018)\
Referenced by: 
[papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020),
[papers/skorstengaard:esop:2018](#papers-skorstengaard-esop-2018),
[papers/woodruff:isca:2014](#papers-woodruff-isca-2014),
[notes/capabilities](#notes-capabilities),
[notes/cheri-architecture](#notes-cheri-architecture)\


This paper follows on from
[an earlier paper by the same authors][skorstengaard:esop:2018]
that looked at how mutually distrusting pieces of code could safely call each other.
In particular, it was concerned about whether the stack and return address were what the caller expected when they called the function.

The earlier paper relied on capability machines that provided “local capabilities” and a primitive for clearing the stack on function return.
This paper relies on capability machines that provide “linear capabilities”.
Linear capabilities are interesting because they cannot be duplicated: if you attempt to copy a linear capability then the source copy is erased.
A consequence of this is that linear capabilities support two extra operations: “split” to partition the memory region accessible by a capability and “splice” to merge two adjacent capabilities back into a single capability.
They make essential use of “splice” as part of enforcing that a callee has returned the entire stack when it returns.

The earlier paper showed how to reason about some example code.
This paper develops “fully abstract overlay semantics” which is an alternative semantics for machine code that has an explicit stack and restricts the code to only use the stack in the way that a compiler might expect.
By doing this, they define what they mean by “well bracketed control flow” and they explicitly link the property that they prove to the requirements that a compiler might have on the code.
Nice!



[CHERI architecture]: #notes-cheri-architecture
[capabilities]: #notes-capabilities
[skorstengaard:esop:2018]: #papers-skorstengaard-esop-2018
# A flexible formal verification framework for industrial scale validation {#papers-slobodova-memocode-2011}


Anna Slobodová, Jared Davis, Sol Swords, Warren A. Hunt Jr.
Formal Methods and Models for Codesign (MEMOCODE), 2011 9th IEEE/ACM International Conference on
IEEE
Pages 89-97
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20flexible%20formal%20verification%20framework%20for%20industrial%20scale%20validation)
[[DBLP]](https://dblp.org/search?q=A%20flexible%20formal%20verification%20framework%20for%20industrial%20scale%20validation)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20flexible%20formal%20verification%20framework%20for%20industrial%20scale%20validation)
[[doi]](https://doi.org/10.1109/MEMCOD.2011.5970515)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# Implicit dynamic frames: Combining dynamic frames and separation logic {#papers-smans-ecoop-2009}


Jan Smans, Bart Jacobs, Frank Piessens
ECOOP 2009 -- Object-Oriented Programming
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 148-172
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Implicit%20dynamic%20frames%3A%20Combining%20dynamic%20frames%20and%20separation%20logic)
[[DBLP]](https://dblp.org/search?q=Implicit%20dynamic%20frames%3A%20Combining%20dynamic%20frames%20and%20separation%20logic)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Implicit%20dynamic%20frames%3A%20Combining%20dynamic%20frames%20and%20separation%20logic)
[[doi]](https://doi.org/10.1007/978-3-642-03013-0_8)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-03013-0)

Notes: 
[permission logic](#permission logic),
[separation logic](#separation logic),
[implicit dynamic frames](#implicit dynamic frames)\
Papers: 
[ohearn:cacm:2019](#ohearn-cacm-2019),
[jacobs:nfm:2011](#jacobs-nfm-2011)\


Permission logics are Hoare-style logics for reasoning about heap allocated
data structures and whether a piece of code has permission to access a given
part of the structure.  Their particular strength is the ability to reason
about the lack of aliases – drawing on ideas from linear logic.  The best known
permission logic is
[separation logic][ohearn:cacm:2019];
another permission logic is dynamic frames.  This paper
tackles the problem that dynamic frames have a high annotation overhead because
of the need to define and manipulate “frame annotations” for each method.
Their solution is to infer the frame information directly from the access
assertions in the pre/post-conditions of functions.

A large part of what makes this more concise is that, in a tool like [VeriFast][jacobs:nfm:2011],
I have to write access predicates and (pure) expresssions separately.  For
example, given a pointer “p” to a pair with fields “lo” and “hi”, I might write
a predicate

p->lo ↦ ?l &∗& p->hi ↦ ?h &∗& l ≤ h

To say that I have access to the lo field and its value is “l” and I have
access to the hi field and its value is “h” and “l ≤ h”.  But, this seems
a bit verbose compared with

p->lo ≤ p->hi

Which, just by mentioning “p->lo” and “p->hi” implies that they are accessible.

The ideas in this paper were implemented in the “VeriCool” tool for verifying
concurrent object-oriented languages.




[permission logic]: #notes-permission-logic
[separation logic]: #notes-separation-logic
[implicit dynamic frames]: #notes-implicit-dynamic-frames
[ohearn:cacm:2019]: #papers-ohearn-cacm-2019
[jacobs:nfm:2011]: #papers-jacobs-nfm-2011
# Heap-dependent expressions in separation logic {#papers-smans-fmood-2010}


Jan Smans, Bart Jacobs, Frank Piessens
Formal Techniques for Distributed Systems
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 170-185
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=Heap-dependent%20expressions%20in%20separation%20logic)
[[DBLP]](https://dblp.org/search?q=Heap-dependent%20expressions%20in%20separation%20logic)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Heap-dependent%20expressions%20in%20separation%20logic)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-13464-7)

Notes: 
[permission logic](#permission logic)\




[permission logic]: #notes-permission-logic
# Moving from the design of usable security technologies to the design of useful secure applications {#papers-smetters-nspw-2002}


Diana K. Smetters, Rebecca E. Grinter
Proceedings of the 2002 Workshop on New Security Paradigms
NSPW '02
Virginia Beach, Virginia
Association for Computing Machinery
New York, NY, USA
Pages 82-89
2002
[[Google Scholar]](https://scholar.google.com/scholar?q=Moving%20from%20the%20design%20of%20usable%20security%20technologies%20to%20the%20design%20of%20useful%20secure%20applications)
[[DBLP]](https://dblp.org/search?q=Moving%20from%20the%20design%20of%20usable%20security%20technologies%20to%20the%20design%20of%20useful%20secure%20applications)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Moving%20from%20the%20design%20of%20usable%20security%20technologies%20to%20the%20design%20of%20useful%20secure%20applications)
[[doi]](https://doi.org/10.1145/844102.844117)
[[ISBN]](http://books.google.com/books?vid=ISBN158113598X)
[[url]](https://doi.org/10.1145/844102.844117)




# On the origin of objects {#papers-smith-book-1996}


Brian Cantwell Smith
MIT Press
1996
[[Google Scholar]](https://scholar.google.com/scholar?q=On%20the%20origin%20of%20objects)
[[DBLP]](https://dblp.org/search?q=On%20the%20origin%20of%20objects)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=On%20the%20origin%20of%20objects)
[[ISBN]](http://books.google.com/books?vid=ISBN9780262193634)




# Alias types {#papers-smith-esop-2000}


Frederick Smith, David Walker, Greg Morrisett
Programming Languages and Systems
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 366-381
2000
[[Google Scholar]](https://scholar.google.com/scholar?q=Alias%20types)
[[DBLP]](https://dblp.org/search?q=Alias%20types)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Alias%20types)
[[doi]](https://doi.org/10.1007/3-540-46425-5_24)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-46425-9)

Notes: 
[linear logic](#linear logic),
[permission logic](#permission logic)\
Papers: 
[morrisett:wcsss:1999](#morrisett-wcsss-1999)\


One of the difficult things about reasoning about programs that
modify pointer-based data structures is the possibility of
aliases.
If p and q alias each other then you need to recognize that writing
to "\*p" will modify "\*q".
Around the late 90s, there was a lot of work on how best to
reason about aliasing.
Nowadays, a lot of academic interest seems to have settled on using
separation logic and a lot of practical interest seems to have
settled on Rust's ownership types or C++11's smart pointers, etc.
But what makes this paper interesting to me is that it tackled
one of the outstanding problems in the
[TALx86 paper][morrisett:wcsss:1999].
In particular, because they were interested in reasoning
about assembly code, they could not rely on
simplifications made in high-level languages such as

- In languages that follow RAII, objects are atomically
  initialized as they are allocated.
  But, in assembly language fields of an object are
  initialized one at a time and so it is crucial to be
  able to reason about whether a field has been initialized
  or not.
- In high level languages, you can declare as many local
  variables as you like and they are all logically distinct
  but in assembly language, there is a fixed set of registers
  that get reused and function activation records live on
  a stack where they overwrite previously used activation
  records.
- In high level languages, all local variables are equally
  accessible but in assembly language, registers are more
  accessible than variables on the stack and so you will
  copy variables from one local variable (on the stack)
  to another (in a register) all the time.
  This creates aliases and you have to be able to reason
  about them.
  
Their introduction concludes "Type systems for low-level languages
should represent sharing".

The type system they create is based on ideas from linear logic.
In particular, they augment the type system with aliasing constraints and then they impose linearity constraints to
enforce the connection with aliasing.


The flexibility of the type system is demonstrated by examples
through the paper and a detailed description of how to compile
a Pascal-like "display" mechanism.
(I think that) displays are interesting and challenging
because the display is an array of pointers to nested
stack frames so reasoning about a display requires a lot
of the machinery that they develop.

The paper includes a 21 page appendix in which they prove
type soundness of their system using a proof in the style
of Wright and Felleisen.



[linear logic]: #notes-linear-logic
[permission logic]: #notes-permission-logic
[morrisett:wcsss:1999]: #papers-morrisett-wcsss-1999
# On the foundations of quantitative information flow {#papers-smith-fossacs-2009}


Geoffrey Smith
International Conference on Foundations of Software Science and Computational Structures
Springer
Pages 288-302
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=On%20the%20foundations%20of%20quantitative%20information%20flow)
[[DBLP]](https://dblp.org/search?q=On%20the%20foundations%20of%20quantitative%20information%20flow)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=On%20the%20foundations%20of%20quantitative%20information%20flow)
[[doi]](https://doi.org/10.1007/978-3-642-00596-1_21)

Notes: 
[information flow](#information flow)\


Argues that standard measurement of size of information leaks based on Shannon entropy are not useful because the number cannot be used to bound the resulting threat.  Proposes alternative based on threat that secret can be guessed correctly in a single try that is equivalent to min-entropy.  Uses examples to show that this results in different measures for leaks that intuitively seem different (and that Shannon entropy views as same).  Tackles general form with non-uniform input distribution and derives simpler formulae for special cases.  As it is arguing that prior art has wrong definition, it has good survey of the state of art when written.  Highly cited (500+).



[information flow]: #notes-information-flow
# Decoupled access/execute computer architectures {#papers-smith-tocs-1984}


James E. Smith
ACM Press
Pages 289-308
1984
[[Google Scholar]](https://scholar.google.com/scholar?q=Decoupled%20access/execute%20computer%20architectures)
[[DBLP]](https://dblp.org/search?q=Decoupled%20access/execute%20computer%20architectures)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Decoupled%20access/execute%20computer%20architectures)
[[doi]](https://doi.org/10.1145/357401.357403)

Notes: 
[pipeline parallelism](#pipeline parallelism),
[microarchitecture](#microarchitecture),
[decoupling](#decoupling),
[CRAY architecture](#CRAY architecture)\
Referenced by: 
[notes/decoupling](#notes-decoupling)\



[pipeline parallelism]: #notes-pipeline-parallelism
[microarchitecture]: #notes-microarchitecture
[decoupling]: #notes-decoupling
[CRAY architecture]: #notes-cray-architecture
# The Flask security architecture: System support for diverse security policies {#papers-spencer-security-1999}


Ray Spencer, Stephen Smalley, Peter Loscocco, Mike Hibler, David Andersen, Jay Lepreau
Proceedings of the 8th Conference on USENIX Security Symposium
SSYM'99
Washington, D.C.
USENIX Association
Berkeley, CA, USA
Pages 11-11
1999
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20Flask%20security%20architecture%3A%20System%20support%20for%20diverse%20security%20policies)
[[DBLP]](https://dblp.org/search?q=The%20Flask%20security%20architecture%3A%20System%20support%20for%20diverse%20security%20policies)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20Flask%20security%20architecture%3A%20System%20support%20for%20diverse%20security%20policies)

Notes: 
[information flow](#information flow)\
Papers: 
[efstathopoulos:sosp:2005](#efstathopoulos-sosp-2005),
[zeldovich:osdi:2006](#zeldovich-osdi-2006),
[krohn:sosp:2007](#krohn-sosp-2007)\


This paper by some of my former colleagues in the [Flux group at the University of Utah](https://www.flux.utah.edu) describes the Flask microkernel-based operating system.
Like its successor SE-Linux, Flask adds fine-grained protection checks into the operating system and separates mechanism from policy by making decisions in a separate policy module that is free to implement whatever policy you want.  That is, you are not stuck with whatever Linux or Windows or ... provides by default.

The paper emphasises the importance of being able to control the propagation of a permission once it has been granted and of being able to revoke a permission (including aborting any in-flight operations that depend on the permission).  These are key differences from capability systems.

The design is implemented in the Fluke micro kernel but they emphasise that it is broadly applicable. (Part of their mechanism allows for delegation to allow a server to act on behalf of several different clients using the permissions of those clients.  It is not clear to me whether that would be as easy in a monolithic kernel.)
For performance reasons, they cache permissions.

The gap in the story is that creating policies and ensuring that the set of checks you implement implements your desired policy is quite hard.  This gap was tackled in a succession of other OSes such as
[Asbestos][efstathopoulos:sosp:2005],
[HiStar][zeldovich:osdi:2006] 
and
[Flume][krohn:sosp:2007].

_Personal note: I joined the Flux group as Flask was being completed.  I think part of the plan was that I would work on creating a policy language for Flask.  Alas, I had no idea how to tackle this problem so I worked on component-based operating systems instead._



[information flow]: #notes-information-flow
[efstathopoulos:sosp:2005]: #papers-efstathopoulos-sosp-2005
[zeldovich:osdi:2006]: #papers-zeldovich-osdi-2006
[krohn:sosp:2007]: #papers-krohn-sosp-2007
# Automatic refinement checking of pipelines with out-of-order execution {#papers-srinivasan-ieeetoc-2010}


Sudarshan K. Srinivasan
IEEE Computer Society
Los Alamitos, CA, USA
Pages 1138-1144
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=Automatic%20refinement%20checking%20of%20pipelines%20with%20out-of-order%20execution)
[[DBLP]](https://dblp.org/search?q=Automatic%20refinement%20checking%20of%20pipelines%20with%20out-of-order%20execution)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automatic%20refinement%20checking%20of%20pipelines%20with%20out-of-order%20execution)
[[doi]](https://doi.org/10.1109/TC.2010.18)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# The ARM scalable vector extension {#papers-stephens-micro-2017}


Nigel Stephens, Stuart Biles, Matthias Boettcher, Jacob Eapen, Mbou Eyole, Giacomo Gabrielli, Matt Horsnell, Grigorios Magklis, Alejandro Martinez, Nathanael Premillieu, Alastair D. Reid, Alejandro Rico, Paul Walker
Pages 26-39
March
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20ARM%20scalable%20vector%20extension)
[[DBLP]](https://dblp.org/search?q=The%20ARM%20scalable%20vector%20extension)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20ARM%20scalable%20vector%20extension)
[[doi]](https://doi.org/10.1109/MM.2017.35)

Notes: 
[Arm architecture](#Arm architecture),
[instruction set architecture](#instruction set architecture),
[SIMD](#SIMD),
[vector architecture](#vector architecture)\




[Arm architecture]: #notes-arm-architecture
[instruction set architecture]: #notes-instruction-set-architecture
[SIMD]: #notes-simd
[vector architecture]: #notes-vector-architecture
# Driller: Augmenting fuzzing through selective symbolic execution {#papers-stephens-ndss-2016}


Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu Wang, Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, Giovanni Vigna
23rd Annual Network and Distributed System Security Symposium, NDSS 2016, San Diego, California, USA, February 21-24, 2016
The Internet Society
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Driller%3A%20Augmenting%20fuzzing%20through%20selective%20symbolic%20execution)
[[DBLP]](https://dblp.org/search?q=Driller%3A%20Augmenting%20fuzzing%20through%20selective%20symbolic%20execution)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Driller%3A%20Augmenting%20fuzzing%20through%20selective%20symbolic%20execution)
[[doi]](https://doi.org/10.14722/ndss.2016.23368)
[[url]](http://wp.internetsociety.org/ndss/wp-content/uploads/sites/25/2017/09/driller-augmenting-fuzzing-through-selective-symbolic-execution.pdf)

Notes: 
[fuzz testing](#fuzz testing),
[symbolic execution](#symbolic execution)\



[fuzz testing]: #notes-fuzz-testing
[symbolic execution]: #notes-symbolic-execution
# Processor memory system verification using DOGReL: a language for specifying end-to-end properties {#papers-stewart-difts-2014}


Daryl Stewart, David Gilday, Daniel Nevill, Thomas Roberts
International Workshop on Design and Implementation of Formal Tools and Systems
DIFTS '14
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=Processor%20memory%20system%20verification%20using%20DOGReL%3A%20a%20language%20for%20specifying%20end-to-end%20properties)
[[DBLP]](https://dblp.org/search?q=Processor%20memory%20system%20verification%20using%20DOGReL%3A%20a%20language%20for%20specifying%20end-to-end%20properties)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Processor%20memory%20system%20verification%20using%20DOGReL%3A%20a%20language%20for%20specifying%20end-to-end%20properties)

Notes: 
[weak memory](#weak memory),
[CPU verification](#CPU verification)\



[weak memory]: #notes-weak-memory
[CPU verification]: #notes-cpu-verification
# SMT proof checking using a logical framework {#papers-stump-fmsd-2013}


Aaron Stump, Duckki Oe, Andrew Reynolds, Liana Hadarean, Cesare Tinelli
Springer
Pages 91-118
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=SMT%20proof%20checking%20using%20a%20logical%20framework)
[[DBLP]](https://dblp.org/search?q=SMT%20proof%20checking%20using%20a%20logical%20framework)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=SMT%20proof%20checking%20using%20a%20logical%20framework)
[[doi]](https://doi.org/10.1007/s10703-012-0163-3)

Notes: 
[SMT solver](#SMT solver)\
Papers: 
[brummayer:sat:2010](#brummayer-sat-2010),
[mansur:arxiv:2020](#mansur-arxiv-2020),
[barrett:mlf:2015](#barrett-mlf-2015)\
Referenced by: 
[papers/barrett:mlf:2015](#papers-barrett-mlf-2015),
[papers/brummayer:sat:2010](#papers-brummayer-sat-2010),
[papers/mansur:arxiv:2020](#papers-mansur-arxiv-2020),
[notes/smt-solver](#notes-smt-solver)\



[SMT solver]: #notes-smt-solver
[brummayer:sat:2010]: #papers-brummayer-sat-2010
[mansur:arxiv:2020]: #papers-mansur-arxiv-2020
[barrett:mlf:2015]: #papers-barrett-mlf-2015
# A survey of computer hardware description languages in the U.S.A. {#papers-su-computer-1974}


Stephen Y. H. Su
Pages 45-51
Dec
1974
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20survey%20of%20computer%20hardware%20description%20languages%20in%20the%20U.S.A.)
[[DBLP]](https://dblp.org/search?q=A%20survey%20of%20computer%20hardware%20description%20languages%20in%20the%20U.S.A.)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20survey%20of%20computer%20hardware%20description%20languages%20in%20the%20U.S.A.)
[[doi]](https://doi.org/10.1109/MC.1974.6323411)

Notes: 
[ISA specification](#ISA specification),
[ISPS](#ISPS),
[RTL](#RTL)\



[ISA specification]: #notes-isa-specification
[ISPS]: #notes-isps
[RTL]: #notes-rtl
# Exploiting task and data parallelism on a multicomputer {#papers-subhlok-ppopp-1993}


Jaspal Subhlok, James M. Stichnoth, David R. O'Hallaron, Thomas R. Gross
Proceedings of the Fourth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming
PPOPP '93
San Diego, California, USA
ACM
New York, NY, USA
Pages 13-22
1993
[[Google Scholar]](https://scholar.google.com/scholar?q=Exploiting%20task%20and%20data%20parallelism%20on%20a%20multicomputer)
[[DBLP]](https://dblp.org/search?q=Exploiting%20task%20and%20data%20parallelism%20on%20a%20multicomputer)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Exploiting%20task%20and%20data%20parallelism%20on%20a%20multicomputer)
[[doi]](https://doi.org/10.1145/155332.155334)
[[ISBN]](http://books.google.com/books?vid=ISBN0-89791-589-5)

Notes: 
[data parallelism](#data parallelism)\



[data parallelism]: #notes-data-parallelism
# Evaluating general purpose automated theorem proving systems {#papers-sutcliffe-ai-2001}


Geoff Sutcliffe, Christian Suttner
Pages 39 - 54
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=Evaluating%20general%20purpose%20automated%20theorem%20proving%20systems)
[[DBLP]](https://dblp.org/search?q=Evaluating%20general%20purpose%20automated%20theorem%20proving%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Evaluating%20general%20purpose%20automated%20theorem%20proving%20systems)
[[doi]](https://doi.org/https://doi.org/10.1016/S0004-3702(01)00113-8)
[[url]](http://www.sciencedirect.com/science/article/pii/S0004370201001138)

Notes: 
[verification competition](#verification competition)\


This may have been the first [verification competition] so an interesting
place to look to see how the competitions developed.



[verification competition]: #notes-verification-competition
# IEEE standard for SystemVerilog - Unified hardware design, specification, and verification language {#papers-systemverilog-ieee-2013}


IEEE
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=IEEE%20standard%20for%20SystemVerilog%20-%20Unified%20hardware%20design%2C%20specification%2C%20and%20verification%20language)
[[DBLP]](https://dblp.org/search?q=IEEE%20standard%20for%20SystemVerilog%20-%20Unified%20hardware%20design%2C%20specification%2C%20and%20verification%20language)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=IEEE%20standard%20for%20SystemVerilog%20-%20Unified%20hardware%20design%2C%20specification%2C%20and%20verification%20language)
[[doi]](https://doi.org/10.1109/IEEESTD.2013.6469140)

Notes: 
[RTL](#RTL)\
Referenced by: 
[notes/rtl](#notes-rtl)\



[RTL]: #notes-rtl
# Scalable translation validation of unverified legacy OS code {#papers-tahat-fmcad-2019}


Amer Tahat, Sarang Joshi, Pronnoy Goswami, Binoy Ravindran
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Scalable%20translation%20validation%20of%20unverified%20legacy%20OS%20code)
[[DBLP]](https://dblp.org/search?q=Scalable%20translation%20validation%20of%20unverified%20legacy%20OS%20code)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Scalable%20translation%20validation%20of%20unverified%20legacy%20OS%20code)
[[doi]](https://doi.org/10.23919/FMCAD.2019.8894252)

Notes: 
[translation validation](#translation validation),
[Arm architecture](#Arm architecture),
[ASL](#ASL),
[PVS theorem prover](#PVS theorem prover)\


Describes a toolchain for translation validation of radere2 reverse engineering
tool using the [ASL] specification of the [Arm architecture] based on the PVS7 theorem prover.

Uses multiple techniques to validate translation of ASL to PVS7.
Tested using 370 functions extracted from Linux and Google's Zircon OS.
Limited to loop-free leaf functions.



[translation validation]: #notes-translation-validation
[Arm architecture]: #notes-arm-architecture
[ASL]: #notes-asl
[PVS theorem prover]: #notes-pvs-theorem-prover
# CLKSCREW: Exposing the perils of security-oblivious energy management {#papers-tang-sec-2017}


Adrian Tang, Simha Sethumadhavan, Salvatore Stolfo
Proceedings of the 26th USENIX Conference on Security Symposium
SEC'17
Vancouver, BC, Canada
USENIX Association
Berkeley, CA, USA
Pages 1057-1074
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=CLKSCREW%3A%20Exposing%20the%20perils%20of%20security-oblivious%20energy%20management)
[[DBLP]](https://dblp.org/search?q=CLKSCREW%3A%20Exposing%20the%20perils%20of%20security-oblivious%20energy%20management)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=CLKSCREW%3A%20Exposing%20the%20perils%20of%20security-oblivious%20energy%20management)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-931971-40-9)
[[url]](https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-tang.pdf)

Notes: 
[side channel](#side channel),
[microarchitecture](#microarchitecture)\



[side channel]: #notes-side-channel
[microarchitecture]: #notes-microarchitecture
# A practical approach to exploiting coarse-grained pipeline parallelism in C programs {#papers-thies-micro-2007}


William Thies, Vikram Chandrasekhar, Saman P. Amarasinghe
Proceedings of the 40th Annual IEEE/ACM International Symposium on Microarchitecture
MICRO 40
IEEE Computer Society
Washington, DC, USA
Pages 356-369
2007
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20practical%20approach%20to%20exploiting%20coarse-grained%20pipeline%20parallelism%20in%20C%20programs)
[[DBLP]](https://dblp.org/search?q=A%20practical%20approach%20to%20exploiting%20coarse-grained%20pipeline%20parallelism%20in%20C%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20practical%20approach%20to%20exploiting%20coarse-grained%20pipeline%20parallelism%20in%20C%20programs)
[[doi]](https://doi.org/10.1109/MICRO.2007.7)
[[ISBN]](http://books.google.com/books?vid=ISBN0-7695-3047-8)

Notes: 
[pipeline parallelism](#pipeline parallelism)\



[pipeline parallelism]: #notes-pipeline-parallelism
# Teleport messaging for distributed stream programs {#papers-thies-ppopp-2005}


William Thies, Michal Karczmarek, Janis Sermulins, Rodric M. Rabbah, Saman P. Amarasinghe
PPoPP '05: Proceedings of Symposium on Principles and Practice of Parallel Programming
ACM Press
Pages 224-235
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=Teleport%20messaging%20for%20distributed%20stream%20programs)
[[DBLP]](https://dblp.org/search?q=Teleport%20messaging%20for%20distributed%20stream%20programs)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Teleport%20messaging%20for%20distributed%20stream%20programs)
[[doi]](https://doi.org/10.1145/1065944.1065975)
[[ISBN]](http://books.google.com/books?vid=ISBN1-59593-080-9)

Notes: 
[stream processing](#stream processing)\



[stream processing]: #notes-stream-processing
# Parameterized unit tests {#papers-tillmann-fse-2005}


Nikolai Tillmann, Wolfram Schulte
Proceedings of the 10th European Software Engineering Conference Held Jointly with 13th ACM SIGSOFT International Symposium on Foundations of Software Engineering
ESEC/FSE-13
Lisbon, Portugal
Association for Computing Machinery
New York, NY, USA
Pages 253-262
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=Parameterized%20unit%20tests)
[[DBLP]](https://dblp.org/search?q=Parameterized%20unit%20tests)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Parameterized%20unit%20tests)
[[doi]](https://doi.org/10.1145/1081706.1081749)
[[ISBN]](http://books.google.com/books?vid=ISBN1595930140)
[[url]](https://doi.org/10.1145/1081706.1081749)

Notes: 
[symbolic execution](#symbolic execution),
[unit tests](#unit tests),
[property-based testing](#property-based testing),
[SMT solver](#SMT solver)\


Parameterized unit tests are a form of [property-based testing] that
generalizes traditional unit tests.  The tests can be instantiated with
concrete values to serve as traditional tests, they can be verified using
[symbolic execution] or, to support modular verification, they can be used as
axioms in the spirit of algebraic specification to use when verifying calls to
a library.

This was implemented for .NET on an early [symbolic execution] tool
using early [SMT solver]s.
It is evaluated on eight benchmarks (qsort, triangle, hashtable, bad,
linkedlist, red-black tree).

The paper has a lengthy related/future work section that cites lots of early
(forgotten?) work on test generation from formal specifications from the '90s.



[symbolic execution]: #notes-symbolic-execution
[unit tests]: #notes-unit-tests
[property-based testing]: #notes-property-based-testing
[SMT solver]: #notes-smt-solver
# Complete information flow tracking from the gates up {#papers-tiwari-asplos-2009}


Mohit Tiwari, Hassan M. G. Wassel, Bita Mazloom, Shashidhar Mysore, Frederic T. Chong, Timothy Sherwood
ACM Sigplan Notices
ACM
Pages 109-120
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Complete%20information%20flow%20tracking%20from%20the%20gates%20up)
[[DBLP]](https://dblp.org/search?q=Complete%20information%20flow%20tracking%20from%20the%20gates%20up)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Complete%20information%20flow%20tracking%20from%20the%20gates%20up)
[[doi]](https://doi.org/10.1145/1508244.1508258)

Notes: 
[information flow](#information flow)\


Builds on ideas also described in [Theoretical analysis of gate-level information flow tracking](oberg:dac:2010) of adding "shadow circuits" that calculate whether each wire/flop in a processor depends on some initial set of untrusted values.

This paper describes a processor with automatically added shadow circuits.  The main problem is that conventional branching/looping means that if the PC becomes untrusted then all other state becomes untrusted in the next few cycles and if a pointer becomes untrusted, then all memory becomes untrusted after the next write through that pointer.  They solve this by, instead, providing predication, fixed iteration count loops and only allowing loop counters as address offsets.

The processor is 5 stages but is not pipelined.  They compare with NIOS-II and are 70% more gates (but not quite an apples-for-apples comparison).

The related work section covers previous hardware based security tracking features quite thoroughly because they claim to be the first processor of their type.



[information flow]: #notes-information-flow
# Execution leases: A hardware-supported mechanism for enforcing strong non-interference {#papers-tiwari-isca-2009}


Mohit Tiwari, Xun Li, Hassan M. G. Wassel, Frederic T. Chong, Timothy Sherwood
Proceedings of the 42nd Annual IEEE/ACM International Symposium on Microarchitecture
ACM
Pages 493-504
2009
[[Google Scholar]](https://scholar.google.com/scholar?q=Execution%20leases%3A%20A%20hardware-supported%20mechanism%20for%20enforcing%20strong%20non-interference)
[[DBLP]](https://dblp.org/search?q=Execution%20leases%3A%20A%20hardware-supported%20mechanism%20for%20enforcing%20strong%20non-interference)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Execution%20leases%3A%20A%20hardware-supported%20mechanism%20for%20enforcing%20strong%20non-interference)
[[doi]](https://doi.org/10.1145/1669112.1669174)

Notes: 
[information flow](#information flow),
[non-interference](#non-interference)\
Referenced by: 
[notes/non-interference](#notes-non-interference)\




[information flow]: #notes-information-flow
[non-interference]: #notes-non-interference
# Crafting a usable microkernel, processor, and I/O system with strict and provable information flow security {#papers-tiwari-isca-2011}


Mohit Tiwari, Jason K. Oberg, Xun Li, Jonathan Valamehr, Timothy Levin, Ben Hardekopf, Ryan Kastner, Frederic T. Chong, Timothy Sherwood
ACM SIGARCH Computer Architecture News
ACM
Pages 189-200
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=Crafting%20a%20usable%20microkernel%2C%20processor%2C%20and%20I/O%20system%20with%20strict%20and%20provable%20information%20flow%20security)
[[DBLP]](https://dblp.org/search?q=Crafting%20a%20usable%20microkernel%2C%20processor%2C%20and%20I/O%20system%20with%20strict%20and%20provable%20information%20flow%20security)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Crafting%20a%20usable%20microkernel%2C%20processor%2C%20and%20I/O%20system%20with%20strict%20and%20provable%20information%20flow%20security)
[[doi]](https://doi.org/10.1145/2000064.2000087)

Notes: 
[information flow](#information flow)\




[information flow]: #notes-information-flow
# Crust: A bounded verifier for Rust {#papers-toman-ase-2015}


John Toman, Stuart Pernsteiner, Emina Torlak
2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE)
Pages 75-80
November
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=Crust%3A%20A%20bounded%20verifier%20for%20Rust)
[[DBLP]](https://dblp.org/search?q=Crust%3A%20A%20bounded%20verifier%20for%20Rust)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Crust%3A%20A%20bounded%20verifier%20for%20Rust)
[[doi]](https://doi.org/10.1109/ASE.2015.77)

Notes: 
[Rust language](#Rust language),
[bounded verification](#bounded verification),
[CBMC verifier](#CBMC verifier),
[Rust unsafe code](#Rust unsafe code),
[undefined behaviour](#undefined behaviour)\
Papers: 
[jung:popl:2017](#jung-popl-2017)\
Referenced by: 
[notes/rust-language](#notes-rust-language)\


One of the key strengths and weaknesses of Rust is the ability to extend its
typesystem with libraries that do not follow Rust's typesystem (i.e., they are
"unsafe") but that (we hope) do not break the Rust semantics that Rust's
typesystem is meant to enforce.
This paper describes a bounded model checking approach to verifying these
libraries for the kinds of error that violate Rust's typesystem.
The tool is demonstrated on three libraries and is able to detect
bugs in old versions of the libraries.

Their approach has three phases:

1. Exhaustive generation of sequences of calls to the library up to some
   size bound where sequences include all possible levels of sharing in order
   to test all forms of aliasing.
   The sequences of calls are followed by assertions to check for aliasing
   in the results of the call sequences that would contravene the Rust
   semantics.

2. Translation of the Rust code to C using a custom backend for the rustc Rust
   compiler.

3. Uses the CBMC bounded model checker for C to verify the translated code.

(They point out that the last two steps could be replaced by using a bounded
model checker such as LLBMC that would verify the LLVM IR code generated
inside the rustc compiler.)

It is useful to compare this with the
[Rustbelt paper][jung:popl:2017].
The Crust approach in this paper uses bounded model checking to automatically
and thoroughly
verify the code for certain classes of problem up to some bound
while the Rustbelt paper uses the Coq interactive theorem prover to manually verify
similar libraries that have been manually transcribed into
a similar language they call "lamda-rust".

I really like this work but it has a few limitations that are worth mentioning.
The focus is on detecting aliasing issues and does not appear to detect
concurrency issues or similar.
The aliasing detection is based on comparing pointers returned by library API
calls but it is not clear whether could be other forms of aliasing that
break the Rust semantics but do not show up as aliasing between
externally revealed pointers.
The Rust-to-C translation cannot handle closures or dynamic dispatch.
If the generated sequence generates a panic, this is ignored instead of
being reported as a failure – this feels like a missed opportunity.




[Rust language]: #notes-rust-language
[bounded verification]: #notes-bounded-verification
[CBMC verifier]: #notes-cbmc-verifier
[Rust unsafe code]: #notes-rust-unsafe-code
[undefined behaviour]: #notes-undefined-behaviour
[jung:popl:2017]: #papers-jung-popl-2017
# Growing solver-aided languages with Rosette {#papers-torlak-onward-2013}


Emina Torlak, Rastislav Bodik
Proceedings of the 2013 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming & Software
Onward! 2013
Indianapolis, Indiana, USA
ACM
New York, NY, USA
Pages 135-152
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Growing%20solver-aided%20languages%20with%20Rosette)
[[DBLP]](https://dblp.org/search?q=Growing%20solver-aided%20languages%20with%20Rosette)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Growing%20solver-aided%20languages%20with%20Rosette)
[[doi]](https://doi.org/10.1145/2509578.2509586)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-2472-4)
[[url]](http://doi.acm.org/10.1145/2509578.2509586)

Notes: 
[Rosette solver](#Rosette solver),
[symbolic evaluation](#symbolic evaluation)\
Referenced by: 
[notes/rosette-solver](#notes-rosette-solver)\



[Rosette solver]: #notes-rosette-solver
[symbolic evaluation]: #notes-symbolic-evaluation
# A lightweight symbolic virtual machine for solver-aided host languages {#papers-torlak-pldi-2014}


Emina Torlak, Rastislav Bodik
Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation
PLDI'14
Edinburgh, United Kingdom
ACM
New York, NY, USA
Pages 530-541
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20lightweight%20symbolic%20virtual%20machine%20for%20solver-aided%20host%20languages)
[[DBLP]](https://dblp.org/search?q=A%20lightweight%20symbolic%20virtual%20machine%20for%20solver-aided%20host%20languages)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20lightweight%20symbolic%20virtual%20machine%20for%20solver-aided%20host%20languages)
[[doi]](https://doi.org/10.1145/2594291.2594340)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-2784-8)
[[url]](http://doi.acm.org/10.1145/2594291.2594340)

Notes: 
[Rosette solver](#Rosette solver),
[symbolic evaluation](#symbolic evaluation),
[symbolic execution](#symbolic execution),
[bounded model checking](#bounded model checking)\
Papers: 
[nelson:sosp:2019](#nelson-sosp-2019)\
Referenced by: 
[papers/nelson:sosp:2019](#papers-nelson-sosp-2019),
[papers/weitz:icfp:2017](#papers-weitz-icfp-2017),
[notes/rosette-solver](#notes-rosette-solver)\


Rosetta is a Racket DSL for implementing Solver-aided Domain Specific
Languages (SDSLs): tools based on solvers that support
angelic execution, debugging, verifying properties and
synthesis.
A key feature of Rosetta is "symbolic reflection" – that allows
Racket code to be symbolically evaluated (in addition to being
executable in the normal way).

Rosetta lies somewhere between symbolic execution (that enumerates
all paths and solves constraints along each path)
and bounded model checking.
Like bounded model checking, Rosetta depends on finitizing the
program being reasoned about but it differs in that the
program may be "self-finitizing": instead of simply unrolling loops
to some limit, any constant parts of the input/program, are used
to determine how much to unroll loops.
Indeed, a key insight seems to be that SDSL's have a significant
amount of concrete evaluation in loops/recursion.

Rosetta also differs from bounded model-checking in how it merges symbolic
values: for each shape of the values, a separate symbolic value is constructed.

Rosetta is demonstrated/evaluated on an OpenCL synthesis task, an XPath
synthesis task and an information flow verification task.

This forms the basis of a number of other projects including
[Serval][nelson:sosp:2019].



[Rosette solver]: #notes-rosette-solver
[symbolic evaluation]: #notes-symbolic-evaluation
[symbolic execution]: #notes-symbolic-execution
[bounded model checking]: #notes-bounded-model-checking
[nelson:sosp:2019]: #papers-nelson-sosp-2019
# VIS speeds new media processing {#papers-tremblay-micro-1996}


Marc Tremblay, J. Michael O'Connor, Venkatesh Narayanan, Liang He
IEEE Computer Society Press
Los Alamitos, CA, USA
Pages 10-20
August
1996
[[Google Scholar]](https://scholar.google.com/scholar?q=VIS%20speeds%20new%20media%20processing)
[[DBLP]](https://dblp.org/search?q=VIS%20speeds%20new%20media%20processing)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=VIS%20speeds%20new%20media%20processing)
[[doi]](https://doi.org/10.1109/40.526921)

Notes: 
[vector architecture](#vector architecture),
[instruction set architecture](#instruction set architecture),
[SIMD](#SIMD)\



[vector architecture]: #notes-vector-architecture
[instruction set architecture]: #notes-instruction-set-architecture
[SIMD]: #notes-simd
# Local reasoning about while-loops {#papers-tuerk-vstte-2010}


Thomas Tuerk
Pages 29
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=Local%20reasoning%20about%20while-loops)
[[DBLP]](https://dblp.org/search?q=Local%20reasoning%20about%20while-loops)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Local%20reasoning%20about%20while-loops)

Notes: 
[loop invariant](#loop invariant),
[separation logic](#separation logic),
[magic wand](#magic wand),
[Verifast verifier](#Verifast verifier)\
Papers: 
[hehner:vstte:2008](#hehner-vstte-2008),
[schwerhoff:ecoop:2015](#schwerhoff-ecoop-2015),
[jacobs:nfm:2011](#jacobs-nfm-2011)\
Referenced by: 
[papers/hehner:vstte:2008](#papers-hehner-vstte-2008),
[papers/leino:lpair:2010](#papers-leino-lpair-2010),
[notes/loop-invariant](#notes-loop-invariant)\


As
[Hehner had previously discovered][hehner:vstte:2008],
we are reasoning about loops in the wrong way.
Instead of using loop invariants that describe what the loop has done so far,
we should be using loop specifications that describe what the loop will do
in the future.
This change enables local reasoning (in the usual "separation logic" sense)
about loops because it focusses on what the loop does and because
it eliminates the need to describe partial data structures such as
the initial segment of a list.

The starting point of this paper is the observation that verifying
recursive functions is simpler than verifying loops even though we
can mechanically transform one into the other.
The difference is that the pre/post-conditions of a function
specify the complete behaviour of the function whereas
a loop invariant describes a series of states at the beginning/end
of each iteration of the loop.
In practice, this means that the loop invariant has to describe
what has been done so far and so invariants typically have the
form

    "Initial segment of data structure has been changed" &&
    "Remaining segment of data structure has not yet been changed"

whereas this paper argues that you should just specify

    "What change will be made to remaining segment of data structure"

Omitting the description of what has been done so far enables
local reasoning: we focus on the action of the remaining iterations
of the loop.

The paper describes how to generalize the classic Hoare-logic
rule for reasoning about loops.
The rule is more complex than we are used to but it is simpler
to use in practice.

The argument that it is simpler is made with examples including
list length, array increment, list filtering, list copy
and binary trees.
Of these, the killer argument is probably binary trees because,
while there are well-known ways of describing initial
segments of lists and arrays, describing a partial binary
tree is harder and this approach completely avoids the need.

This paper notes that "magic wands" could also have been used
to avoid the need to define partial datastructures but that
reasoning about this is harder.
(This might have changed with the later development of
[lightweight magic wands][schwerhoff:ecoop:2015]).

The approach in this paper is implemented in the author's
"Holfoot" tool and also in
[VeriFast][jacobs:nfm:2011].



[loop invariant]: #notes-loop-invariant
[separation logic]: #notes-separation-logic
[magic wand]: #notes-magic-wand
[Verifast verifier]: #notes-verifast-verifier
[hehner:vstte:2008]: #papers-hehner-vstte-2008
[schwerhoff:ecoop:2015]: #papers-schwerhoff-ecoop-2015
[jacobs:nfm:2011]: #papers-jacobs-nfm-2011
# Simple verification of Rust programs via functional purification {#papers-ullrich-msc-2016}


Sebastian Ullrich
Karlsruhe Institut of Technology
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=Simple%20verification%20of%20Rust%20programs%20via%20functional%20purification)
[[DBLP]](https://dblp.org/search?q=Simple%20verification%20of%20Rust%20programs%20via%20functional%20purification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Simple%20verification%20of%20Rust%20programs%20via%20functional%20purification)

Notes: 
[Rust language](#Rust language)\
Papers: 
[matsushita:esop:2020](#matsushita-esop-2020),
[demoura:cade:2015](#demoura-cade-2015)\
Referenced by: 
[papers/matsushita:esop:2020](#papers-matsushita-esop-2020)\


Transpiles Rust code to a functional program in Lean ([demoura:cade:2015])
to allow verification of Rust programs in Lean.
Demonstrated on a binary search implementation.

The implementation is [here](https://github.com/Kha/electrolysis).



[Rust language]: #notes-rust-language
[matsushita:esop:2020]: #papers-matsushita-esop-2020
[demoura:cade:2015]: #papers-demoura-cade-2015
# Design, implementation and verification of an extensible and modular hypervisor framework {#papers-vasudevan-secpriv-2013}


Amit Vasudevan, Sagar Chaki, Limin Jia, Jonathan McCune, James Newsome, Anupam Datta
2013 IEEE Symposium on Security and Privacy
IEEE
Pages 430-444
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Design%2C%20implementation%20and%20verification%20of%20an%20extensible%20and%20modular%20hypervisor%20framework)
[[DBLP]](https://dblp.org/search?q=Design%2C%20implementation%20and%20verification%20of%20an%20extensible%20and%20modular%20hypervisor%20framework)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Design%2C%20implementation%20and%20verification%20of%20an%20extensible%20and%20modular%20hypervisor%20framework)





# überSpark: Enforcing verifiable object abstractions for automated compositional security analysis of a hypervisor {#papers-vasudevan-usenix-2016}


Amit Vasudevan, Sagar Chaki, Petros Maniatis, Limin Jia, Anupam Datta
25th USENIX Security Symposium (USENIX Security 16)
USENIX Association
Austin, TX
Pages 87-104
August
2016
[[Google Scholar]](https://scholar.google.com/scholar?q=%C3%BCberSpark%3A%20Enforcing%20verifiable%20object%20abstractions%20for%20automated%20compositional%20security%20analysis%20of%20a%20hypervisor)
[[DBLP]](https://dblp.org/search?q=%C3%BCberSpark%3A%20Enforcing%20verifiable%20object%20abstractions%20for%20automated%20compositional%20security%20analysis%20of%20a%20hypervisor)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=%C3%BCberSpark%3A%20Enforcing%20verifiable%20object%20abstractions%20for%20automated%20compositional%20security%20analysis%20of%20a%20hypervisor)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-931971-32-4)
[[url]](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/vasudevan)

Notes: 
[Frama-C verifier](#Frama-C verifier),
[CompCert compiler](#CompCert compiler),
[information flow](#information flow)\
Referenced by: 
[notes/annotation-burden](#notes-annotation-burden)\


Verifies properties of a concurrent micro-hypervisor uXMHF using the [Frama-C verifier]) with some custom plugins and using CompCert to compile.
Assembly language and a hardware model are accomodated by invoking via function calls and providing a C equivalent function that accesses shadow C variables that model changes in hardware state.
Interestingly, the hypervisor also allows unverified plugins - but all unverified plugins are run in a sandbox (and incur higher overhead).

The core of the idea is to structure the hypervisor as a set of singleton objects
and prove isolation properties, etc. about each object.
(I am unclear how/if a singleton object differs from a module!)

Verification is of security invariants (not full functional correctness).
Invariants cover memory separation, control flow integrity and [information flow].
Verification is automatic but depends on annotation.
The annotation burden is around 110% though it is not clear what fraction of that is really a specification burden.

The related work section in this paper is really good – covering both work in unverified OSes and verified OSes.

Also, the detail on the proof structure and the invariants is unusually good.
(And the corresponding tech report apparently has even more detail!)



[Frama-C verifier]: #notes-frama-c-verifier
[CompCert compiler]: #notes-compcert-compiler
[information flow]: #notes-information-flow
# Active libraries: Rethinking the roles of compilers and libraries {#papers-veldhuizen-oo-1998}


Todd L. Veldhuizen, Dennis Gannon
Proceedings of the SIAM Workshop on Object Oriented Methods for Inter-operable Scientific and Engineering Computing (OO'98
SIAM Press
1998
[[Google Scholar]](https://scholar.google.com/scholar?q=Active%20libraries%3A%20Rethinking%20the%20roles%20of%20compilers%20and%20libraries)
[[DBLP]](https://dblp.org/search?q=Active%20libraries%3A%20Rethinking%20the%20roles%20of%20compilers%20and%20libraries)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Active%20libraries%3A%20Rethinking%20the%20roles%20of%20compilers%20and%20libraries)
[[url]](http://arxiv.org/abs/math.NA/9810022)




# Formal verification of superscalar microprocessors with multicycle functional units, exception, and branch prediction {#papers-velev-dac-2000}


Miroslav N. Velev, Randal E. Bryant
Proceedings of the 37th Annual Design Automation Conference
DAC '00
Los Angeles, California, USA
ACM
New York, NY, USA
Pages 112-117
2000
[[Google Scholar]](https://scholar.google.com/scholar?q=Formal%20verification%20of%20superscalar%20microprocessors%20with%20multicycle%20functional%20units%2C%20exception%2C%20and%20branch%20prediction)
[[DBLP]](https://dblp.org/search?q=Formal%20verification%20of%20superscalar%20microprocessors%20with%20multicycle%20functional%20units%2C%20exception%2C%20and%20branch%20prediction)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Formal%20verification%20of%20superscalar%20microprocessors%20with%20multicycle%20functional%20units%2C%20exception%2C%20and%20branch%20prediction)
[[doi]](https://doi.org/10.1145/337292.337331)
[[ISBN]](http://books.google.com/books?vid=ISBN1-58113-187-9)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# Establishing a refinement relation between binaries and abstract code {#papers-verbeek-fmmsd-2019}


Freek Verbeek, Joshua Bockenek, Abhijith Bharadwaj, Ian Roessle, Binoy Ravindran
Proceedings of the 17th ACM-IEEE International Conference on Formal Methods and Models for System Design
ACM
Pages 17
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Establishing%20a%20refinement%20relation%20between%20binaries%20and%20abstract%20code)
[[DBLP]](https://dblp.org/search?q=Establishing%20a%20refinement%20relation%20between%20binaries%20and%20abstract%20code)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Establishing%20a%20refinement%20relation%20between%20binaries%20and%20abstract%20code)
[[doi]](https://doi.org/10.1145/3359986.3361215)





# COASTAL: Combining concolic and fuzzing for Java (competition contribution) {#papers-visser-tacas-2020}


Willem Visser, Jaco Geldenhuys
Tools and Algorithms for the Construction and Analysis of Systems
Springer International Publishing
Cham
Pages 373-377
2020
[[Google Scholar]](https://scholar.google.com/scholar?q=COASTAL%3A%20Combining%20concolic%20and%20fuzzing%20for%20Java%20%28competition%20contribution%29)
[[DBLP]](https://dblp.org/search?q=COASTAL%3A%20Combining%20concolic%20and%20fuzzing%20for%20Java%20%28competition%20contribution%29)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=COASTAL%3A%20Combining%20concolic%20and%20fuzzing%20for%20Java%20%28competition%20contribution%29)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-030-45237-7)

Notes: 
[fuzz testing](#fuzz testing),
[symbolic execution](#symbolic execution),
[SV competition](#SV competition),
[test generation](#test generation)\


This is a nice short, readable description of Coastal which

- maintains two work queues (one for [fuzz testing]
  and one for [symbolic execution])
- uses "strategies" to generate new queue entries from the results of the
  fuzzing and symex engines
- uses "observers" to track assertions, coverage, prune paths, display
  information in a GUI

Coastal was still under development when it was entered in [SV competition].




[fuzz testing]: #notes-fuzz-testing
[symbolic execution]: #notes-symbolic-execution
[SV competition]: #notes-sv-competition
[test generation]: #notes-test-generation
# Annotation inference for separation logic based verifiers {#papers-vogels-fmoods-2011}


Frédéric Vogels, Bart Jacobs, Frank Piessens, Jan Smans
Formal Techniques for Distributed Systems
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 319-333
2011
[[Google Scholar]](https://scholar.google.com/scholar?q=Annotation%20inference%20for%20separation%20logic%20based%20verifiers)
[[DBLP]](https://dblp.org/search?q=Annotation%20inference%20for%20separation%20logic%20based%20verifiers)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Annotation%20inference%20for%20separation%20logic%20based%20verifiers)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-642-21461-5)

Notes: 
[VeriFast verifier](#VeriFast verifier),
[VCC verifier](#VCC verifier),
[separation logic](#separation logic),
[permission logic](#permission logic),
[auto-active verification](#auto-active verification)\
Referenced by: 
[papers/philippaerts:scp:2014](#papers-philippaerts-scp-2014),
[notes/annotation-burden](#notes-annotation-burden)\


One of the challenges in automatic program verification
tools such as
the [VCC verifier]
and
the [VeriFast verifier]
is the amount of annotation required to 
write the specification and 
guide the verification tool to construct a proof.

The VeriFast tool's initial goal was to provide sound,
fast verification for C and Java.
This paper describes three extensions to reduce
the amount of annotation required.
These extensions are implemented outside the small core
and therefore any annotations added cannot cause VeriFast to
produce unsound results.

1. In VeriFast, one often "opens" a predicate
   at the start of a function to expand the predicate's definition
   and "closes" a predicate at the end of a function to trigger proof that
   the predicate holds,
   The first auto-annotations technique is to automatically open/close
   any predicates mentioned in the requires/assumes clauses
   provided the predicates are not recursive.
   The basis for this is a directed graph between predicates
   that mention each other where edges are labelled with side-conditions.

2. In VeriFast, one also explicitly applies lemmas.
   The second auto-annotation aggressively applies lemmas as soon as possible
   (i.e., as soon as they can be triggered) to make all consequences
   available to the prover unless doing so could lead to an exponential
   explosion or would remove facts from the symbolic state.

3. Finally, they perform a shape analysis, which further drives
   open/close, lemma application and also loop invariant generation.


The overall effect of these three inference steps is a dramatic reduction in
the amount of annotation required.  Across eight functions totalling 113 lines
of code, the amount of annotation required drops from 205 lines of annotation
to just 8 lines of annotation.



[VeriFast verifier]: #notes-verifast-verifier
[VCC verifier]: #notes-vcc-verifier
[separation logic]: #notes-separation-logic
[permission logic]: #notes-permission-logic
[auto-active verification]: #notes-auto-active-verification
# Why events are a bad idea (for high-concurrency servers) {#papers-vonbehren-hotos-2003}


Robert von Behren, Jeremy Condit, Eric Brewer
Proceedings of the 9th Conference on Hot Topics in Operating Systems - Volume 9
HOTOS'03
Lihue, Hawaii
USENIX Association
Berkeley, CA, USA
Pages 4
2003
[[Google Scholar]](https://scholar.google.com/scholar?q=Why%20events%20are%20a%20bad%20idea%20%28for%20high-concurrency%20servers%29)
[[DBLP]](https://dblp.org/search?q=Why%20events%20are%20a%20bad%20idea%20%28for%20high-concurrency%20servers%29)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Why%20events%20are%20a%20bad%20idea%20%28for%20high-concurrency%20servers%29)

Notes: 
[threads](#threads),
[events](#events)\
Referenced by: 
[notes/events](#notes-events),
[notes/threads](#notes-threads)\



[threads]: #notes-threads
[events]: #notes-events
# -Overify: Optimizing programs for fast verification {#papers-wagner-hotos-2013}


Jonas Wagner, Volodymyr Kuznetsov, George Candea
14th Workshop on Hot Topics in Operating Systems
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=-Overify%3A%20Optimizing%20programs%20for%20fast%20verification)
[[DBLP]](https://dblp.org/search?q=-Overify%3A%20Optimizing%20programs%20for%20fast%20verification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=-Overify%3A%20Optimizing%20programs%20for%20fast%20verification)

Notes: 
[KLEE verifier](#KLEE verifier)\


This paper explores the benefit of using different optimization options (or
even custom transformations) when compiling a program for optimization.
Their optimization options are over 5000x better than -O0 and 14x better than -O3
for verification using KLEE on their motivating example.
Compared with -O3, their main goal is to reduce the amount of information lost
during compilation.
They mention but do little to address the problem of undefined behaviour in C
causing different compilations to behave differently although they
did look for this in their evaluation and found that
they detected the same bugs with -O0, -O3 and -Overify.

The paper identifies transformations that have a positive or negative effect on verification.
Optimizations discussed are:

- unswitching loops
- loop unrolling
- function inlining
- copy propagation
- constant folding
- allocating variables in registers
- splitting large objects
- preserving information from the compiler: alias information, variable ranges, loop invariants, trip counts, type information
- inserting runtime checks
- using a simplified library (as KLEE already does).

And optimizations that make verification worse are CPU specific optimizations, cache optimizations, padding objects.

One of the payoffs from reading this paper is that I had naïvely expected that
the -O0 version would be easier to verify than the -O2 or -O3 version.  At
least when using KLEE, this is not true.



[KLEE verifier]: #notes-klee-verifier
# A type system for expressive security policies {#papers-walker-popl-2000}


David Walker
Proceedings of the 27th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
POPL'00
Boston, MA, USA
Association for Computing Machinery
New York, NY, USA
Pages 254–267
2000
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20type%20system%20for%20expressive%20security%20policies)
[[DBLP]](https://dblp.org/search?q=A%20type%20system%20for%20expressive%20security%20policies)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20type%20system%20for%20expressive%20security%20policies)
[[doi]](https://doi.org/10.1145/325694.325728)
[[ISBN]](http://books.google.com/books?vid=ISBN1581131259)
[[url]](https://doi.org/10.1145/325694.325728)

Notes: 
[typed assembly language](#typed assembly language)\
Papers: 
[morrisett:wcsss:1999](#morrisett-wcsss-1999)\


These days, many people define security properties based on
some form of intransitive information flow specification.
But in the '90s, Fred Schneider and others were working on
security automata that would monitor the execution of the
program and terminate it if the program violated
the security specification.
For example, a specification might say that if a program
has read a file containing a secret, it cannot then
open a network connection.

This paper builds on work on [Typed Assembly Language][morrisett:wcsss:1999]
to develop rich, expressive type systems to capture
security properties in a type system instead of via
some more ad hoc approach.

At first sight, this merely repeats the work of Schneider
in a different formalism:
they enforce the security policy by inserting the automata
and the checks into the code and then they optimize away
any of the checks that they can show will not fail.
But the key benefit of doing this within a typesystem
is that the transformed code and each step in the optimization can be
typechecked to show that it still enforces the security
policy.
That is, when a check is removed, the system is required to leave enough of
a residue in the code that you can see why the check was
not required.
As a result of this, anyone who receives the code can confirm
that the code will obey the security policy just by
typechecking the code.



[typed assembly language]: #notes-typed-assembly-language
[morrisett:wcsss:1999]: #papers-morrisett-wcsss-1999
# Alias types for recursive data structures {#papers-walker-tic-2001}


David Walker, Greg Morrisett
Types in Compilation
Springer Berlin Heidelberg
Berlin, Heidelberg
Pages 177-206
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=Alias%20types%20for%20recursive%20data%20structures)
[[DBLP]](https://dblp.org/search?q=Alias%20types%20for%20recursive%20data%20structures)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Alias%20types%20for%20recursive%20data%20structures)
[[doi]](https://doi.org/10.1007/3-540-45332-6_7)
[[ISBN]](http://books.google.com/books?vid=ISBN978-3-540-45332-1)

Notes: 
[permission logic](#permission logic),
[linear logic](#linear logic),
[ownership types](#ownership types),
[typed assembly language](#typed assembly language)\
Referenced by: 
[notes/ownership-types](#notes-ownership-types)\




[permission logic]: #notes-permission-logic
[linear logic]: #notes-linear-logic
[ownership types]: #notes-ownership-types
[typed assembly language]: #notes-typed-assembly-language
# Continuation-based multiprocessing {#papers-wand-lfp-1980}


Mitchell Wand
Proceedings of the 1980 ACM Conference on LISP and Functional Programming
LFP '80
Stanford University, California, USA
ACM
New York, NY, USA
Pages 19-28
1980
[[Google Scholar]](https://scholar.google.com/scholar?q=Continuation-based%20multiprocessing)
[[DBLP]](https://dblp.org/search?q=Continuation-based%20multiprocessing)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Continuation-based%20multiprocessing)
[[doi]](https://doi.org/10.1145/800087.802786)

Notes: 
[continuations](#continuations)\



[continuations]: #notes-continuations
# EXOCHI: architecture and programming environment for a heterogeneous multi-core multithreaded system {#papers-wang-pldi-2007}


Perry H. Wang, Jamison D. Collins, Gautham N. Chinya, Hong Jiang, Xinmin Tian, Milind Girkar, Nick Y. Yang, Guei-Yuan Lueh, Hong Wang
Proceedings PLDI 2007
San Diego, California, USA
ACM
New York, NY, USA
Pages 156-166
2007
[[Google Scholar]](https://scholar.google.com/scholar?q=EXOCHI%3A%20architecture%20and%20programming%20environment%20for%20a%20heterogeneous%20multi-core%20multithreaded%20system)
[[DBLP]](https://dblp.org/search?q=EXOCHI%3A%20architecture%20and%20programming%20environment%20for%20a%20heterogeneous%20multi-core%20multithreaded%20system)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=EXOCHI%3A%20architecture%20and%20programming%20environment%20for%20a%20heterogeneous%20multi-core%20multithreaded%20system)
[[doi]](https://doi.org/10.1145/1250734.1250753)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-59593-633-2)

Notes: 
[threads](#threads)\



[threads]: #notes-threads
# KRust: A formal executable semantics of Rust {#papers-wang-tase-2018}


Feng Wang, Fu Song, Min Zhang, Xiaoran Zhu, Jun Zhang
2018 International Symposium on Theoretical Aspects of Software Engineering (TASE)
Pages 44-51
Aug
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=KRust%3A%20A%20formal%20executable%20semantics%20of%20Rust)
[[DBLP]](https://dblp.org/search?q=KRust%3A%20A%20formal%20executable%20semantics%20of%20Rust)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=KRust%3A%20A%20formal%20executable%20semantics%20of%20Rust)
[[doi]](https://doi.org/10.1109/TASE.2018.00014)

Notes: 
[Rust language](#Rust language)\



[Rust language]: #notes-rust-language
# Relational test tables: A practical specification language for evolution and security {#papers-weigl-arxiv-2019}


Alexander Weigl, Mattias Ulbrich, Suhyun Cha, Bernhard Beckert, Birgit Vogel-Heuser
2019
[[Google Scholar]](https://scholar.google.com/scholar?q=Relational%20test%20tables%3A%20A%20practical%20specification%20language%20for%20evolution%20and%20security)
[[DBLP]](https://dblp.org/search?q=Relational%20test%20tables%3A%20A%20practical%20specification%20language%20for%20evolution%20and%20security)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Relational%20test%20tables%3A%20A%20practical%20specification%20language%20for%20evolution%20and%20security)
[[arXiv]](https://arxiv.org/1910.09068)

Notes: 
[test generation](#test generation),
[information flow](#information flow),
[kripke structure](#kripke structure),
[model checking](#model checking),
[unit tests](#unit tests)\


Relational test tables describe sets of traces and constraints on those traces
and (the relational part) between traces and support for stuttering (to allow
for timing differences).

Extends authors previous work that generalized "concrete test tables" to
support verification by replacing concrete input values with constraints.

They target reactive systems so test tables describe sequences of inputs and
outputs with timing constraints.

Compare with approaches from the [model checking] community based on [Kripke
structure]s.

Implementation uses nuXmv and IC3 model checkers and demonstration is based on
a Pick and Place Unit (PPU).




[test generation]: #notes-test-generation
[information flow]: #notes-information-flow
[kripke structure]: #notes-kripke-structure
[model checking]: #notes-model-checking
[unit tests]: #notes-unit-tests
# Rust distilled: An expressive tower of languages {#papers-weiss-arxiv-2018}


Aaron Weiss, Daniel Patterson, Amal Ahmed
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=Rust%20distilled%3A%20An%20expressive%20tower%20of%20languages)
[[DBLP]](https://dblp.org/search?q=Rust%20distilled%3A%20An%20expressive%20tower%20of%20languages)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Rust%20distilled%3A%20An%20expressive%20tower%20of%20languages)
[[arXiv]](https://arxiv.org/1806.02693)
[[url]](http://arxiv.org/abs/1806.02693)

Notes: 
[Rust language](#Rust language)\



[Rust language]: #notes-rust-language
# SpaceSearch: A library for building and verifying solver-aided tools {#papers-weitz-icfp-2017}


Konstantin Weitz, Steven Lyubomirsky, Stefan Heule, Emina Torlak, Michael D. Ernst, Zachary Tatlock
ICFP 2017: Proceedings of the 22nd ACM SIGPLAN International Conference on Functional Programming
Oxford, UK
Pages 25:1-25:28
September
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=SpaceSearch%3A%20A%20library%20for%20building%20and%20verifying%20solver-aided%20tools)
[[DBLP]](https://dblp.org/search?q=SpaceSearch%3A%20A%20library%20for%20building%20and%20verifying%20solver-aided%20tools)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=SpaceSearch%3A%20A%20library%20for%20building%20and%20verifying%20solver-aided%20tools)
[[doi]](https://doi.org/10.1145/3110269)

Notes: 
[Rosette solver](#Rosette solver),
[Coq theorem prover](#Coq theorem prover)\
Papers: 
[torlak:pldi:2014](#torlak-pldi-2014)\
Referenced by: 
[notes/rosette-solver](#notes-rosette-solver)\


Coq embedding of [Rosette's solver aided language][torlak:pldi:2014] inspired by smten.

Factors proof into two parts
with SpaceSearch ADT as the interface between the two.
- Coq proof (interactive) - can use induction, coinduction, higher order, etc.
- Rosette proof (automatic) - limited to first order.

Demonstrated by
- verifying RockSalt against STOKE
- verifying Bagpipe

Found bugs in both.


[Rosette solver]: #notes-rosette-solver
[Coq theorem prover]: #notes-coq-theorem-prover
[torlak:pldi:2014]: #papers-torlak-pldi-2014
# Automatically comparing memory consistency models {#papers-wickerson-popl-2017}


John Wickerson, Mark Batty, Tyler Sorensen, George A. Constantinides
Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages
POPL 2017
Paris, France
ACM
New York, NY, USA
Pages 190-204
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=Automatically%20comparing%20memory%20consistency%20models)
[[DBLP]](https://dblp.org/search?q=Automatically%20comparing%20memory%20consistency%20models)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Automatically%20comparing%20memory%20consistency%20models)
[[doi]](https://doi.org/10.1145/3009837.3009838)
[[ISBN]](http://books.google.com/books?vid=ISBN978-1-4503-4660-3)

Notes: 
[weak memory](#weak memory)\



[weak memory]: #notes-weak-memory
# Formal modeling and verification of microprocessors {#papers-windley-ieeetoc-1995}


Phillip J. Windley
IEEE
Pages 54-72
1995
[[Google Scholar]](https://scholar.google.com/scholar?q=Formal%20modeling%20and%20verification%20of%20microprocessors)
[[DBLP]](https://dblp.org/search?q=Formal%20modeling%20and%20verification%20of%20microprocessors)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Formal%20modeling%20and%20verification%20of%20microprocessors)
[[doi]](https://doi.org/10.1109/12.368009)

Notes: 
[CPU verification](#CPU verification)\



[CPU verification]: #notes-cpu-verification
# From SODA to scotch: The evolution of a wireless baseband processor {#papers-woh-micro-2008}


Mark Woh, Yuan Lin, Sangwon Seo, Scott A. Mahlke, Trevor N. Mudge, Chaitali Chakrabarti, Richard Bruce, Danny Kershaw, Alastair D. Reid, Mladen Wilder, Krisztián Flautner
41st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO-41 2008)
Lake Como, Italy
IEEE Computer Society
Pages 152-163
8-12
November
2008
[[Google Scholar]](https://scholar.google.com/scholar?q=From%20SODA%20to%20scotch%3A%20The%20evolution%20of%20a%20wireless%20baseband%20processor)
[[DBLP]](https://dblp.org/search?q=From%20SODA%20to%20scotch%3A%20The%20evolution%20of%20a%20wireless%20baseband%20processor)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=From%20SODA%20to%20scotch%3A%20The%20evolution%20of%20a%20wireless%20baseband%20processor)
[[doi]](https://doi.org/10.1109/MICRO.2008.4771787)

Notes: 
[SIMD](#SIMD),
[vector architecture](#vector architecture),
[VLIW](#VLIW),
[SDR](#SDR)\
Papers: 
[reid:cases:2008](#reid-cases-2008)\
Referenced by: 
[papers/reid:cases:2008](#papers-reid-cases-2008)\




[SIMD]: #notes-simd
[vector architecture]: #notes-vector-architecture
[VLIW]: #notes-vliw
[SDR]: #notes-sdr
[reid:cases:2008]: #papers-reid-cases-2008
# Design and programming of embedded multiprocessors: An interface-centric approach {#papers-wolf-codes-2004}


Pieter van der Wolf, Erwin A. de Kock, Tomas Henriksson, Wido Kruijtzer, Gerben Essink
Hardware/software codesign and system synthesis, International conference on
IEEE Computer Society
Los Alamitos, CA, USA
Pages 206-217
sep
2004
[[Google Scholar]](https://scholar.google.com/scholar?q=Design%20and%20programming%20of%20embedded%20multiprocessors%3A%20An%20interface-centric%20approach)
[[DBLP]](https://dblp.org/search?q=Design%20and%20programming%20of%20embedded%20multiprocessors%3A%20An%20interface-centric%20approach)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Design%20and%20programming%20of%20embedded%20multiprocessors%3A%20An%20interface-centric%20approach)
[[doi]](https://doi.org/10.1109/CODES+ISSS.2004.17)
[[url]](https://doi.ieeecomputersociety.org/10.1109/CODES+ISSS.2004.17)

Notes: 
[pipeline parallelism](#pipeline parallelism)\



[pipeline parallelism]: #notes-pipeline-parallelism
# The CHERI capability model: Revisiting RISC in an age of risk {#papers-woodruff-isca-2014}


Jonathan Woodruff, Robert N. M. Watson, David Chisnall, Simon W. Moore, Jonathan Anderson, Brooks Davis, Ben Laurie, Peter G. Neumann, Robert M. Norton, Michael Roe
2014 ACM/IEEE 41st International Symposium on Computer Architecture (ISCA)
Pages 457-468
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=The%20CHERI%20capability%20model%3A%20Revisiting%20RISC%20in%20an%20age%20of%20risk)
[[DBLP]](https://dblp.org/search?q=The%20CHERI%20capability%20model%3A%20Revisiting%20RISC%20in%20an%20age%20of%20risk)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=The%20CHERI%20capability%20model%3A%20Revisiting%20RISC%20in%20an%20age%20of%20risk)
[[doi]](https://doi.org/10.1109/ISCA.2014.6853201)

Notes: 
[CHERI architecture](#CHERI architecture),
[capabilities](#capabilities)\
Papers: 
[nienhuis:secpriv:2020](#nienhuis-secpriv-2020),
[skorstengaard:popl:2019](#skorstengaard-popl-2019),
[skorstengaard:esop:2018](#skorstengaard-esop-2018)\
Referenced by: 
[papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020),
[notes/capabilities](#notes-capabilities),
[notes/cheri-architecture](#notes-cheri-architecture)\



[CHERI architecture]: #notes-cheri-architecture
[capabilities]: #notes-capabilities
[nienhuis:secpriv:2020]: #papers-nienhuis-secpriv-2020
[skorstengaard:popl:2019]: #papers-skorstengaard-popl-2019
[skorstengaard:esop:2018]: #papers-skorstengaard-esop-2018
# Large-scale automated refactoring using ClangMR {#papers-wright-icsm-2013}


Hyrum K. Wright, Daniel Jasper, Manuel Klimek, Chandler Carruth, Zhanyong Wan
2013 IEEE International Conference on Software Maintenance
Pages 548-551
Sep.
2013
[[Google Scholar]](https://scholar.google.com/scholar?q=Large-scale%20automated%20refactoring%20using%20ClangMR)
[[DBLP]](https://dblp.org/search?q=Large-scale%20automated%20refactoring%20using%20ClangMR)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Large-scale%20automated%20refactoring%20using%20ClangMR)
[[doi]](https://doi.org/10.1109/ICSM.2013.93)

Notes: 
[google papers](#google papers),
[google infrastructure](#google infrastructure)\



[google papers]: #notes-google-papers
[google infrastructure]: #notes-google-infrastructure
# A dependently typed assembly language {#papers-xi-icfp-2001}


Hongwei Xi, Robert Harper
Proceedings of the Sixth ACM SIGPLAN International Conference on Functional Programming
ICFP'01
Florence, Italy
Association for Computing Machinery
New York, NY, USA
Pages 169–180
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20dependently%20typed%20assembly%20language)
[[DBLP]](https://dblp.org/search?q=A%20dependently%20typed%20assembly%20language)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20dependently%20typed%20assembly%20language)
[[doi]](https://doi.org/10.1145/507635.507657)
[[ISBN]](http://books.google.com/books?vid=ISBN1581134150)
[[url]](https://doi.org/10.1145/507635.507657)

Notes: 
[dependent type](#dependent type),
[typed assembly language](#typed assembly language)\



[dependent type]: #notes-dependent-type
[typed assembly language]: #notes-typed-assembly-language
# Soundness and its role in bug detection systems {#papers-xie-bugs-2005}


Yichen Xie, Mayur Naik, Brian Hackett, Alex Aiken
Proceedings of BUGS 2005 (PLDI 2005 Workshop on the Evaluation of Software Defect Detection Tools)
Chicago, IL, USA
June
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=Soundness%20and%20its%20role%20in%20bug%20detection%20systems)
[[DBLP]](https://dblp.org/search?q=Soundness%20and%20its%20role%20in%20bug%20detection%20systems)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Soundness%20and%20its%20role%20in%20bug%20detection%20systems)
[[url]](http://www.cs.umd.edu/~pugh/SoftwareDefectWorkshop05/BugWorkshop05.pdf)

Notes: 
[under-approximation](#under-approximation)\
Papers: 
[godefroid:bugs:2005](#godefroid-bugs-2005)\
Referenced by: 
[papers/godefroid:bugs:2005](#papers-godefroid-bugs-2005)\


This one-page, position paper talks about three different, competing costs in
a tool: soundness (no false negatives); cost; and usability (which relates to
false positives).  They argue:

1. that unsound tools will usually appear before sound tools;
2. that sound tools will eventually appear;
3. that user-annotations will be used.

This paper is worth reading alongside [godefroid:bugs:2005] (from the same
workshop) that also discusses soundness but with a completely different
interpretation.



[under-approximation]: #notes-under-approximation
[godefroid:bugs:2005]: #papers-godefroid-bugs-2005
# Safe to the last instruction: automated verification of a type-safe operating system {#papers-yang-pldi-2010}


Jean Yang, Chris Hawblitzel
PLDI
ACM
Pages 99-110
2010
[[Google Scholar]](https://scholar.google.com/scholar?q=Safe%20to%20the%20last%20instruction%3A%20automated%20verification%20of%20a%20type-safe%20operating%20system)
[[DBLP]](https://dblp.org/search?q=Safe%20to%20the%20last%20instruction%3A%20automated%20verification%20of%20a%20type-safe%20operating%20system)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Safe%20to%20the%20last%20instruction%3A%20automated%20verification%20of%20a%20type-safe%20operating%20system)
[[doi]](https://doi.org/10.1145/1809028.1806610)

Notes: 
[typed assembly language](#typed assembly language)\




[typed assembly language]: #notes-typed-assembly-language
# Robust declassification {#papers-zdancewic-csfw-2001}


Steve Zdancewic, Andrew C. Myers
Proceedings 14th IEEE Computer Security Foundations Workshop
Pages 15-23
June
2001
[[Google Scholar]](https://scholar.google.com/scholar?q=Robust%20declassification)
[[DBLP]](https://dblp.org/search?q=Robust%20declassification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Robust%20declassification)
[[doi]](https://doi.org/10.1109/CSFW.2001.930133)

Notes: 
[information flow](#information flow)\



[information flow]: #notes-information-flow
# Observational determinism for concurrent program security {#papers-zdancewic-csfw-2003}


Steve Zdancewic, Andrew C. Myers
16th IEEE Computer Security Foundations Workshop, 2003. Proceedings.
IEEE
Pages 29-43
2003
[[Google Scholar]](https://scholar.google.com/scholar?q=Observational%20determinism%20for%20concurrent%20program%20security)
[[DBLP]](https://dblp.org/search?q=Observational%20determinism%20for%20concurrent%20program%20security)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Observational%20determinism%20for%20concurrent%20program%20security)
[[doi]](https://doi.org/10.1109/CSFW.2003.1212703)

Notes: 
[information flow](#information flow)\



[information flow]: #notes-information-flow
# Making information flow explicit in HiStar {#papers-zeldovich-osdi-2006}


Nickolai Zeldovich, Silas Boyd-Wickizer, Eddie Kohler, David Mazières
Proceedings of the 7th Symposium on Operating Systems Design and Implementation
OSDI'06
Seattle, Washington
USENIX Association
Berkeley, CA, USA
Pages 263-278
2006
[[Google Scholar]](https://scholar.google.com/scholar?q=Making%20information%20flow%20explicit%20in%20HiStar)
[[DBLP]](https://dblp.org/search?q=Making%20information%20flow%20explicit%20in%20HiStar)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Making%20information%20flow%20explicit%20in%20HiStar)
[[ISBN]](http://books.google.com/books?vid=ISBN1-931971-47-1)

Notes: 
[information flow](#information flow)\
Referenced by: 
[papers/spencer:security:1999](#papers-spencer-security-1999)\



[information flow]: #notes-information-flow
# Locating defects is uncertain {#papers-zeller-bugs-2005}


Andreas Zeller
Proceedings of BUGS 2005 (PLDI 2005 Workshop on the Evaluation of Software Defect Detection Tools)
Chicago, IL, USA
June
2005
[[Google Scholar]](https://scholar.google.com/scholar?q=Locating%20defects%20is%20uncertain)
[[DBLP]](https://dblp.org/search?q=Locating%20defects%20is%20uncertain)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Locating%20defects%20is%20uncertain)
[[url]](http://www.cs.umd.edu/~pugh/SoftwareDefectWorkshop05/BugWorkshop05.pdf)

Notes: 
[bug localization](#bug localization)\


This one-page, position paper talks about bug localization.
Failures are seen as the symptom of a chain of infection that
starts with some initial cause/infection.

The problem of localization consists of splitting the code into
parts that are responsible for the bug and parts that are not.
The interesting observation is that

> to precisely locate the defect, we need a specification [of each part that is
> considered] that is precise enough to tell us where to correct it.

and this leads to the conclusion that

> programmers do not "locate" defects; they design fixes along with the
> implicit specification of what should be going on at this location—and the
> location that is changed is defined as the defect in hindsight.

Tools that try to locate bugs will be imprecise for several reasons so they
should estimate the probablity of each location they suggest and list locations
in order of decreasing probability.



[bug localization]: #notes-bug-localization
# A hardware design language for timing-sensitive information flow security {#papers-zhang-asplos-2015}


Danfeng Zhang, Yao Wang, G. Edward Suh, Andrew C. Myers
ACM
Pages 503-516
2015
[[Google Scholar]](https://scholar.google.com/scholar?q=A%20hardware%20design%20language%20for%20timing-sensitive%20information%20flow%20security)
[[DBLP]](https://dblp.org/search?q=A%20hardware%20design%20language%20for%20timing-sensitive%20information%20flow%20security)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=A%20hardware%20design%20language%20for%20timing-sensitive%20information%20flow%20security)
[[doi]](https://doi.org/10.1145/2694344.2694372)

Notes: 
[information flow](#information flow)\
Papers: 
[demoura:tacas:2008](#demoura-tacas-2008)\


Extends Verilog with security labels and declassification. Labels can be static or dynamic and are tracked using a modified type system with some tricks to improve precision (related to implicit flows).  Analysis is (of course) timing sensitive so timing channels are automatically handled.
Constraints generated by type system are solved using
[the Z3 SMT solver][demoura:tacas:2008].
Evaluated on a MIPS CPU with two additional instructions to set timing labels and PPA evaluated (little impact).  Benchmarks include MiBench and OpenSSL.
Not clear if any form of label polymorphism is supported.



[information flow]: #notes-information-flow
[demoura:tacas:2008]: #papers-demoura-tacas-2008
# Integrating memory consistency models with instruction-level abstraction for heterogeneous system-on-chip verification {#papers-zhang-fmcad-2018}


Hongce Zhang, Caroline Trippel, Yatin Manerkar, Aarti Gupta, Margaret Martonosi, Sharad Malik
Formal Methods in Computer-Aided Design, FMCAD
2018
[[Google Scholar]](https://scholar.google.com/scholar?q=Integrating%20memory%20consistency%20models%20with%20instruction-level%20abstraction%20for%20heterogeneous%20system-on-chip%20verification)
[[DBLP]](https://dblp.org/search?q=Integrating%20memory%20consistency%20models%20with%20instruction-level%20abstraction%20for%20heterogeneous%20system-on-chip%20verification)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Integrating%20memory%20consistency%20models%20with%20instruction-level%20abstraction%20for%20heterogeneous%20system-on-chip%20verification)
[[doi]](https://doi.org/10.23919/FMCAD.2018.8603015)

Notes: 
[weak memory](#weak memory),
[CPU verification](#CPU verification),
[ISA specification](#ISA specification)\



[weak memory]: #notes-weak-memory
[CPU verification]: #notes-cpu-verification
[ISA specification]: #notes-isa-specification
# Using test case reduction and prioritization to improve symbolic execution {#papers-zhang-issta-2014}


Chaoqiang Zhang, Alex Groce, Mohammad Amin Alipour
Proceedings of the 2014 International Symposium on Software Testing and Analysis
ISSTA 2014
San Jose, CA, USA
Association for Computing Machinery
New York, NY, USA
Pages 160-170
2014
[[Google Scholar]](https://scholar.google.com/scholar?q=Using%20test%20case%20reduction%20and%20prioritization%20to%20improve%20symbolic%20execution)
[[DBLP]](https://dblp.org/search?q=Using%20test%20case%20reduction%20and%20prioritization%20to%20improve%20symbolic%20execution)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Using%20test%20case%20reduction%20and%20prioritization%20to%20improve%20symbolic%20execution)
[[doi]](https://doi.org/10.1145/2610384.2610392)
[[ISBN]](http://books.google.com/books?vid=ISBN9781450326452)
[[url]](https://doi.org/10.1145/2610384.2610392)




# LISA – machine description language and generic machine model for HW/SW co-design {#papers-zivojnovic-vlsi-1996}


Vojin Zivojnovic, Stefan Pees, Heinrich Meyr
VLSI Signal Processing, IX
Pages 127-136
October
1996
[[Google Scholar]](https://scholar.google.com/scholar?q=LISA%20%E2%80%93%20machine%20description%20language%20and%20generic%20machine%20model%20for%20HW/SW%20co-design)
[[DBLP]](https://dblp.org/search?q=LISA%20%E2%80%93%20machine%20description%20language%20and%20generic%20machine%20model%20for%20HW/SW%20co-design)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=LISA%20%E2%80%93%20machine%20description%20language%20and%20generic%20machine%20model%20for%20HW/SW%20co-design)
[[doi]](https://doi.org/10.1109/VLSISP.1996.558311)

Notes: 
[ISA specification](#ISA specification),
[LISA](#LISA)\
Referenced by: 
[notes/lisa](#notes-lisa)\



[ISA specification]: #notes-isa-specification
[LISA]: #notes-lisa
# Solver aided reverse engineering of architectural features {#papers-zorn-iscawddd-2017}


Bill Zorn, Dan Grossman, Luis Ceze
Proceedings of 14th Annual Workshop on Duplicating, Deconstructing and Debunking (ISCAWDDD)
Toronto, Canada
June
2017
[[Google Scholar]](https://scholar.google.com/scholar?q=Solver%20aided%20reverse%20engineering%20of%20architectural%20features)
[[DBLP]](https://dblp.org/search?q=Solver%20aided%20reverse%20engineering%20of%20architectural%20features)
[[Citeseer]](https://citeseer.ist.psu.edu/search?q=Solver%20aided%20reverse%20engineering%20of%20architectural%20features)

Notes: 
[Rosette solver](#Rosette solver),
[ISA specification](#ISA specification)\



[Rosette solver]: #notes-rosette-solver
[ISA specification]: #notes-isa-specification
# Abstract interpretation {#notes-abstract-interpretation}


[[Google Scholar]](https://scholar.google.com/scholar?q=Abstract%20interpretation)
[[Wikipedia]](https://en.wikipedia.org/wiki/Abstract_interpretation)

Referenced by: 
[papers/barnett:fmco:2005](#papers-barnett-fmco-2005),
[papers/clarke:cacm:2009](#papers-clarke-cacm-2009),
[papers/cousot:oopsla:2012](#papers-cousot-oopsla-2012),
[papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012),
[papers/fahndrich:foveoos:2010](#papers-fahndrich-foveoos-2010),
[papers/gurfinkel:cav:2015](#papers-gurfinkel-cav-2015),
[papers/mai:asplos:2013](#papers-mai-asplos-2013),
[papers/regehr:asplos:2004](#papers-regehr-asplos-2004),
[papers/regehr:emsoft:2003](#papers-regehr-emsoft-2003),
[papers/regehr:lctes:2006](#papers-regehr-lctes-2006),
[papers/regehr:tecs:2005](#papers-regehr-tecs-2005),
[notes/seahorn-verifier](#notes-seahorn-verifier)\


todo:

- <https://en.wikipedia.org/wiki/Galois_connection>
- <https://en.wikipedia.org/wiki/Widening_(computer_science)>




# ACL2 theorem prover {#notes-acl2-theorem-prover}

![ACL2 theorem prover](http://www.cs.utexas.edu/users/moore/acl2/v8-3/HTML/acl2-logo-200-134.gif){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=ACL2%20theorem%20prover)
[[Website]](http://www.cs.utexas.edu/users/moore/acl2/)
[[Wikipedia]](https://en.wikipedia.org/wiki/ACL2)

Referenced by: 
[papers/goel:acl2:2013](#papers-goel-acl2-2013),
[papers/goel:fmcad:2014](#papers-goel-fmcad-2014),
[papers/goel:pcs:2017](#papers-goel-pcs-2017),
[papers/goel:phd:2016](#papers-goel-phd-2016),
[papers/hardin:acl2:2006](#papers-hardin-acl2-2006),
[papers/kaufmann:ieeetse:1997](#papers-kaufmann-ieeetse-1997)\


ACL2 ("A Computational Logic for Applicative Common Lisp") is an interactive
theorem prover based on first order logic.



# Alias analysis {#notes-alias-analysis}


[[Google Scholar]](https://scholar.google.com/scholar?q=Alias%20analysis)
[[Wikipedia]](https://en.wikipedia.org/wiki/Alias_analysis)

Referenced by: 
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[notes/separation-logic](#notes-separation-logic)\



# Alloy verifier {#notes-alloy-verifier}


[[Google Scholar]](https://scholar.google.com/scholar?q=Alloy%20verifier)
[[Wikipedia]](https://en.wikipedia.org/wiki/Alloy_(specification_language))

Notes: 
[requirements specification](#requirements specification)\
Referenced by: 
[papers/frias:icse:2005](#papers-frias-icse-2005),
[papers/jackson:tosem:2002](#papers-jackson-tosem-2002),
[papers/krishnamurthi:fm:2019](#papers-krishnamurthi-fm-2019)\



[requirements specification]: #notes-requirements-specification
# Annotation burden {#notes-annotation-burden}


[[Google Scholar]](https://scholar.google.com/scholar?q=Annotation%20burden)

Notes: 
[ghost code](#ghost code),
[VeriFast verifier](#VeriFast verifier),
[interactive theorem prover](#interactive theorem prover),
[auto-active verification](#auto-active verification)\
Papers: 
[calcagno:popl:2009](#calcagno-popl-2009),
[cohen:cav:2010](#cohen-cav-2010),
[gu:osdi:2016](#gu-osdi-2016),
[mangano:crisis:2016](#mangano-crisis-2016),
[morrisett:wcsss:1999](#morrisett-wcsss-1999),
[vasudevan:usenix:2016](#vasudevan-usenix-2016),
[vogels:fmoods:2011](#vogels-fmoods-2011),
[costanzo:pldi:2016](#costanzo-pldi-2016),
[klein:sosp:2009](#klein-sosp-2009),
[leroy:cacm:2009](#leroy-cacm-2009)\
Referenced by: 
[papers/leino:informatics:2001](#papers-leino-informatics-2001),
[notes/ghost-code](#notes-ghost-code)\


Program verification using
[auto-active verifiers][auto-active verification] and
[interactive theorem prover]s requires writing annotations,
proof scripts or [ghost code] to assist the verification.

Some reported numbers are

| Prover         | System            | Paper                   | Burden |
| -------------- | ----------------- | ----------------------- | -----: |
| VCC            | Hyper-V           | [cohen:cav:2010]        | 100%   |
| Frama-C        | Contiki           | [mangano:crisis:2016]   | 110%   |
| Frama-C        | überSpark         | [vasudevan:usenix:2016] | 110%   |
| Coq            | CertiKOS          | [gu:osdi:2016]          | 1500%  |
| -------------- | ----------------- | ----------------------- | ------ |

todo: collect more data

[vogels:fmoods:2011] describes some techniques to infer annotations in
the [VeriFast verifier].
[calcagno:popl:2009] describes the Infer system used to infer function
contracts for various systems including parts of the Linux kernel.



[ghost code]: #notes-ghost-code
[VeriFast verifier]: #notes-verifast-verifier
[interactive theorem prover]: #notes-interactive-theorem-prover
[auto-active verification]: #notes-auto-active-verification
[calcagno:popl:2009]: #papers-calcagno-popl-2009
[cohen:cav:2010]: #papers-cohen-cav-2010
[gu:osdi:2016]: #papers-gu-osdi-2016
[mangano:crisis:2016]: #papers-mangano-crisis-2016
[morrisett:wcsss:1999]: #papers-morrisett-wcsss-1999
[vasudevan:usenix:2016]: #papers-vasudevan-usenix-2016
[vogels:fmoods:2011]: #papers-vogels-fmoods-2011
[costanzo:pldi:2016]: #papers-costanzo-pldi-2016
[klein:sosp:2009]: #papers-klein-sosp-2009
[leroy:cacm:2009]: #papers-leroy-cacm-2009
# Absence of RunTime Errors (AoRTE) {#notes-aorte}


[[Google Scholar]](https://scholar.google.com/scholar?q=Absence%20of%20RunTime%20Errors%20%28AoRTE%29)

Notes: 
[extended static checking](#extended static checking),
[SV competition](#SV competition)\
Referenced by: 
[notes/blast-verifier](#notes-blast-verifier),
[notes/extended-static-checking](#notes-extended-static-checking),
[notes/sv-competition](#notes-sv-competition)\


todo:



[extended static checking]: #notes-extended-static-checking
[SV competition]: #notes-sv-competition
# Arm architecture {#notes-arm-architecture}

![Arm architecture](https://www.arm.com/-/media/global/logos/Arm-logo-blue-pms313.svg){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=Arm%20architecture)
[[Website]](https://www.arm.com)
[[Wikipedia]](https://en.wikipedia.org/wiki/ARM_architecture)

Notes: 
[instruction set architecture](#instruction set architecture),
[ISA specification](#ISA specification),
[ASL](#ASL),
[Sail language](#Sail language)\
Referenced by: 
[papers/armstrong:arw:2018](#papers-armstrong-arw-2018),
[papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019),
[papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019),
[papers/boettcher:date:2014](#papers-boettcher-date-2014),
[papers/dam:ted:2013](#papers-dam-ted-2013),
[papers/dam:trusted:2013](#papers-dam-trusted-2013),
[papers/flur:popl:2016](#papers-flur-popl-2016),
[papers/fox:cambridge:2001](#papers-fox-cambridge-2001),
[papers/fox:itp:2010](#papers-fox-itp-2010),
[papers/fox:itp:2012](#papers-fox-itp-2012),
[papers/fox:itps:2015](#papers-fox-itps-2015),
[papers/fox:tphols:2003](#papers-fox-tphols-2003),
[papers/fox:ucam:2002](#papers-fox-ucam-2002),
[papers/khakpour:cpp:2013](#papers-khakpour-cpp-2013),
[papers/lockhart:ispass:2015](#papers-lockhart-ispass-2015),
[papers/myreen:tphols:2009](#papers-myreen-tphols-2009),
[papers/reid:cav:2016](#papers-reid-cav-2016),
[papers/reid:fmcad:2016](#papers-reid-fmcad-2016),
[papers/reid:oopsla:2017](#papers-reid-oopsla-2017),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[papers/schwarz:sefm:2016](#papers-schwarz-sefm-2016),
[papers/seal:book:2000](#papers-seal-book-2000),
[papers/sewell:pldi:2013](#papers-sewell-pldi-2013),
[papers/shi:phd:2013](#papers-shi-phd-2013),
[papers/stephens:micro:2017](#papers-stephens-micro-2017),
[papers/tahat:fmcad:2019](#papers-tahat-fmcad-2019),
[notes/asl](#notes-asl),
[notes/instruction-set-architecture](#notes-instruction-set-architecture),
[notes/l3](#notes-l3),
[notes/sail-language](#notes-sail-language)\


Arm is an [instruction set architecture].

Formal [ISA specification]s for Arm include

- [Specification from Arm](https://developer.arm.com/architectures/cpu-architecture/a-profile/exploration-tools)
  written in [ASL].

- [Specification from Cambridge University](https://github.com/rems-project/sail-arm)
  mechanically translated to [Sail][Sail language]
  from the [ASL] specification.

- [L3 specification from Cambridge University](https://acjf3.github.io/l3/index.html).



[instruction set architecture]: #notes-instruction-set-architecture
[ISA specification]: #notes-isa-specification
[ASL]: #notes-asl
[Sail language]: #notes-sail-language
# Arm Architecture Specification Language (ASL) {#notes-asl}


[[Google Scholar]](https://scholar.google.com/scholar?q=Arm%20Architecture%20Specification%20Language%20%28ASL%29)

Notes: 
[Arm architecture](#Arm architecture),
[ISA specification](#ISA specification)\
Papers: 
[reid:cav:2016](#reid-cav-2016),
[reid:fmcad:2016](#reid-fmcad-2016),
[reid:oopsla:2017](#reid-oopsla-2017),
[reid:phd:2019](#reid-phd-2019)\
Referenced by: 
[papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019),
[papers/reid:cav:2016](#papers-reid-cav-2016),
[papers/reid:fmcad:2016](#papers-reid-fmcad-2016),
[papers/reid:oopsla:2017](#papers-reid-oopsla-2017),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[papers/tahat:fmcad:2019](#papers-tahat-fmcad-2019),
[notes/arm-architecture](#notes-arm-architecture),
[notes/dependent-type](#notes-dependent-type),
[notes/isa-specification](#notes-isa-specification),
[notes/sail-language](#notes-sail-language)\


ASL is the [ISA specification] language used by Arm to
specify their A-, R- and M-profile processor architectures ([reid:fmcad:2016]).
Those specifications have been extensively tested,
formally validated ([reid:oopsla:2017])
and have been used to formally validate Arm's
processor implementations ([reid:cav:2016]).

> ASL is an executable, strongly-typed, imperative language with support for
> [dependent type]s and for throwing and catching exceptions.  For the first
> 20–25 years of Arm’s history, specifications were created after the
> corresponding implementation as documentation of what had been built.  [...]
> specifications are now written and tested before implementation starts.
>
> The ASL language was created by reverse engineering a specification language
> from the pseudocode notation used in Arm’s existing documentation, fixing the
> pseudocode in the documentation and evolving that pseudocode into a formal
> specification.
> <br>--- Alastair Reid ([reid:phd:2019])



[Arm architecture]: #notes-arm-architecture
[ISA specification]: #notes-isa-specification
[reid:cav:2016]: #papers-reid-cav-2016
[reid:fmcad:2016]: #papers-reid-fmcad-2016
[reid:oopsla:2017]: #papers-reid-oopsla-2017
[reid:phd:2019]: #papers-reid-phd-2019
# Aspect oriented programming {#notes-aspect-oriented-programming}


[[Google Scholar]](https://scholar.google.com/scholar?q=Aspect%20oriented%20programming)
[[Wikipedia]](https://en.wikipedia.org/wiki/Aspect-oriented_programming)

Referenced by: 
[papers/kiczales:iwoos:1991](#papers-kiczales-iwoos-1991)\



# Auto active verification {#notes-auto-active-verification}


[[Google Scholar]](https://scholar.google.com/scholar?q=Auto%20active%20verification)

Notes: 
[Boogie verifier](#Boogie verifier),
[Dafny verifier](#Dafny verifier),
[VeriFast verifier](#VeriFast verifier)\
Papers: 
[nelson:sosp:2019](#nelson-sosp-2019)\
Referenced by: 
[papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011),
[papers/jacobs:vstte:2010](#papers-jacobs-vstte-2010),
[papers/leino:icse:2013](#papers-leino-icse-2013),
[papers/leino:informatics:2001](#papers-leino-informatics-2001),
[papers/leino:lpair:2010](#papers-leino-lpair-2010),
[papers/vogels:fmoods:2011](#papers-vogels-fmoods-2011),
[notes/annotation-burden](#notes-annotation-burden),
[notes/dafny-verifier](#notes-dafny-verifier),
[notes/vcc-verifier](#notes-vcc-verifier)\


A term coined by Leino and Moskal

> [...] all interaction with the program verifier [is] done with annotations
> supplied in the program text [...]. This was made possible by powerful automatic
> satisfiability-modulo-theories (SMT) solvers.
> <br>--- [Usable auto-active verification], [Usable Verification Workshop 2010].

though I think they are retroactively naming what the [ESC report] did.

A more recent description

> In contrast to interactive theorem provers, auto-active theorem provers ask
> developers to write proof annotations on implementation code, such as
> preconditions, postconditions, and loop invariants. The prover translates
> the annotated code into a verificationcondition and invokes a constraint
> solver to check its validity.
> <br>--- [nelson:sosp:2019]

Some examples are the [Dafny verifier], the [Boogie verifier] and the [VeriFast verifier].

[ESC report]: https://scholar.google.co.uk/scholar?q=extended+static+checking
[Usable Verification Workshop 2010]: http://fm.csl.sri.com/UV10/
[Usable auto-active verification]: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.295.2080&rep=rep1&type=pdf



[Boogie verifier]: #notes-boogie-verifier
[Dafny verifier]: #notes-dafny-verifier
[VeriFast verifier]: #notes-verifast-verifier
[nelson:sosp:2019]: #papers-nelson-sosp-2019
# Binary Analysis Platform (BAP) {#notes-bap-tool}


[[Google Scholar]](https://scholar.google.com/scholar?q=Binary%20Analysis%20Platform%20%28BAP%29)
[[Website]](https://github.com/BinaryAnalysisPlatform/bap)

Notes: 
[binary analysis](#binary analysis)\
Papers: 
[avgerinos:icse:2014](#avgerinos-icse-2014)\
Referenced by: 
[papers/avgerinos:icse:2014](#papers-avgerinos-icse-2014)\


A binary analysis tool developed at CMU in early 2010's
and used as the basis of many binary analysis tools.
Version 2.0 released in 2019.



[binary analysis]: #notes-binary-analysis
[avgerinos:icse:2014]: #papers-avgerinos-icse-2014
# Binary Decision Diagrams (BDD) {#notes-bdd}


[[Google Scholar]](https://scholar.google.com/scholar?q=Binary%20Decision%20Diagrams%20%28BDD%29)
[[Wikipedia]](https://en.wikipedia.org/wiki/Binary_decision_diagram)

Referenced by: 
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[papers/regehr:asplos:2004](#papers-regehr-asplos-2004),
[papers/regehr:lctes:2006](#papers-regehr-lctes-2006),
[notes/symbolic-model-checking](#notes-symbolic-model-checking)\


A number of other compact canonical representations exist – see the
[Wikipedia page](https://en.wikipedia.org/wiki/Binary_decision_diagram).



# Bi-abduction {#notes-biabduction}


[[Google Scholar]](https://scholar.google.com/scholar?q=Bi-abduction)

Notes: 
[separation logic](#separation logic)\
Referenced by: 
[papers/calcagno:popl:2009](#papers-calcagno-popl-2009)\


todo



[separation logic]: #notes-separation-logic
# Binary analysis {#notes-binary-analysis}


[[Google Scholar]](https://scholar.google.com/scholar?q=Binary%20analysis)

Notes: 
[ISA specification](#ISA specification)\
Referenced by: 
[papers/goodman:ndss:2018](#papers-goodman-ndss-2018),
[papers/maus:amast:2008](#papers-maus-amast-2008),
[papers/noonan:pldi:2016](#papers-noonan-pldi-2016),
[papers/shoshitaishvili:sp:2016](#papers-shoshitaishvili-sp-2016),
[notes/bap-tool](#notes-bap-tool)\



[ISA specification]: #notes-isa-specification
# BLAST verifier {#notes-blast-verifier}


[[Google Scholar]](https://scholar.google.com/scholar?q=BLAST%20verifier)
[[Wikipedia]](https://en.wikipedia.org/wiki/BLAST_model_checker)

Notes: 
[model checking](#model checking),
[CPAchecker verifier](#CPAchecker verifier),
[extended static checking](#extended static checking),
[AoRTE](#AoRTE),
[SV competition](#SV competition),
[CEGAR](#CEGAR)\
Papers: 
[beyer:sas:2004](#beyer-sas-2004),
[beyer:ijsttt:2007](#beyer-ijsttt-2007),
[necula:cc:2002](#necula-cc-2002)\
Referenced by: 
[papers/beyer:ijsttt:2007](#papers-beyer-ijsttt-2007),
[papers/beyer:sas:2004](#papers-beyer-sas-2004),
[papers/holzer:cav:2008](#papers-holzer-cav-2008),
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[notes/cpachecker-verifier](#notes-cpachecker-verifier),
[notes/sv-competition](#notes-sv-competition)\


BLAST (Berkeley Lazy Abstraction Software verification Tool)
was an early C program verification tool.

> The task addressed by BLAST is the need to check whether software satisfies the
> behavioral requirements of its associated interfaces. BLAST employs
> counterexample-driven automatic abstraction refinement to construct an abstract
> model that is then model-checked for safety properties. The abstraction is
> constructed on the fly, and only to the requested precision.
> <br>--- [Wikipedia](https://en.wikipedia.org/wiki/BLAST_model_checker)



[model checking]: #notes-model-checking
[CPAchecker verifier]: #notes-cpachecker-verifier
[extended static checking]: #notes-extended-static-checking
[AoRTE]: #notes-aorte
[SV competition]: #notes-sv-competition
[CEGAR]: #notes-cegar
[beyer:sas:2004]: #papers-beyer-sas-2004
[beyer:ijsttt:2007]: #papers-beyer-ijsttt-2007
[necula:cc:2002]: #papers-necula-cc-2002
# Boogie verifier {#notes-boogie-verifier}


[[Google Scholar]](https://scholar.google.com/scholar?q=Boogie%20verifier)
[[Website]](https://www.microsoft.com/en-us/research/project/boogie-an-intermediate-verification-language/)

Notes: 
[permission logic](#permission logic),
[Spec-sharp project](#Spec-sharp project),
[intermediate verification language](#intermediate verification language),
[verification condition generator](#verification condition generator)\
Referenced by: 
[papers/almeida:security:2016](#papers-almeida-security-2016),
[papers/baranowski:atva:2018](#papers-baranowski-atva-2018),
[papers/barnett:cacm:2011](#papers-barnett-cacm-2011),
[papers/barnett:fmco:2005](#papers-barnett-fmco-2005),
[papers/legoues:sefm:2011](#papers-legoues-sefm-2011),
[papers/leino:icse:2013](#papers-leino-icse-2013),
[papers/leino:lpair:2010](#papers-leino-lpair-2010),
[papers/leino:tacas:2010](#papers-leino-tacas-2010),
[papers/rakamaric:cav:2014](#papers-rakamaric-cav-2014),
[notes/auto-active-verification](#notes-auto-active-verification),
[notes/civl-verifier](#notes-civl-verifier),
[notes/corral-verifier](#notes-corral-verifier),
[notes/intermediate-verification-language](#notes-intermediate-verification-language),
[notes/smack-verifier](#notes-smack-verifier),
[notes/spec-sharp-project](#notes-spec-sharp-project),
[notes/vcc-verifier](#notes-vcc-verifier),
[notes/verification-condition-generator](#notes-verification-condition-generator)\


Boogie is an [intermediate verification language] and
[verification condition generator]
developed by Microsoft Research.
Originally, part of the [Spec# project][Spec-sharp project] though it has taken
on a life of its own.



[permission logic]: #notes-permission-logic
[Spec-sharp project]: #notes-spec-sharp-project
[intermediate verification language]: #notes-intermediate-verification-language
[verification condition generator]: #notes-verification-condition-generator
# Bounded model-checking {#notes-bounded-model-checking}


[[Google Scholar]](https://scholar.google.com/scholar?q=Bounded%20model-checking)

Notes: 
[bounded verification](#bounded verification),
[model checking](#model checking),
[symbolic execution](#symbolic execution),
[symbolic evaluation](#symbolic evaluation),
[reachability](#reachability)\
Papers: 
[nelson:sosp:2019](#nelson-sosp-2019),
[bornholt:oopsla:2018](#bornholt-oopsla-2018),
[jhala:compsurv:2009](#jhala-compsurv-2009)\
Referenced by: 
[papers/biere:tacas:1999](#papers-biere-tacas-1999),
[papers/bornholt:oopsla:2018](#papers-bornholt-oopsla-2018),
[papers/clarke:cacm:2009](#papers-clarke-cacm-2009),
[papers/clarke:tacas:2004](#papers-clarke-tacas-2004),
[papers/cook:cav:2018](#papers-cook-cav-2018),
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[papers/merz:vstte:2012](#papers-merz-vstte-2012),
[papers/reid:cav:2016](#papers-reid-cav-2016),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[papers/torlak:pldi:2014](#papers-torlak-pldi-2014),
[notes/bounded-verification](#notes-bounded-verification),
[notes/cbmc-verifier](#notes-cbmc-verifier),
[notes/symbolic-evaluation](#notes-symbolic-evaluation),
[notes/symbolic-execution](#notes-symbolic-execution)\


Bounded model checking is a variant of [model checking].

Following the terminology in section 3.1 of 
[bornholt:oopsla:2018], bounded model-checking is a form of
[symbolic evaluation] where all paths are followed at a time.

The benefit of following all paths at once is that it avoids the path explosion
problem seen in [symbolic execution].

The disadvantage of following all paths at once is that this
requires that states are merged at join points so many calculations
involve symbolic values requiring the use of a solver to resolve.



[bounded verification]: #notes-bounded-verification
[model checking]: #notes-model-checking
[symbolic execution]: #notes-symbolic-execution
[symbolic evaluation]: #notes-symbolic-evaluation
[reachability]: #notes-reachability
[nelson:sosp:2019]: #papers-nelson-sosp-2019
[bornholt:oopsla:2018]: #papers-bornholt-oopsla-2018
[jhala:compsurv:2009]: #papers-jhala-compsurv-2009
# Bounded verification {#notes-bounded-verification}


[[Google Scholar]](https://scholar.google.com/scholar?q=Bounded%20verification)

Notes: 
[bounded model checking](#bounded model checking)\
Referenced by: 
[papers/biere:tacas:1999](#papers-biere-tacas-1999),
[papers/cook:cav:2018](#papers-cook-cav-2018),
[papers/lal:cav:2012](#papers-lal-cav-2012),
[papers/toman:ase:2015](#papers-toman-ase-2015),
[notes/bounded-model-checking](#notes-bounded-model-checking)\


todo:



[bounded model checking]: #notes-bounded-model-checking
# Büchi automaton {#notes-buchi-automaton}


[[Google Scholar]](https://scholar.google.com/scholar?q=B%C3%BCchi%20automaton)
[[Wikipedia]](https://en.wikipedia.org/wiki/Büchi_automaton)

Notes: 
[model checking](#model checking),
[Kripke structure](#Kripke structure),
[temporal logic](#temporal logic)\
Referenced by: 
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[notes/model-checking](#notes-model-checking)\


A Büchi automaton is like a finite state machine (FSM) except that it
accepts infinite inputs.
An FSM accepts an input if it enters an accepting state _once_;
a Büchi automaton accepts an input if it passes through an accepting
state infinitely many times.

As with FSMs, there are deterministic and non-determistic variants of Büchi
automata but, unlike FSMs, not all non-deterministic automata can be converted
to deterministic Büchi automata.
(See [Wikipedia page] for details/alternatives.)

Büchi automata are used for [model checking] by converting linear [temporal
logic] formulae to automata.
They can accept any ω-regular language.



[model checking]: #notes-model-checking
[Kripke structure]: #notes-kripke-structure
[temporal logic]: #notes-temporal-logic
# Bug localization {#notes-bug-localization}


[[Google Scholar]](https://scholar.google.com/scholar?q=Bug%20localization)

Referenced by: 
[papers/zeller:bugs:2005](#papers-zeller-bugs-2005)\





# Cactus plot / Survival plot {#notes-cactus-plot}


[[Google Scholar]](https://scholar.google.com/scholar?q=Cactus%20plot%20/%20Survival%20plot)
[[Wikipedia]](https://en.wikipedia.org/wiki/Survival_function)

Notes: 
[SV competition](#SV competition)\
Referenced by: 
[papers/astrauskas:oopsla:2019](#papers-astrauskas-oopsla-2019)\


A cactus plot or "survival plot" is used to summarize the performance
of an automated verification tool
in verification tool competitions such as [SMT-COMP] and [SV-COMP][SV competition].
The graph plots how many problems can be solved in a given time.

(I think that a "cactus plot" is the transpose of a "survival plot".)

A [paper about the use of cactus plots in competitions](http://www.sc-square.org/CSA/workshop2-papers/RP3-FinalVersion.pdf).

Here is an example from [SV-COMP 2020].

![cactus plot for SV-COMP overflow verification results](https://sv-comp.sosy-lab.org/2020/results/results-verified/quantilePlot-NoOverflows.svg)


[SMT-COMP]: https://smt-comp.github.io/
[SV-COMP 2020]: https://sv-comp.sosy-lab.org/2020/


[SV competition]: #notes-sv-competition
# Capabilities {#notes-capabilities}


[[Google Scholar]](https://scholar.google.com/scholar?q=Capabilities)
[[Wikipedia]](https://en.wikipedia.org/wiki/Capability-based_security)

Notes: 
[CHERI architecture](#CHERI architecture)\
Papers: 
[nienhuis:secpriv:2020](#nienhuis-secpriv-2020),
[woodruff:isca:2014](#woodruff-isca-2014),
[skorstengaard:esop:2018](#skorstengaard-esop-2018),
[skorstengaard:popl:2019](#skorstengaard-popl-2019)\
Referenced by: 
[papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020),
[papers/skorstengaard:esop:2018](#papers-skorstengaard-esop-2018),
[papers/skorstengaard:popl:2019](#papers-skorstengaard-popl-2019),
[papers/woodruff:isca:2014](#papers-woodruff-isca-2014),
[notes/cheri-architecture](#notes-cheri-architecture)\


A capability is an unforgeable access token.

todo: noted feature is that it solves the "confused deputy" problem.



[CHERI architecture]: #notes-cheri-architecture
[nienhuis:secpriv:2020]: #papers-nienhuis-secpriv-2020
[woodruff:isca:2014]: #papers-woodruff-isca-2014
[skorstengaard:esop:2018]: #papers-skorstengaard-esop-2018
[skorstengaard:popl:2019]: #papers-skorstengaard-popl-2019
# CBMC verifier {#notes-cbmc-verifier}


[[Google Scholar]](https://scholar.google.com/scholar?q=CBMC%20verifier)
[[Website]](https://github.com/diffblue/cbmc)

Notes: 
[bounded model checking](#bounded model checking)\
Papers: 
[clarke:tacas:2004](#clarke-tacas-2004)\
Referenced by: 
[papers/beyer:hvc:2017](#papers-beyer-hvc-2017),
[papers/chong:icse:2020](#papers-chong-icse-2020),
[papers/clarke:tacas:2004](#papers-clarke-tacas-2004),
[papers/holzer:cav:2008](#papers-holzer-cav-2008),
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[papers/toman:ase:2015](#papers-toman-ase-2015)\


CBMC is a [bounded model-checker][bounded model checking] for C and C++ programs.




[bounded model checking]: #notes-bounded-model-checking
[clarke:tacas:2004]: #papers-clarke-tacas-2004
# CEGAR (Counter-Example Guided Abstraction Refinement) {#notes-cegar}


[[Google Scholar]](https://scholar.google.com/scholar?q=CEGAR%20%28Counter-Example%20Guided%20Abstraction%20Refinement%29)
[[Wikipedia]](https://en.wikipedia.org/wiki/Abstraction_model_checking)

Papers: 
[clarke:cav:2000](#clarke-cav-2000)\
Referenced by: 
[papers/ball:pldi:2001](#papers-ball-pldi-2001),
[papers/clarke:cacm:2009](#papers-clarke-cacm-2009),
[papers/clarke:cav:2000](#papers-clarke-cav-2000),
[papers/henzinger:spin:2003](#papers-henzinger-spin-2003),
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[notes/blast-verifier](#notes-blast-verifier)\


Counter-Example Guided Abstraction Refinement is a method of constructing
an abstraction of a system such as a program by constructing a series
of increasingly precise abstractions, attempting to verify the system
using those abstractions and, if an attempt fails, using a counter-example
from the failed attempt to construct a more precise abstraction.

I think the original paper was [clarke:cav:2000].



[clarke:cav:2000]: #papers-clarke-cav-2000
# Chalice verifier {#notes-chalice-verifier}

![Chalice verifier](https://www.microsoft.com/en-us/research/wp-content/uploads/2008/12/Chalice-logo.png){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=Chalice%20verifier)
[[Website]](https://www.microsoft.com/en-us/research/project/chalice/)

Notes: 
[Permission logic](#Permission logic)\
Papers: 
[heule:ftfjp:2011](#heule-ftfjp-2011)\
Referenced by: 
[papers/heule:ftfjp:2011](#papers-heule-ftfjp-2011),
[papers/leino:fosad:2007](#papers-leino-fosad-2007),
[notes/permission-logic](#notes-permission-logic)\


Chalice is a language and verifier for writing and verifying concurrent
programs developed by Microsoft Research based on [Permission logic].



[Permission logic]: #notes-permission-logic
[heule:ftfjp:2011]: #papers-heule-ftfjp-2011
# CHERI architecture {#notes-cheri-architecture}

![CHERI architecture](https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=CHERI%20architecture)

Notes: 
[capabilities](#capabilities),
[instruction set architecture](#instruction set architecture)\
Papers: 
[skorstengaard:esop:2018](#skorstengaard-esop-2018),
[skorstengaard:popl:2019](#skorstengaard-popl-2019),
[nienhuis:secpriv:2020](#nienhuis-secpriv-2020),
[woodruff:isca:2014](#woodruff-isca-2014)\
Referenced by: 
[papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019),
[papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019),
[papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020),
[papers/skorstengaard:esop:2018](#papers-skorstengaard-esop-2018),
[papers/skorstengaard:popl:2019](#papers-skorstengaard-popl-2019),
[papers/woodruff:isca:2014](#papers-woodruff-isca-2014),
[notes/capabilities](#notes-capabilities),
[notes/instruction-set-architecture](#notes-instruction-set-architecture),
[notes/sail-language](#notes-sail-language)\


CHERI is an [instruction set architecture] based on providing hardware
support for [capabilities].
In particular, CHERI separates protection checks from virtual memory.

The basic CHERI design in [woodruff:isca:2014] tackled spatial safety but left
a hole wrt temporal safety. That is, capabilities could be used to protect
a region of memory but there was no way to revoke a capability.
This was addressed in later papers.



[capabilities]: #notes-capabilities
[instruction set architecture]: #notes-instruction-set-architecture
[skorstengaard:esop:2018]: #papers-skorstengaard-esop-2018
[skorstengaard:popl:2019]: #papers-skorstengaard-popl-2019
[nienhuis:secpriv:2020]: #papers-nienhuis-secpriv-2020
[woodruff:isca:2014]: #papers-woodruff-isca-2014
# CIL tool {#notes-cil-tool}


[[Google Scholar]](https://scholar.google.com/scholar?q=CIL%20tool)
[[Wikipedia]](https://en.wikipedia.org/wiki/George_Necula#C_Intermediate_Language)

Papers: 
[necula:cc:2002](#necula-cc-2002)\
Referenced by: 
[papers/necula:cc:2002](#papers-necula-cc-2002)\



[necula:cc:2002]: #papers-necula-cc-2002
# CIVL verifier {#notes-civl-verifier}


[[Google Scholar]](https://scholar.google.com/scholar?q=CIVL%20verifier)
[[Website]](http://vsl.cis.udel.edu:8080/civl/)

Notes: 
[intermediate verification language](#intermediate verification language),
[symbolic execution](#symbolic execution),
[Boogie verifier](#Boogie verifier)\
Referenced by: 
[papers/siegel:sc:2015](#papers-siegel-sc-2015)\


CIVL is an extension of the [Boogie verifier] with some concurrency primitives,
a model checker based on [symbolic execution],
a concurrency [intermediate verification language].



[intermediate verification language]: #notes-intermediate-verification-language
[symbolic execution]: #notes-symbolic-execution
[Boogie verifier]: #notes-boogie-verifier
# CompCert compiler {#notes-compcert-compiler}


[[Google Scholar]](https://scholar.google.com/scholar?q=CompCert%20compiler)
[[Website]](http://compcert.inria.fr/)
[[Wikipedia]](https://en.wikipedia.org/wiki/CompCert)

Notes: 
[Coq theorem prover](#Coq theorem prover),
[translation validation](#translation validation)\
Papers: 
[leroy:cacm:2009](#leroy-cacm-2009)\
Referenced by: 
[papers/gu:osdi:2016](#papers-gu-osdi-2016),
[papers/leroy:cacm:2009](#papers-leroy-cacm-2009),
[papers/vasudevan:usenix:2016](#papers-vasudevan-usenix-2016),
[notes/translation-validation](#notes-translation-validation)\


CompCert is an optimizing compiler for a large subset of C that has been
formally verified using the [Coq theorem prover].
Passes in CompCert were either verified as correct for any
input or using [translation validation].



[Coq theorem prover]: #notes-coq-theorem-prover
[translation validation]: #notes-translation-validation
[leroy:cacm:2009]: #papers-leroy-cacm-2009
# Concurrent separation logic {#notes-concurrent-separation-logic}


[[Google Scholar]](https://scholar.google.com/scholar?q=Concurrent%20separation%20logic)

Notes: 
[separation logic](#separation logic),
[frame rule](#frame rule)\
Referenced by: 
[papers/brookes:tcs:2006](#papers-brookes-tcs-2006),
[papers/ohearn:cacm:2019](#papers-ohearn-cacm-2019),
[papers/ohearn:tcs:2007](#papers-ohearn-tcs-2007),
[papers/penninckx:nfm:2012](#papers-penninckx-nfm-2012)\


todo:

Concurrent separation logic is an extension of [separation logic] to handle concurrency.
Since the [frame rule] already takes care of most of the work, the
main extension is how to reason about locks, mutexes, and other synchronization
mechanisms.
Often the answer is that the synchronization mechanism logically owns the
resource when the lock (or whatever) is not held.



[separation logic]: #notes-separation-logic
[frame rule]: #notes-frame-rule
# Continuations {#notes-continuations}


[[Google Scholar]](https://scholar.google.com/scholar?q=Continuations)
[[Wikipedia]](https://en.wikipedia.org/wiki/Continuation)

Notes: 
[threads](#threads)\
Papers: 
[lauer:osr:1979](#lauer-osr-1979),
[draves:sosp:1991](#draves-sosp-1991)\
Referenced by: 
[papers/draves:sosp:1991](#papers-draves-sosp-1991),
[papers/lauer:osr:1979](#papers-lauer-osr-1979),
[papers/reid:cases:2008](#papers-reid-cases-2008),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[papers/wand:lfp:1980](#papers-wand-lfp-1980),
[notes/events](#notes-events),
[notes/threads](#notes-threads)\



[threads]: #notes-threads
[lauer:osr:1979]: #papers-lauer-osr-1979
[draves:sosp:1991]: #papers-draves-sosp-1991
# Contract driven development {#notes-contract-driven-development}


[[Google Scholar]](https://scholar.google.com/scholar?q=Contract%20driven%20development)
[[Wikipedia]](https://en.wikipedia.org/wiki/Design_by_contract)

Notes: 
[test driven development](#test driven development),
[modular verification](#modular verification)\
Papers: 
[logozzo:vmcai:2011](#logozzo-vmcai-2011),
[fahndrich:foveoos:2010](#fahndrich-foveoos-2010)\
Referenced by: 
[papers/barnett:cacm:2011](#papers-barnett-cacm-2011),
[papers/barnett:fmco:2005](#papers-barnett-fmco-2005),
[papers/deline:pldi:2001](#papers-deline-pldi-2001),
[papers/fahndrich:foveoos:2010](#papers-fahndrich-foveoos-2010),
[papers/hatcliff:compsurv:2012](#papers-hatcliff-compsurv-2012),
[papers/leino:fosad:2007](#papers-leino-fosad-2007),
[papers/lindner:indin:2018](#papers-lindner-indin-2018),
[papers/logozzo:vmcai:2011](#papers-logozzo-vmcai-2011),
[papers/mai:asplos:2013](#papers-mai-asplos-2013),
[notes/modular-verification](#notes-modular-verification),
[notes/spec-sharp-project](#notes-spec-sharp-project)\


Contract driven development is a development methodology where you write
a contract for a function/method/class before implementing it.

The name comes from Bertrand Meyer's paper [meyer:fase:2007].

In a formal verification context, this is often synonymous with [modular
verification].

The approach of defining the desired behaviour before implementing the
behaviour bears some resemblance to [test driven development].

Formal verification papers:
[logozzo:vmcai:2011],
[fahndrich:foveoos:2010]

[meyer:fase:2007]: https://doi.org/10.1007/978-3-540-71289-3_2


[test driven development]: #notes-test-driven-development
[modular verification]: #notes-modular-verification
[logozzo:vmcai:2011]: #papers-logozzo-vmcai-2011
[fahndrich:foveoos:2010]: #papers-fahndrich-foveoos-2010
# Coq theorem prover {#notes-coq-theorem-prover}

![Coq theorem prover](https://upload.wikimedia.org/wikipedia/commons/d/d8/Coq_logo.png){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=Coq%20theorem%20prover)
[[Website]](https://coq.inria.fr)
[[Wikipedia]](https://en.wikipedia.org/wiki/Coq)

Is a kind of: 
[interactive theorem prover](#interactive theorem prover)\
Notes: 
[dependent type](#dependent type)\
Referenced by: 
[papers/becker:fm:2016](#papers-becker-fm-2016),
[papers/coquand:eurocal:1985](#papers-coquand-eurocal-1985),
[papers/gu:osdi:2016](#papers-gu-osdi-2016),
[papers/jung:popl:2017](#papers-jung-popl-2017),
[papers/jung:popl:2020](#papers-jung-popl-2020),
[papers/leroy:cacm:2009](#papers-leroy-cacm-2009),
[papers/pierce:book:2016](#papers-pierce-book-2016),
[papers/weitz:icfp:2017](#papers-weitz-icfp-2017),
[notes/compcert-compiler](#notes-compcert-compiler),
[notes/dependent-type](#notes-dependent-type),
[notes/nova-hypervisor](#notes-nova-hypervisor)\


Coq is an [interactive theorem prover]
based on the [calculus of constructions] (CoC)
which is a [constructive logic] based on the
[Curry-Howard correspondence].


[calculus of constructions]: https://en.wikipedia.org/wiki/Calculus_of_constructions
[Curry-Howard correspondence]: https://en.wikipedia.org/wiki/Curry–Howard_correspondence
[constructive logic]: https://en.wikipedia.org/wiki/Intuitionistic_logic



[dependent type]: #notes-dependent-type
# Corral verifier {#notes-corral-verifier}


[[Google Scholar]](https://scholar.google.com/scholar?q=Corral%20verifier)
[[Website]](https://www.microsoft.com/en-us/research/project/q-program-verifier/)

Notes: 
[Boogie verifier](#Boogie verifier)\
Referenced by: 
[papers/baranowski:atva:2018](#papers-baranowski-atva-2018),
[papers/barnett:fmco:2005](#papers-barnett-fmco-2005),
[papers/lal:cav:2012](#papers-lal-cav-2012),
[papers/lal:fse:2014](#papers-lal-fse-2014)\


Corral is a whole-program analysis tool for [Boogie][Boogie verifier] programs
that searches for assertion violations.
Corral was developed by Microsoft Research.



[Boogie verifier]: #notes-boogie-verifier
# CPAchecker verifier {#notes-cpachecker-verifier}


[[Google Scholar]](https://scholar.google.com/scholar?q=CPAchecker%20verifier)
[[Wikipedia]](https://en.wikipedia.org/wiki/CPAchecker)

Notes: 
[model checking](#model checking),
[BLAST verifier](#BLAST verifier),
[SV competition](#SV competition)\
Papers: 
[beyer:cav:2011](#beyer-cav-2011),
[necula:cc:2002](#necula-cc-2002)\
Referenced by: 
[papers/beyer:cav:2011](#papers-beyer-cav-2011),
[notes/blast-verifier](#notes-blast-verifier),
[notes/sv-competition](#notes-sv-competition)\


> CPAchecker is a framework and tool for formal software verification, and
> program analysis, of C programs. Some of its ideas and concepts, for example
> lazy abstraction, were inherited from the software model checker
> [BLAST][BLAST verifier].
> <br>--- [Wikipedia](https://en.wikipedia.org/wiki/CPAchecker)



[model checking]: #notes-model-checking
[BLAST verifier]: #notes-blast-verifier
[SV competition]: #notes-sv-competition
[beyer:cav:2011]: #papers-beyer-cav-2011
[necula:cc:2002]: #papers-necula-cc-2002
# CPU verification {#notes-cpu-verification}


[[Google Scholar]](https://scholar.google.com/scholar?q=CPU%20verification)

Notes: 
[ISA specification](#ISA specification)\
Referenced by: 
[papers/aagaard:charme:2001](#papers-aagaard-charme-2001),
[papers/aagaard:fmcad:2000](#papers-aagaard-fmcad-2000),
[papers/albin:cli:1995](#papers-albin-cli-1995),
[papers/bevier:jar:1989](#papers-bevier-jar-1989),
[papers/beyer:ijsttt:2006](#papers-beyer-ijsttt-2006),
[papers/burch:cav:1994](#papers-burch-cav-1994),
[papers/fox:ucam:2002](#papers-fox-ucam-2002),
[papers/greve:fmcad:1998](#papers-greve-fmcad-1998),
[papers/higgins:hldvt:2004](#papers-higgins-hldvt-2004),
[papers/huang:todaes:2019](#papers-huang-todaes-2019),
[papers/hunt:jar:1989](#papers-hunt-jar-1989),
[papers/hunt:lncs:1994](#papers-hunt-lncs-1994),
[papers/hunt:micro:1999](#papers-hunt-micro-1999),
[papers/jhala:cav:2001](#papers-jhala-cav-2001),
[papers/kaivola:cav:2009](#papers-kaivola-cav-2009),
[papers/kirankumar:fmcad:2012](#papers-kirankumar-fmcad-2012),
[papers/kroening:dac:2001](#papers-kroening-dac-2001),
[papers/kroening:itg:2000](#papers-kroening-itg-2000),
[papers/kuhne:fmcad:2010](#papers-kuhne-fmcad-2010),
[papers/lahiri:cav:2003](#papers-lahiri-cav-2003),
[papers/lahiri:hldvt:2001](#papers-lahiri-hldvt-2001),
[papers/lustig:asplos:2016](#papers-lustig-asplos-2016),
[papers/mcmillan:cav:1998](#papers-mcmillan-cav-1998),
[papers/reid:cav:2016](#papers-reid-cav-2016),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[papers/segar:fmsd:1995](#papers-segar-fmsd-1995),
[papers/slobodova:memocode:2011](#papers-slobodova-memocode-2011),
[papers/srinivasan:ieeetoc:2010](#papers-srinivasan-ieeetoc-2010),
[papers/stewart:difts:2014](#papers-stewart-difts-2014),
[papers/velev:dac:2000](#papers-velev-dac-2000),
[papers/windley:ieeetoc:1995](#papers-windley-ieeetoc-1995),
[papers/zhang:fmcad:2018](#papers-zhang-fmcad-2018),
[notes/isa-specification](#notes-isa-specification),
[notes/symbolic-trajectory-evaluation](#notes-symbolic-trajectory-evaluation)\




[ISA specification]: #notes-isa-specification
# Cray architecture {#notes-cray-architecture}


[[Google Scholar]](https://scholar.google.com/scholar?q=Cray%20architecture)
[[Wikipedia]](https://en.wikipedia.org/wiki/Cray)

Is a kind of: 
[instruction set architecture](#instruction set architecture)\
Notes: 
[vector architecture](#vector architecture)\
Papers: 
[russell:cacm:1978](#russell-cacm-1978)\
Referenced by: 
[papers/palacharla:micro:1995](#papers-palacharla-micro-1995),
[papers/russell:cacm:1978](#papers-russell-cacm-1978),
[papers/smith:tocs:1984](#papers-smith-tocs-1984),
[notes/instruction-set-architecture](#notes-instruction-set-architecture)\



[vector architecture]: #notes-vector-architecture
[russell:cacm:1978]: #papers-russell-cacm-1978
# CVC4 solver {#notes-cvc4-solver}


[[Google Scholar]](https://scholar.google.com/scholar?q=CVC4%20solver)

Is a kind of: 
[SMT solver](#SMT solver)\
Papers: 
[barrett:cav:2011](#barrett-cav-2011)\
Referenced by: 
[papers/barrett:cav:2011](#papers-barrett-cav-2011),
[notes/smt-solver](#notes-smt-solver)\



[barrett:cav:2011]: #papers-barrett-cav-2011
# Dafny verifier {#notes-dafny-verifier}

![Dafny verifier](https://www.microsoft.com/en-us/research/wp-content/uploads/2008/12/dafny-logo_sm.jpg){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=Dafny%20verifier)
[[Website]](https://www.microsoft.com/en-us/research/project/dafny-a-language-and-program-verifier-for-functional-correctness/)
[[Wikipedia]](https://en.wikipedia.org/wiki/Dafny)

Notes: 
[auto-active verification](#auto-active verification)\
Papers: 
[leino:icse:2013](#leino-icse-2013)\
Referenced by: 
[papers/legoues:sefm:2011](#papers-legoues-sefm-2011),
[papers/leino:icse:2013](#papers-leino-icse-2013),
[papers/leino:lpair:2010](#papers-leino-lpair-2010),
[papers/mai:asplos:2013](#papers-mai-asplos-2013),
[notes/auto-active-verification](#notes-auto-active-verification)\


Dafny is a language and [auto-active program verifier][auto-active verification]
developed by Microsoft Research.

The [Dafny paper][leino:icse:2013] is quite an early description I think.



[auto-active verification]: #notes-auto-active-verification
[leino:icse:2013]: #papers-leino-icse-2013
# DART verifier {#notes-dart-verifier}


[[Google Scholar]](https://scholar.google.com/scholar?q=DART%20verifier)

Notes: 
[symbolic execution](#symbolic execution)\
Referenced by: 
[papers/cadar:cacm:2013](#papers-cadar-cacm-2013),
[papers/godefroid:pldi:2005](#papers-godefroid-pldi-2005),
[notes/fuzz-testing](#notes-fuzz-testing),
[notes/symbolic-execution](#notes-symbolic-execution)\


DART is a [symbolic execution] tool developed at Bell Labs and 
a forerunner to the [SAGE verifier].

DART is based on "concolic" execution.



[symbolic execution]: #notes-symbolic-execution
# Data parallelism {#notes-data-parallelism}


[[Google Scholar]](https://scholar.google.com/scholar?q=Data%20parallelism)

Notes: 
[SIMD](#SIMD),
[MIMD](#MIMD),
[parallelism](#parallelism)\
Papers: 
[flynn:ieeeproc:1966](#flynn-ieeeproc-1966)\
Referenced by: 
[papers/blelloch:book:1990](#papers-blelloch-book-1990),
[papers/flynn:ieeeproc:1966](#papers-flynn-ieeeproc-1966),
[papers/kozyrakis:phd:2002](#papers-kozyrakis-phd-2002),
[papers/silva:sbac:2016](#papers-silva-sbac-2016),
[papers/subhlok:ppopp:1993](#papers-subhlok-ppopp-1993),
[notes/mimd](#notes-mimd),
[notes/parallelism](#notes-parallelism),
[notes/simd](#notes-simd),
[notes/vector-architecture](#notes-vector-architecture)\



[SIMD]: #notes-simd
[MIMD]: #notes-mimd
[parallelism]: #notes-parallelism
[flynn:ieeeproc:1966]: #papers-flynn-ieeeproc-1966
# Decidability ceiling {#notes-decidability-ceiling}


[[Google Scholar]](https://scholar.google.com/scholar?q=Decidability%20ceiling)

Referenced by: 
[papers/leino:informatics:2001](#papers-leino-informatics-2001)\





# Decoupling {#notes-decoupling}


[[Google Scholar]](https://scholar.google.com/scholar?q=Decoupling)

Notes: 
[stream processing](#stream processing)\
Papers: 
[smith:tocs:1984](#smith-tocs-1984),
[palacharla:micro:1995](#palacharla-micro-1995)\
Referenced by: 
[papers/bird:sc:1993](#papers-bird-sc-1993),
[papers/palacharla:micro:1995](#papers-palacharla-micro-1995),
[papers/reid:cases:2008](#papers-reid-cases-2008),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[papers/smith:tocs:1984](#papers-smith-tocs-1984),
[notes/parallelism](#notes-parallelism),
[notes/stream-processing](#notes-stream-processing)\



[stream processing]: #notes-stream-processing
[smith:tocs:1984]: #papers-smith-tocs-1984
[palacharla:micro:1995]: #papers-palacharla-micro-1995
# Dependent type {#notes-dependent-type}


[[Google Scholar]](https://scholar.google.com/scholar?q=Dependent%20type)
[[Wikipedia]](https://en.wikipedia.org/wiki/Dependent_type)

Notes: 
[Lean theorem prover](#Lean theorem prover),
[Coq theorem prover](#Coq theorem prover),
[ASL](#ASL),
[Sail language](#Sail language),
[type inference](#type inference)\
Referenced by: 
[papers/armstrong:arw:2018](#papers-armstrong-arw-2018),
[papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019),
[papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019),
[papers/ferraiuolo:dac:2017](#papers-ferraiuolo-dac-2017),
[papers/nanevski:icfp:2008](#papers-nanevski-icfp-2008),
[papers/nanevski:oopsla:2019](#papers-nanevski-oopsla-2019),
[papers/reid:cav:2016](#papers-reid-cav-2016),
[papers/reid:fmcad:2016](#papers-reid-fmcad-2016),
[papers/reid:oopsla:2017](#papers-reid-oopsla-2017),
[papers/xi:icfp:2001](#papers-xi-icfp-2001),
[notes/coq-theorem-prover](#notes-coq-theorem-prover)\


A dependent type is a type whose definition depends on a value.

Some common forms of dependent type are
- product types &Pi;
- sum types &Sigma;
- sized vector types such as "N-bit bitvectors".

See also: [Barendregt cube](https://en.wikipedia.org/wiki/Lambda_cube).



[Lean theorem prover]: #notes-lean-theorem-prover
[Coq theorem prover]: #notes-coq-theorem-prover
[ASL]: #notes-asl
[Sail language]: #notes-sail-language
[type inference]: #notes-type-inference
# Differential Power Analysis {#notes-differential-power-analysis}


[[Google Scholar]](https://scholar.google.com/scholar?q=Differential%20Power%20Analysis)
[[Wikipedia]](https://en.wikipedia.org/wiki/Power_analysis#Differential_power_analysis)

Notes: 
[side channel](#side channel),
[security](#security),
[microarchitecture](#microarchitecture)\
Papers: 
[kocher:crypto:1999](#kocher-crypto-1999)\
Referenced by: 
[papers/kocher:crypto:1999](#papers-kocher-crypto-1999)\



[side channel]: #notes-side-channel
[security]: #notes-security
[microarchitecture]: #notes-microarchitecture
[kocher:crypto:1999]: #papers-kocher-crypto-1999
# Distributed Shared Memory {#notes-distributed-shared-memory}


[[Google Scholar]](https://scholar.google.com/scholar?q=Distributed%20Shared%20Memory)
[[Wikipedia]](https://en.wikipedia.org/wiki/Distributed_shared_memory)

Notes: 
[weak memory](#weak memory)\
Papers: 
[li:tocs:1989](#li-tocs-1989)\
Referenced by: 
[papers/bershad:cmpcon:1993](#papers-bershad-cmpcon-1993),
[papers/johnson:osr:1995](#papers-johnson-osr-1995),
[papers/li:tocs:1989](#papers-li-tocs-1989)\



[weak memory]: #notes-weak-memory
[li:tocs:1989]: #papers-li-tocs-1989
# Domain Specific Language (DSL) {#notes-domain-specific-language}


[[Google Scholar]](https://scholar.google.com/scholar?q=Domain%20Specific%20Language%20%28DSL%29)
[[Wikipedia]](https://en.wikipedia.org/wiki/Domain-specific_language)

Referenced by: 
[papers/eide:aspse:2001](#papers-eide-aspse-2001),
[papers/eide:icse:2002](#papers-eide-icse-2002),
[papers/peterson:padl:2001](#papers-peterson-padl-2001),
[papers/reid:icse:1999](#papers-reid-icse-1999)\



# Embedding {#notes-embedding}


[[Google Scholar]](https://scholar.google.com/scholar?q=Embedding)

Papers: 
[boulton:tpcd:1993](#boulton-tpcd-1993)\
Referenced by: 
[papers/boulton:tpcd:1993](#papers-boulton-tpcd-1993)\



[boulton:tpcd:1993]: #papers-boulton-tpcd-1993
# Entropy {#notes-entropy}


[[Google Scholar]](https://scholar.google.com/scholar?q=Entropy)

Referenced by: 
[papers/bohme:fse:2020](#papers-bohme-fse-2020)\




# Events {#notes-events}


[[Google Scholar]](https://scholar.google.com/scholar?q=Events)

Notes: 
[threads](#threads),
[continuations](#continuations)\
Papers: 
[ousterhout:usenix:1996](#ousterhout-usenix-1996),
[vonbehren:hotos:2003](#vonbehren-hotos-2003)\
Referenced by: 
[papers/dabek:sigops:2002](#papers-dabek-sigops-2002),
[papers/dunkels:enss:2006](#papers-dunkels-enss-2006),
[papers/gay:pldi:2003](#papers-gay-pldi-2003),
[papers/vonbehren:hotos:2003](#papers-vonbehren-hotos-2003)\



[threads]: #notes-threads
[continuations]: #notes-continuations
[ousterhout:usenix:1996]: #papers-ousterhout-usenix-1996
[vonbehren:hotos:2003]: #papers-vonbehren-hotos-2003
# Extended static checking (ESC) {#notes-extended-static-checking}


[[Google Scholar]](https://scholar.google.com/scholar?q=Extended%20static%20checking%20%28ESC%29)
[[Wikipedia]](https://en.wikipedia.org/wiki/Extended_static_checking)

Notes: 
[SeaHorn verifier](#SeaHorn verifier),
[SMACK verifier](#SMACK verifier),
[SV competition](#SV competition),
[AoRTE](#AoRTE)\
Referenced by: 
[papers/beyer:cav:2011](#papers-beyer-cav-2011),
[papers/beyer:ijsttt:2007](#papers-beyer-ijsttt-2007),
[papers/leino:informatics:2001](#papers-leino-informatics-2001),
[papers/lindner:indin:2018](#papers-lindner-indin-2018),
[papers/lindner:indin:2019](#papers-lindner-indin-2019),
[notes/aorte](#notes-aorte),
[notes/blast-verifier](#notes-blast-verifier),
[notes/sv-competition](#notes-sv-competition)\


> ESC can be thought of as an extended form of type checking.
> [...]
> it promotes practicality over soundness, in that it aims to dramatically
> reduce the number of false positives (overestimated errors that are not real
> errors, that is, ESC over strictness) at the cost of introducing some false
> negatives (real ESC underestimation error, but that need no programmer's
> attention, or are not targeted by ESC).
> ESC can identify a range of errors which are currently outside the scope of
> a type checker, including division by zero, array out of bounds, integer
> overflow and null dereferences.
> <br>--- [Wikipedia](https://en.wikipedia.org/wiki/Extended_static_checking)

Extended static checking achieves ["Absence of RunTime Exceptions"][AoRTE]
(AoRTE) which is things like

- No division by zero
- No integer overflow
- Memory safety
  - All array accesses in bounds
  - No null dereferences
  - No buffer overflows
  - No use after free
  - No memory leaks
- Lock safety of concurrent code

The nice thing about extended static checking is that you don't have
to write specifications or proofs.

The software verification competition [SV-COMP][SV competition] mostly checks
properties like this.



[SeaHorn verifier]: #notes-seahorn-verifier
[SMACK verifier]: #notes-smack-verifier
[SV competition]: #notes-sv-competition
[AoRTE]: #notes-aorte
# Foreign function interface {#notes-foreign-function-interface}


[[Google Scholar]](https://scholar.google.com/scholar?q=Foreign%20function%20interface)
[[Wikipedia]](https://en.wikipedia.org/wiki/Foreign_function_interface)

Papers: 
[chakravarty:haskffi:2003](#chakravarty-haskffi-2003),
[jones:hw:1997](#jones-hw-1997)\
Referenced by: 
[papers/chakravarty:haskffi:2003](#papers-chakravarty-haskffi-2003),
[papers/jones:hw:1997](#papers-jones-hw-1997),
[papers/reid:gfpw:1994](#papers-reid-gfpw-1994),
[notes/smt-lib-format](#notes-smt-lib-format)\


todo


[chakravarty:haskffi:2003]: #papers-chakravarty-haskffi-2003
[jones:hw:1997]: #papers-jones-hw-1997
# Formal specification {#notes-formal-specification}


[[Google Scholar]](https://scholar.google.com/scholar?q=Formal%20specification)
[[Wikipedia]](https://en.wikipedia.org/wiki/Formal_specification)

Referenced by: 
[papers/bodin:popl:2014](#papers-bodin-popl-2014),
[papers/burke:lacl:2005](#papers-burke-lacl-2005),
[papers/cifuentes:iwpc:1998](#papers-cifuentes-iwpc-1998),
[papers/damm:fmoods:1999](#papers-damm-fmoods-1999),
[papers/falkoff:ibm:1964](#papers-falkoff-ibm-1964),
[papers/fauth:edtc:1995](#papers-fauth-edtc-1995),
[papers/mavin:isre:2009](#papers-mavin-isre-2009),
[papers/reid:fmcad:2016](#papers-reid-fmcad-2016),
[papers/reid:msc:1993](#papers-reid-msc-1993),
[notes/l3](#notes-l3)\



# FShell Query Language (FQL) {#notes-fql}


[[Google Scholar]](https://scholar.google.com/scholar?q=FShell%20Query%20Language%20%28FQL%29)

Notes: 
[SV competition](#SV competition)\
Papers: 
[holzer:cav:2008](#holzer-cav-2008),
[holzer:hvc:2010](#holzer-hvc-2010)\
Referenced by: 
[papers/beyer:ase:2019](#papers-beyer-ase-2019),
[papers/beyer:hvc:2017](#papers-beyer-hvc-2017),
[papers/holzer:cav:2008](#papers-holzer-cav-2008),
[papers/holzer:hvc:2010](#papers-holzer-hvc-2010),
[notes/sv-competition](#notes-sv-competition),
[notes/test-competition](#notes-test-competition)\


FQL is a query language for describing code coverage criteria.
It consists of

- structural constraints specified as path automata
- quality constraints such as
  - block coverage
  - condition coverage
  - predicate coverage

The syntax of FQL is defined in [holzer:hvc:2010].
An FQL spec has the form

    in G cover C passing P

where

- "in G" and "passing P" are optional
- G is a filter functon
  - "@BASICBLOCKENTRY"
  - "@FUNC(<name>)" ("@CALL" in later work)
  - "@CONDITIONEDGE" ("@DECISIONEDGE" in later work)
- C is a coverage specification
    - A regexp like syntax
        - line specifications @4, @7, etc.
        - conditions "{ x == 42 }", etc.
        - wildcards "ID"
        - quoted regexps
        - Normal regexp syntax: ".", "*", "+", "^" and "$" ("*" can only occur inside quotes)
    - Which are used in
        - edges using "EDGES(regex)"
        - nodes (i.e., statements) using "NODES(regex)"
        - paths using "PATHS(T, k)" where "T" is a filter function and "k"
          is a bound on how many times "T" appears.

- P is a "passing clause": a path pattern that every test case must satisfy
  - For example, "^NOT(@CALL(unimplemented))*$"
  - For example, "^(ID.{x >= 0})*$" specifies tests where x never becomes
    negative.

The syntax "in @FUNC(foo) cover EDGES(@DEF(x))" is equivalent to
"cover EDGES(COMPOSE(@DEF(x), @FUNC(foo)))".

Sugar:

- "->" == ".ID*"




[SV competition]: #notes-sv-competition
[holzer:cav:2008]: #papers-holzer-cav-2008
[holzer:hvc:2010]: #papers-holzer-hvc-2010
# Fractional permissions {#notes-fractional-permissions}


[[Google Scholar]](https://scholar.google.com/scholar?q=Fractional%20permissions)

Notes: 
[separation logic](#separation logic),
[permission logic](#permission logic),
[permission accounting](#permission accounting)\
Papers: 
[bornat:popl:2005](#bornat-popl-2005),
[heule:ftfjp:2011](#heule-ftfjp-2011)\
Referenced by: 
[papers/bornat:popl:2005](#papers-bornat-popl-2005),
[papers/heule:ftfjp:2011](#papers-heule-ftfjp-2011),
[papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011),
[papers/jacobs:vstte:2010](#papers-jacobs-vstte-2010),
[papers/leino:fosad:2007](#papers-leino-fosad-2007),
[notes/permission-accounting](#notes-permission-accounting),
[notes/verifast-verifier](#notes-verifast-verifier)\


Fractional permissions
is trick used in [separation logic]
and its generalization [permission logic] to
for [permission accounting].
That is, to track the notion of sharing a resource.
The idea is to distinguish between

- owning 100% of a resource that allows you to do anything with it: read/write/delete.
- having several owners of a resource that might each own 50%, 25% and 25%
  (say) of the resource and can only read the resource.

Adapted for [separation logic] by [bornat:popl:2005].
Later, [heule:ftfjp:2011] developed a variation that avoids the sometimes ad hoc
choice of what fractions to use.





[separation logic]: #notes-separation-logic
[permission logic]: #notes-permission-logic
[permission accounting]: #notes-permission-accounting
[bornat:popl:2005]: #papers-bornat-popl-2005
[heule:ftfjp:2011]: #papers-heule-ftfjp-2011
# Frama-C verifier {#notes-frama-c-verifier}

![Frama-C verifier](http://frama-c.com/modern/framac.gif){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=Frama-C%20verifier)
[[Website]](http://frama-c.com)
[[Wikipedia]](https://en.wikipedia.org/wiki/Frama-C)

Notes: 
[undefined behaviour](#undefined behaviour)\
Papers: 
[cuoq:sefm:2012](#cuoq-sefm-2012)\
Referenced by: 
[papers/blanchard:fmics:2015](#papers-blanchard-fmics-2015),
[papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012),
[papers/mangano:crisis:2016](#papers-mangano-crisis-2016),
[papers/vasudevan:usenix:2016](#papers-vasudevan-usenix-2016),
[notes/undefined-behaviour](#notes-undefined-behaviour)\


Frama-C (the Framework for Modular Analysis of C programs)
is a set of interoperable program analyzers for C programs.
It is structured as a plugin architecture supporting 
value analysis, deductive verification, weakest precondition
calculation, impact analysis and program slicing.
This is supported by a framework based on the CIL frontend to parse C code,
and some common analyses and libraries.

Frama-C also forms the basis of the [tis interpreter]
that executes C programs and detects [undefined behaviour].

Frama-C has commercial support from [TrustInSoft].

[TrustInSoft]: http://trust-in-soft.com/
[tis interpreter]: http://trust-in-soft.com/tis-interpreter



[undefined behaviour]: #notes-undefined-behaviour
[cuoq:sefm:2012]: #papers-cuoq-sefm-2012
# Frame rule {#notes-frame-rule}


[[Google Scholar]](https://scholar.google.com/scholar?q=Frame%20rule)
[[Wikipedia]](https://en.wikipedia.org/wiki/Frame_problem#Separation_logic_solution)

Notes: 
[separation logic](#separation logic)\
Referenced by: 
[papers/hobor:popl:2013](#papers-hobor-popl-2013),
[papers/krishnaswami:tldi:2010](#papers-krishnaswami-tldi-2010),
[notes/concurrent-separation-logic](#notes-concurrent-separation-logic)\


todo



[separation logic]: #notes-separation-logic
# Functional Reactive Programming (FRP) {#notes-functional-reactive-programming}


[[Google Scholar]](https://scholar.google.com/scholar?q=Functional%20Reactive%20Programming%20%28FRP%29)
[[Wikipedia]](https://en.wikipedia.org/wiki/Functional_reactive_programming)

Referenced by: 
[papers/peterson:padl:2001](#papers-peterson-padl-2001),
[papers/reid:icse:1999](#papers-reid-icse-1999)\



# Fuzz testing {#notes-fuzz-testing}


[[Google Scholar]](https://scholar.google.com/scholar?q=Fuzz%20testing)
[[Wikipedia]](https://en.wikipedia.org/wiki/Fuzzing)

Notes: 
[symbolic execution](#symbolic execution),
[DART verifier](#DART verifier),
[KLEE verifier](#KLEE verifier)\
Papers: 
[godefroid:cacm:2020](#godefroid-cacm-2020),
[manes:ieeetse:2019](#manes-ieeetse-2019),
[miller:cacm:1990](#miller-cacm-1990)\
Referenced by: 
[papers/babic:fse:2019](#papers-babic-fse-2019),
[papers/beyer:ase:2019](#papers-beyer-ase-2019),
[papers/beyer:hvc:2017](#papers-beyer-hvc-2017),
[papers/bohme2:fse:2020](#papers-bohme2-fse-2020),
[papers/bohme:fse:2020](#papers-bohme-fse-2020),
[papers/braione:icse:2018](#papers-braione-icse-2018),
[papers/claessen:icfp:2000](#papers-claessen-icfp-2000),
[papers/dimjasevic:ifm:2018](#papers-dimjasevic-ifm-2018),
[papers/garg:icse:2013](#papers-garg-icse-2013),
[papers/godefroid:cacm:2020](#papers-godefroid-cacm-2020),
[papers/goodman:ndss:2018](#papers-goodman-ndss-2018),
[papers/maciver:ecoop:2020](#papers-maciver-ecoop-2020),
[papers/manes:ieeetse:2019](#papers-manes-ieeetse-2019),
[papers/miller:cacm:1990](#papers-miller-cacm-1990),
[papers/regehr:pldi:2012](#papers-regehr-pldi-2012),
[papers/stephens:ndss:2016](#papers-stephens-ndss-2016),
[papers/visser:tacas:2020](#papers-visser-tacas-2020),
[notes/property-based-testing](#notes-property-based-testing),
[notes/sage-verifier](#notes-sage-verifier),
[notes/search-based-test-generation](#notes-search-based-test-generation),
[notes/symbolic-execution](#notes-symbolic-execution),
[notes/test-case-reduction](#notes-test-case-reduction),
[notes/test-generation](#notes-test-generation)\


Testing a piece of code with a broad range of
unexpected inputs typically done to find security
vulnerabilities.
Unlike traditional testing, it uses less human understanding
of the program and is often performed by non-developers of the code.

See the surveys for more detail: [godefroid:cacm:2020], [manes:ieeetse:2019].

Programs are often instrumented to detect more errors (e.g.,
address/memory/UB/thread sanitizers, control-flow integrity, etc.).

Three types of fuzzer based on how much knowledge of
the program under test they exploit.

- blackbox fuzzing
- greybox fuzzing
  - coverage guided such as EFS, Randoop, AFL, VUzzer
- whitebox fuzzing
  - [symbolic execution] such as [DART verifier] and [KLEE verifier]
  - taint analysis that determines dependencies of branches on
    particular parts of input
- hybrid fuzzers alternate between white- and grey-box fuzzing
  e.g., Driller

Related concept of random test generation differs in that there
may be more focus on generating inputs that are restricted in
some way. For example, we might want to restrict to syntactically legal
inputs.
So we get concepts like

- "rejection sampling" – retry generating a value until it satisfies some
  predicate.
- grammar-based generation and discovering grammars
- use of dictionaries



[symbolic execution]: #notes-symbolic-execution
[DART verifier]: #notes-dart-verifier
[KLEE verifier]: #notes-klee-verifier
[godefroid:cacm:2020]: #papers-godefroid-cacm-2020
[manes:ieeetse:2019]: #papers-manes-ieeetse-2019
[miller:cacm:1990]: #papers-miller-cacm-1990
# Ghost code {#notes-ghost-code}


[[Google Scholar]](https://scholar.google.com/scholar?q=Ghost%20code)

Notes: 
[annotation burden](#annotation burden)\
Referenced by: 
[papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011),
[papers/jacobs:vstte:2010](#papers-jacobs-vstte-2010),
[papers/leino:fosad:2007](#papers-leino-fosad-2007),
[papers/leino:icse:2013](#papers-leino-icse-2013),
[notes/annotation-burden](#notes-annotation-burden)\


todo



[annotation burden]: #notes-annotation-burden
# Google infrastructure {#notes-google-infrastructure}


[[Google Scholar]](https://scholar.google.com/scholar?q=Google%20infrastructure)

Referenced by: 
[papers/chang:tocs:2012](#papers-chang-tocs-2012),
[papers/corbett:tocs:2013](#papers-corbett-tocs-2013),
[papers/potvin:cacm:2016](#papers-potvin-cacm-2016),
[papers/sadowski:cacm:2018](#papers-sadowski-cacm-2018),
[papers/sadowski:icse-seip:2018](#papers-sadowski-icse-seip-2018),
[papers/sadowski:icse:2015](#papers-sadowski-icse-2015),
[papers/wright:icsm:2013](#papers-wright-icsm-2013)\


A list of pieces of Google infrastructure mentioned in papers.  (Almost
certainly out of date and inaccurate because it is based on what the papers
said at the time they were written.)

### Bigtable
### ClangMR

Code refactoring infrastructure

### Clipper

Find dead code

### CodeSearch
### Critique

Code review tool

### ErrorProne

Static analysis (under TriCorder)

### MapReduce
### Megastore
### Piper

Distributed version control system optimized for huge monorepos

### Rosie

Splits large changes across multiple reviewing boundaries (for monorepos)

### Spanner

Distributed, timestamped database (replaces BigTable?)

### Tricorder

Static analysis framework

### TrueTime

Time server returning time intervals based on GPS and atomic clocks




# Google papers {#notes-google-papers}


[[Google Scholar]](https://scholar.google.com/scholar?q=Google%20papers)
[[url]](https://research.google/pubs/)

Referenced by: 
[papers/chang:tocs:2012](#papers-chang-tocs-2012),
[papers/corbett:tocs:2013](#papers-corbett-tocs-2013),
[papers/macvean:ppig:2016](#papers-macvean-ppig-2016),
[papers/potvin:cacm:2016](#papers-potvin-cacm-2016),
[papers/sadowski:cacm:2018](#papers-sadowski-cacm-2018),
[papers/sadowski:icse-seip:2018](#papers-sadowski-icse-seip-2018),
[papers/sadowski:icse:2015](#papers-sadowski-icse-2015),
[papers/wright:icsm:2013](#papers-wright-icsm-2013)\






# Haskell language {#notes-haskell-language}

![Haskell language](https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Haskell-Logo.svg/440px-Haskell-Logo.svg.png){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=Haskell%20language)
[[Website]](https://www.haskell.org)
[[Wikipedia]](https://en.wikipedia.org/wiki/Haskell_(programming_language))

Referenced by: 
[papers/chakravarty:haskffi:2003](#papers-chakravarty-haskffi-2003),
[papers/jones:hasklang:1999](#papers-jones-hasklang-1999),
[papers/jones:hasklib:1999](#papers-jones-hasklib-1999),
[papers/jones:hw:1997](#papers-jones-hw-1997),
[papers/jones:pldi:1999](#papers-jones-pldi-1999),
[papers/peterson:hw:1995](#papers-peterson-hw-1995),
[papers/peterson:padl:2001](#papers-peterson-padl-2001),
[papers/reid:gfpw:1993](#papers-reid-gfpw-1993),
[papers/reid:gfpw:1994](#papers-reid-gfpw-1994),
[papers/reid:hw:1995](#papers-reid-hw-1995),
[papers/reid:icse:1999](#papers-reid-icse-1999),
[papers/reid:ifl:1998](#papers-reid-ifl-1998),
[papers/reid:yale:1998](#papers-reid-yale-1998),
[papers/reid:yale:2001](#papers-reid-yale-2001)\




# HOL theorem prover {#notes-hol-theorem-prover}


[[Google Scholar]](https://scholar.google.com/scholar?q=HOL%20theorem%20prover)
[[Wikipedia]](https://en.wikipedia.org/wiki/HOL_(proof_assistant))

Is a kind of: 
[interactive theorem prover](#interactive theorem prover)\
Papers: 
[gordon:book:1993](#gordon-book-1993)\
Referenced by: 
[papers/boulton:tpcd:1993](#papers-boulton-tpcd-1993),
[papers/gordon:book:1993](#papers-gordon-book-1993)\



[gordon:book:1993]: #papers-gordon-book-1993
# Human factors {#notes-human-factors}


[[Google Scholar]](https://scholar.google.com/scholar?q=Human%20factors)

Referenced by: 
[papers/krishnamurthi:fm:2019](#papers-krishnamurthi-fm-2019)\





# Hyperproperty {#notes-hyperproperty}


[[Google Scholar]](https://scholar.google.com/scholar?q=Hyperproperty)

Notes: 
[non-interference](#non-interference)\
Referenced by: 
[papers/clarkson:jcs:2010](#papers-clarkson-jcs-2010),
[notes/non-interference](#notes-non-interference)\


todo:



[non-interference]: #notes-non-interference
# Implicit dynamic frames {#notes-implicit-dynamic-frames}


[[Google Scholar]](https://scholar.google.com/scholar?q=Implicit%20dynamic%20frames)

Is a kind of: 
[permission logic](#permission logic)\
Notes: 
[separation logic](#separation logic)\
Referenced by: 
[papers/kassios:fm:2006](#papers-kassios-fm-2006),
[papers/smans:ecoop:2009](#papers-smans-ecoop-2009),
[notes/permission-logic](#notes-permission-logic)\


A form of [permission logic] and an alternative to [separation logic].



[separation logic]: #notes-separation-logic
# Information flow {#notes-information-flow}


[[Google Scholar]](https://scholar.google.com/scholar?q=Information%20flow)
[[Wikipedia]](https://en.wikipedia.org/wiki/Information_flow_(information_theory))

Notes: 
[self-composition](#self-composition)\
Referenced by: 
[papers/almeida:security:2016](#papers-almeida-security-2016),
[papers/barthe:csfw:2004](#papers-barthe-csfw-2004),
[papers/barthe:iacr:2007](#papers-barthe-iacr-2007),
[papers/barthe:mscs:2011](#papers-barthe-mscs-2011),
[papers/clark:entcs:2002](#papers-clark-entcs-2002),
[papers/clarkson:jcs:2010](#papers-clarkson-jcs-2010),
[papers/costanzo:pldi:2016](#papers-costanzo-pldi-2016),
[papers/deng:hasp:2019](#papers-deng-hasp-2019),
[papers/denning:cacm:1976](#papers-denning-cacm-1976),
[papers/efstathopoulos:sosp:2005](#papers-efstathopoulos-sosp-2005),
[papers/ferraiuolo:asplos:2017](#papers-ferraiuolo-asplos-2017),
[papers/ferraiuolo:ccs:2018](#papers-ferraiuolo-ccs-2018),
[papers/ferraiuolo:dac:2017](#papers-ferraiuolo-dac-2017),
[papers/ferraiuolo:sosp:2017](#papers-ferraiuolo-sosp-2017),
[papers/goguen:secpriv:1982](#papers-goguen-secpriv-1982),
[papers/goguen:secpriv:1984](#papers-goguen-secpriv-1984),
[papers/hritcu:icfp:2013](#papers-hritcu-icfp-2013),
[papers/khakpour:cpp:2013](#papers-khakpour-cpp-2013),
[papers/krohn:sosp:2007](#papers-krohn-sosp-2007),
[papers/leinenbach:fm:2009](#papers-leinenbach-fm-2009),
[papers/liu:cpsspc:2018](#papers-liu-cpsspc-2018),
[papers/lowe:csfw:2015](#papers-lowe-csfw-2015),
[papers/mantel:pls:2007](#papers-mantel-pls-2007),
[papers/mantel:sp:2001](#papers-mantel-sp-2001),
[papers/murray:secpriv:2013](#papers-murray-secpriv-2013),
[papers/myers:csfw:2004](#papers-myers-csfw-2004),
[papers/nelson:sosp:2019](#papers-nelson-sosp-2019),
[papers/oberg:dac:2010](#papers-oberg-dac-2010),
[papers/rushby:sri:1992](#papers-rushby-sri-1992),
[papers/sabelfield:jcs:2009](#papers-sabelfield-jcs-2009),
[papers/sigurbjarnarson:osdi:2018](#papers-sigurbjarnarson-osdi-2018),
[papers/smith:fossacs:2009](#papers-smith-fossacs-2009),
[papers/spencer:security:1999](#papers-spencer-security-1999),
[papers/tiwari:asplos:2009](#papers-tiwari-asplos-2009),
[papers/tiwari:isca:2009](#papers-tiwari-isca-2009),
[papers/tiwari:isca:2011](#papers-tiwari-isca-2011),
[papers/vasudevan:usenix:2016](#papers-vasudevan-usenix-2016),
[papers/weigl:arxiv:2019](#papers-weigl-arxiv-2019),
[papers/zdancewic:csfw:2001](#papers-zdancewic-csfw-2001),
[papers/zdancewic:csfw:2003](#papers-zdancewic-csfw-2003),
[papers/zeldovich:osdi:2006](#papers-zeldovich-osdi-2006),
[papers/zhang:asplos:2015](#papers-zhang-asplos-2015),
[notes/non-interference](#notes-non-interference),
[notes/self-composition](#notes-self-composition)\


todo: refactor this note

Information flow checks are a form of security checks that track where
information is flowing from and to and under which circumstances.
It can be performed as a dynamic check on a single execution ("taint tracking")
or as a static analysis that typically compares results on two or more
executions.

A distinction is often made before "explicit" information flow (e.g., "x = y;")
and "implicit" information flow (e.g., "if y then x = 1;" which has an
information flow from y to x even if y is False).  This distinction reflects
a classic weakness of taint tracking approaches that dynamically tag values
with metadata during an execution and, because they are based on a single
execution, are unable to accurately track information flows in the paths that
are not executed.

Some topics are

-  Declassification
-  Cryptography
-  Operating Systems
-  Languages
   - Type-based information flow checking
   - Self-composition
-  Hardware
-  Systems
-  Quantitative



[self-composition]: #notes-self-composition
# Instruction set architecture {#notes-instruction-set-architecture}


[[Google Scholar]](https://scholar.google.com/scholar?q=Instruction%20set%20architecture)
[[Wikipedia]](https://en.wikipedia.org/wiki/Instruction_set_architecture)

Notes: 
[Arm architecture](#Arm architecture),
[CHERI architecture](#CHERI architecture),
[CRAY architecture](#CRAY architecture),
[MIPS architecture](#MIPS architecture),
[PDP11 architecture](#PDP11 architecture),
[PowerPC architecture](#PowerPC architecture),
[RISCV architecture](#RISCV architecture),
[x86 architecture](#x86 architecture),
[ISA specification](#ISA specification)\
Referenced by: 
[papers/armstrong:arw:2018](#papers-armstrong-arw-2018),
[papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019),
[papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019),
[papers/asanovic:phd:1998](#papers-asanovic-phd-1998),
[papers/barbacci:ieee:1981](#papers-barbacci-ieee-1981),
[papers/baumann:hotos:2017](#papers-baumann-hotos-2017),
[papers/bell:afips:1970](#papers-bell-afips-1970),
[papers/bell:book:1971](#papers-bell-book-1971),
[papers/boettcher:date:2014](#papers-boettcher-date-2014),
[papers/dam:ted:2013](#papers-dam-ted-2013),
[papers/dam:trusted:2013](#papers-dam-trusted-2013),
[papers/dasgupta:pldi:2019](#papers-dasgupta-pldi-2019),
[papers/degenbaev:phd:2012](#papers-degenbaev-phd-2012),
[papers/fisher:isca:1983](#papers-fisher-isca-1983),
[papers/flur:popl:2016](#papers-flur-popl-2016),
[papers/fox:cambridge:2001](#papers-fox-cambridge-2001),
[papers/fox:itp:2010](#papers-fox-itp-2010),
[papers/fox:itp:2012](#papers-fox-itp-2012),
[papers/fox:itps:2015](#papers-fox-itps-2015),
[papers/fox:tphols:2003](#papers-fox-tphols-2003),
[papers/goel:acl2:2013](#papers-goel-acl2-2013),
[papers/goel:fmcad:2014](#papers-goel-fmcad-2014),
[papers/goel:pcs:2017](#papers-goel-pcs-2017),
[papers/goel:phd:2016](#papers-goel-phd-2016),
[papers/gray:micro:2015](#papers-gray-micro-2015),
[papers/gross:micro:2016](#papers-gross-micro-2016),
[papers/hennessy:book:2011](#papers-hennessy-book-2011),
[papers/heule:pldi:2016](#papers-heule-pldi-2016),
[papers/kaufmann:utaustin:2012](#papers-kaufmann-utaustin-2012),
[papers/kozyrakis:phd:2002](#papers-kozyrakis-phd-2002),
[papers/lee:micro:1996](#papers-lee-micro-1996),
[papers/lockhart:ispass:2015](#papers-lockhart-ispass-2015),
[papers/morrisett:pldi:2012](#papers-morrisett-pldi-2012),
[papers/morrisett:wcsss:1999](#papers-morrisett-wcsss-1999),
[papers/myreen:tphols:2009](#papers-myreen-tphols-2009),
[papers/noonan:pldi:2016](#papers-noonan-pldi-2016),
[papers/patterson:cacm:1985](#papers-patterson-cacm-1985),
[papers/patterson:sigarch:1980](#papers-patterson-sigarch-1980),
[papers/pdp11:book:1973](#papers-pdp11-book-1973),
[papers/peleg:micro:1996](#papers-peleg-micro-1996),
[papers/reid:cav:2016](#papers-reid-cav-2016),
[papers/reid:fmcad:2016](#papers-reid-fmcad-2016),
[papers/reid:oopsla:2017](#papers-reid-oopsla-2017),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[papers/russell:cacm:1978](#papers-russell-cacm-1978),
[papers/sarkar:pldi:2011](#papers-sarkar-pldi-2011),
[papers/sarkar:popl:2009](#papers-sarkar-popl-2009),
[papers/seal:book:2000](#papers-seal-book-2000),
[papers/sewell:pldi:2013](#papers-sewell-pldi-2013),
[papers/shi:phd:2013](#papers-shi-phd-2013),
[papers/stephens:micro:2017](#papers-stephens-micro-2017),
[papers/tremblay:micro:1996](#papers-tremblay-micro-1996),
[notes/arm-architecture](#notes-arm-architecture),
[notes/cheri-architecture](#notes-cheri-architecture),
[notes/cray-architecture](#notes-cray-architecture),
[notes/isa-specification](#notes-isa-specification),
[notes/isps](#notes-isps),
[notes/mips-architecture](#notes-mips-architecture),
[notes/pdp11-architecture](#notes-pdp11-architecture),
[notes/powerpc-architecture](#notes-powerpc-architecture),
[notes/risc-architecture](#notes-risc-architecture),
[notes/riscv-architecture](#notes-riscv-architecture),
[notes/vector-architecture](#notes-vector-architecture),
[notes/x86-architecture](#notes-x86-architecture)\




[Arm architecture]: #notes-arm-architecture
[CHERI architecture]: #notes-cheri-architecture
[CRAY architecture]: #notes-cray-architecture
[MIPS architecture]: #notes-mips-architecture
[PDP11 architecture]: #notes-pdp11-architecture
[PowerPC architecture]: #notes-powerpc-architecture
[RISCV architecture]: #notes-riscv-architecture
[x86 architecture]: #notes-x86-architecture
[ISA specification]: #notes-isa-specification
# Interactive theorem prover {#notes-interactive-theorem-prover}


[[Google Scholar]](https://scholar.google.com/scholar?q=Interactive%20theorem%20prover)
[[Wikipedia]](https://en.wikipedia.org/wiki/Proof_assistant)

Referenced by: 
[papers/demoura:cade:2015](#papers-demoura-cade-2015),
[papers/gordon:book:1993](#papers-gordon-book-1993),
[papers/nipkow:book:2002](#papers-nipkow-book-2002),
[notes/annotation-burden](#notes-annotation-burden),
[notes/coq-theorem-prover](#notes-coq-theorem-prover),
[notes/hol-theorem-prover](#notes-hol-theorem-prover),
[notes/lean-theorem-prover](#notes-lean-theorem-prover),
[notes/pvs-theorem-prover](#notes-pvs-theorem-prover)\


An interactive theorem prover (aka "proof assistant")
is an interactive tool for finding and checking proofs.
The search is normally controlled by human provided "tactics".

Some theorem provers follow the "LCF" theorem prover in
generating a proof certificate that is checked by a small
trusted core.
Some variants optimize this process while preserving the
same soundness guarantee.



# Intermediate verification language {#notes-intermediate-verification-language}


[[Google Scholar]](https://scholar.google.com/scholar?q=Intermediate%20verification%20language)

Notes: 
[Boogie verifier](#Boogie verifier),
[Viper verifier](#Viper verifier)\
Papers: 
[legoues:sefm:2011](#legoues-sefm-2011)\
Referenced by: 
[papers/baranowski:atva:2018](#papers-baranowski-atva-2018),
[papers/barnett:fmco:2005](#papers-barnett-fmco-2005),
[papers/leino:tacas:2010](#papers-leino-tacas-2010),
[papers/muller:vmcai:2016](#papers-muller-vmcai-2016),
[papers/rakamaric:cav:2014](#papers-rakamaric-cav-2014),
[papers/siegel:sc:2015](#papers-siegel-sc-2015),
[notes/boogie-verifier](#notes-boogie-verifier),
[notes/civl-verifier](#notes-civl-verifier),
[notes/prusti-verifier](#notes-prusti-verifier),
[notes/smack-verifier](#notes-smack-verifier),
[notes/viper-verifier](#notes-viper-verifier)\


An intermediate verification language is a simple verification language that
more complex languages can be converted down to.

A critical feature in IVLs is that any error messages can be converted back
to the source language as in the [Boogie verification debugger][legoues:sefm:2011].

Examples include
the [Boogie verifier] and
the [Viper verifier].



[Boogie verifier]: #notes-boogie-verifier
[Viper verifier]: #notes-viper-verifier
[legoues:sefm:2011]: #papers-legoues-sefm-2011
# ISA specification {#notes-isa-specification}


[[Google Scholar]](https://scholar.google.com/scholar?q=ISA%20specification)

Notes: 
[instruction set architecture](#instruction set architecture),
[ASL](#ASL),
[ISPS](#ISPS),
[L3](#L3),
[LISA](#LISA),
[Sail language](#Sail language),
[SLED](#SLED),
[CPU verification](#CPU verification),
[translation validation](#translation validation),
[weak memory](#weak memory)\
Referenced by: 
[papers/armstrong:arw:2018](#papers-armstrong-arw-2018),
[papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019),
[papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019),
[papers/bansal:asplos:2006](#papers-bansal-asplos-2006),
[papers/bansal:osdi:2008](#papers-bansal-osdi-2008),
[papers/barbacci:cmu:1972](#papers-barbacci-cmu-1972),
[papers/barbacci:ieee:1981](#papers-barbacci-ieee-1981),
[papers/bell:afips:1970](#papers-bell-afips-1970),
[papers/bell:book:1971](#papers-bell-book-1971),
[papers/beyer:ijsttt:2006](#papers-beyer-ijsttt-2006),
[papers/blanqui:rapido:2011](#papers-blanqui-rapido-2011),
[papers/cattell:phd:1978](#papers-cattell-phd-1978),
[papers/cattell:toplas:1980](#papers-cattell-toplas-1980),
[papers/cifuentes:computer:2000](#papers-cifuentes-computer-2000),
[papers/cifuentes:iwpc:1998](#papers-cifuentes-iwpc-1998),
[papers/dam:ted:2013](#papers-dam-ted-2013),
[papers/dam:trusted:2013](#papers-dam-trusted-2013),
[papers/dasgupta:pldi:2019](#papers-dasgupta-pldi-2019),
[papers/degenbaev:phd:2012](#papers-degenbaev-phd-2012),
[papers/dias:popl:2010](#papers-dias-popl-2010),
[papers/falkoff:ibm:1964](#papers-falkoff-ibm-1964),
[papers/fauth:edtc:1995](#papers-fauth-edtc-1995),
[papers/fernandez:icse:1997](#papers-fernandez-icse-1997),
[papers/flur:popl:2016](#papers-flur-popl-2016),
[papers/fox:cambridge:2001](#papers-fox-cambridge-2001),
[papers/fox:itp:2010](#papers-fox-itp-2010),
[papers/fox:itp:2012](#papers-fox-itp-2012),
[papers/fox:itps:2015](#papers-fox-itps-2015),
[papers/fox:tphols:2003](#papers-fox-tphols-2003),
[papers/godefroid:pldi:2012](#papers-godefroid-pldi-2012),
[papers/goel:acl2:2013](#papers-goel-acl2-2013),
[papers/goel:fmcad:2014](#papers-goel-fmcad-2014),
[papers/goel:phd:2016](#papers-goel-phd-2016),
[papers/gray:micro:2015](#papers-gray-micro-2015),
[papers/hardin:acl2:2006](#papers-hardin-acl2-2006),
[papers/hennessy:micro:1982](#papers-hennessy-micro-1982),
[papers/heule:pldi:2016](#papers-heule-pldi-2016),
[papers/huang:todaes:2019](#papers-huang-todaes-2019),
[papers/kaufmann:utaustin:2012](#papers-kaufmann-utaustin-2012),
[papers/kuhne:fmcad:2010](#papers-kuhne-fmcad-2010),
[papers/lockhart:ispass:2015](#papers-lockhart-ispass-2015),
[papers/mishra:book:2008](#papers-mishra-book-2008),
[papers/morrisett:pldi:2012](#papers-morrisett-pldi-2012),
[papers/myreen:tphols:2009](#papers-myreen-tphols-2009),
[papers/noonan:pldi:2016](#papers-noonan-pldi-2016),
[papers/pdp11:book:1973](#papers-pdp11-book-1973),
[papers/ramsey:lctes:1998](#papers-ramsey-lctes-1998),
[papers/ramsey:toplas:1997](#papers-ramsey-toplas-1997),
[papers/regehr:asplos:2004](#papers-regehr-asplos-2004),
[papers/regehr:emsoft:2003](#papers-regehr-emsoft-2003),
[papers/regehr:lctes:2006](#papers-regehr-lctes-2006),
[papers/regehr:tecs:2005](#papers-regehr-tecs-2005),
[papers/reid:cav:2016](#papers-reid-cav-2016),
[papers/reid:fmcad:2016](#papers-reid-fmcad-2016),
[papers/reid:oopsla:2017](#papers-reid-oopsla-2017),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[papers/roessle:cpp:2019](#papers-roessle-cpp-2019),
[papers/samet:ieeetse:1977](#papers-samet-ieeetse-1977),
[papers/sarkar:pldi:2011](#papers-sarkar-pldi-2011),
[papers/sarkar:popl:2009](#papers-sarkar-popl-2009),
[papers/schmaltz:vstte:2012](#papers-schmaltz-vstte-2012),
[papers/seal:book:2000](#papers-seal-book-2000),
[papers/sewell:pldi:2013](#papers-sewell-pldi-2013),
[papers/shi:phd:2013](#papers-shi-phd-2013),
[papers/su:computer:1974](#papers-su-computer-1974),
[papers/zhang:fmcad:2018](#papers-zhang-fmcad-2018),
[papers/zivojnovic:vlsi:1996](#papers-zivojnovic-vlsi-1996),
[papers/zorn:iscawddd:2017](#papers-zorn-iscawddd-2017),
[notes/arm-architecture](#notes-arm-architecture),
[notes/asl](#notes-asl),
[notes/binary-analysis](#notes-binary-analysis),
[notes/cpu-verification](#notes-cpu-verification),
[notes/instruction-set-architecture](#notes-instruction-set-architecture),
[notes/isps](#notes-isps),
[notes/l3](#notes-l3),
[notes/lisa](#notes-lisa),
[notes/sail-language](#notes-sail-language),
[notes/sled](#notes-sled)\


Specifications of [instruction set architecture]s.



[instruction set architecture]: #notes-instruction-set-architecture
[ASL]: #notes-asl
[ISPS]: #notes-isps
[L3]: #notes-l3
[LISA]: #notes-lisa
[Sail language]: #notes-sail-language
[SLED]: #notes-sled
[CPU verification]: #notes-cpu-verification
[translation validation]: #notes-translation-validation
[weak memory]: #notes-weak-memory
# Instruction Set Processor (ISP) {#notes-isps}


[[Google Scholar]](https://scholar.google.com/scholar?q=Instruction%20Set%20Processor%20%28ISP%29)
[[Website]](http://gordonbell.azurewebsites.net/computer_structures__readings_and_examples/index.html)

Notes: 
[ISA specification](#ISA specification),
[instruction set architecture](#instruction set architecture)\
Papers: 
[bell:afips:1970](#bell-afips-1970),
[bell:book:1971](#bell-book-1971),
[barbacci:cmu:1972](#barbacci-cmu-1972),
[barbacci:ieee:1981](#barbacci-ieee-1981)\
Referenced by: 
[papers/barbacci2:computer:1973](#papers-barbacci2-computer-1973),
[papers/barbacci:afips:1977](#papers-barbacci-afips-1977),
[papers/barbacci:cmu:1972](#papers-barbacci-cmu-1972),
[papers/barbacci:computer:1973](#papers-barbacci-computer-1973),
[papers/barbacci:computer:1977](#papers-barbacci-computer-1977),
[papers/barbacci:computer:1978](#papers-barbacci-computer-1978),
[papers/barbacci:dac:1979](#papers-barbacci-dac-1979),
[papers/barbacci:icse:1988](#papers-barbacci-icse-1988),
[papers/barbacci:ieee:1981](#papers-barbacci-ieee-1981),
[papers/barbacci:ieeetc:1975](#papers-barbacci-ieeetc-1975),
[papers/barbacci:ieeetc:1981](#papers-barbacci-ieeetc-1981),
[papers/barbacci:isca:1973](#papers-barbacci-isca-1973),
[papers/bell:afips:1970](#papers-bell-afips-1970),
[papers/bell:book:1971](#papers-bell-book-1971),
[papers/chu:ieeedtc:1992](#papers-chu-ieeedtc-1992),
[papers/dam:ieeetc:1981](#papers-dam-ieeetc-1981),
[papers/djordjevic:cj:1985](#papers-djordjevic-cj-1985),
[papers/pdp11:book:1973](#papers-pdp11-book-1973),
[papers/su:computer:1974](#papers-su-computer-1974),
[notes/isa-specification](#notes-isa-specification)\




[ISA specification]: #notes-isa-specification
[instruction set architecture]: #notes-instruction-set-architecture
[bell:afips:1970]: #papers-bell-afips-1970
[bell:book:1971]: #papers-bell-book-1971
[barbacci:cmu:1972]: #papers-barbacci-cmu-1972
[barbacci:ieee:1981]: #papers-barbacci-ieee-1981
# JavaScript programming language {#notes-javascript}


[[Google Scholar]](https://scholar.google.com/scholar?q=JavaScript%20programming%20language)
[[Wikipedia]](https://en.wikipedia.org/wiki/JavaScript)

Papers: 
[bodin:popl:2014](#bodin-popl-2014)\
Referenced by: 
[papers/bodin:popl:2014](#papers-bodin-popl-2014)\



[bodin:popl:2014]: #papers-bodin-popl-2014
# KLEE verifier {#notes-klee-verifier}

![KLEE verifier](https://klee.github.io/images/klee.svg){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=KLEE%20verifier)
[[Website]](https://klee.github.io)

Notes: 
[LLVM compiler](#LLVM compiler),
[symbolic execution](#symbolic execution)\
Papers: 
[cadar:cacm:2013](#cadar-cacm-2013),
[cadar:osdi:2008](#cadar-osdi-2008),
[lindner:indin:2018](#lindner-indin-2018),
[lindner:indin:2019](#lindner-indin-2019)\
Referenced by: 
[papers/baldoni:compsurv:2018](#papers-baldoni-compsurv-2018),
[papers/beyer:ase:2019](#papers-beyer-ase-2019),
[papers/beyer:hvc:2017](#papers-beyer-hvc-2017),
[papers/cadar:cacm:2013](#papers-cadar-cacm-2013),
[papers/chipounov:hotdep:2009](#papers-chipounov-hotdep-2009),
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[papers/lindner:indin:2018](#papers-lindner-indin-2018),
[papers/lindner:indin:2019](#papers-lindner-indin-2019),
[papers/wagner:hotos:2013](#papers-wagner-hotos-2013),
[notes/fuzz-testing](#notes-fuzz-testing),
[notes/s2e-verifier](#notes-s2e-verifier),
[notes/symbolic-execution](#notes-symbolic-execution),
[notes/test-competition](#notes-test-competition)\


KLEE is a symbolic virtual machine built on top of the [LLVM compiler].  KLEE
uses [symbolic execution] to generate tests by constructing the "path
conditions" associated with paths through the program and, for each path, using
a constraint solver to solve those conditions to generate inputs that would
cause the program to follow that path.



[LLVM compiler]: #notes-llvm-compiler
[symbolic execution]: #notes-symbolic-execution
[cadar:cacm:2013]: #papers-cadar-cacm-2013
[cadar:osdi:2008]: #papers-cadar-osdi-2008
[lindner:indin:2018]: #papers-lindner-indin-2018
[lindner:indin:2019]: #papers-lindner-indin-2019
# Kripke structure {#notes-kripke-structure}


[[Google Scholar]](https://scholar.google.com/scholar?q=Kripke%20structure)
[[Wikipedia]](https://en.wikipedia.org/wiki/Kripke_structure_(model_checking))

Notes: 
[model checking](#model checking)\
Referenced by: 
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[papers/weigl:arxiv:2019](#papers-weigl-arxiv-2019),
[notes/buchi-automaton](#notes-buchi-automaton),
[notes/model-checking](#notes-model-checking),
[notes/temporal-logic](#notes-temporal-logic)\


In essence, a (finite) labelled transition system in which
every state has at least one transition ("left total").



[model checking]: #notes-model-checking
# L3 specification language {#notes-l3}


[[Google Scholar]](https://scholar.google.com/scholar?q=L3%20specification%20language)

Notes: 
[formal specification](#formal specification),
[ISA specification](#ISA specification),
[Arm architecture](#Arm architecture)\
Papers: 
[fox:itp:2012](#fox-itp-2012)\
Referenced by: 
[papers/fox:itp:2012](#papers-fox-itp-2012),
[notes/isa-specification](#notes-isa-specification)\



[formal specification]: #notes-formal-specification
[ISA specification]: #notes-isa-specification
[Arm architecture]: #notes-arm-architecture
[fox:itp:2012]: #papers-fox-itp-2012
# Lean theorem prover {#notes-lean-theorem-prover}

![Lean theorem prover](https://leanprover.github.io/images/lean_logo.svg){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=Lean%20theorem%20prover)
[[Website]](https://leanprover.github.io)
[[Wikipedia]](https://en.wikipedia.org/wiki/Lean_(proof_assistant))

Notes: 
[interactive theorem prover](#interactive theorem prover)\
Referenced by: 
[papers/demoura:cade:2015](#papers-demoura-cade-2015),
[notes/dependent-type](#notes-dependent-type)\


Lean is an [interactive theorem prover] and programming language developed
at Microsoft Research.



[interactive theorem prover]: #notes-interactive-theorem-prover
# Linear logic {#notes-linear-logic}


[[Google Scholar]](https://scholar.google.com/scholar?q=Linear%20logic)
[[Wikipedia]](https://en.wikipedia.org/wiki/Linear_logic)

Referenced by: 
[papers/morrisett:wcsss:1999](#papers-morrisett-wcsss-1999),
[papers/nanevski:icfp:2008](#papers-nanevski-icfp-2008),
[papers/smith:esop:2000](#papers-smith-esop-2000),
[papers/walker:tic:2001](#papers-walker-tic-2001),
[notes/permission-logic](#notes-permission-logic)\


todo

Mention 'substructural logic' because I keep forgetting the term


# LISA {#notes-lisa}


[[Google Scholar]](https://scholar.google.com/scholar?q=LISA)
[[Wikipedia]](https://en.wikipedia.org/wiki/LISA_(Language_for_Instruction_Set_Architecture))

Notes: 
[ISA specification](#ISA specification)\
Papers: 
[zivojnovic:vlsi:1996](#zivojnovic-vlsi-1996)\
Referenced by: 
[papers/zivojnovic:vlsi:1996](#papers-zivojnovic-vlsi-1996),
[notes/isa-specification](#notes-isa-specification)\



[ISA specification]: #notes-isa-specification
[zivojnovic:vlsi:1996]: #papers-zivojnovic-vlsi-1996
# LLVM compiler {#notes-llvm-compiler}

![LLVM compiler](https://www.llvm.org/img/DragonSmall.png){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=LLVM%20compiler)
[[Website]](https://www.llvm.org/)
[[Wikipedia]](https://en.wikipedia.org/wiki/LLVM)

Referenced by: 
[papers/baranowski:atva:2018](#papers-baranowski-atva-2018),
[papers/gurfinkel:cav:2015](#papers-gurfinkel-cav-2015),
[papers/merz:vstte:2012](#papers-merz-vstte-2012),
[papers/nelson:sosp:2019](#papers-nelson-sosp-2019),
[papers/rakamaric:cav:2014](#papers-rakamaric-cav-2014),
[notes/klee-verifier](#notes-klee-verifier),
[notes/seahorn-verifier](#notes-seahorn-verifier),
[notes/smack-verifier](#notes-smack-verifier)\


todo:



# Loop invariant {#notes-loop-invariant}


[[Google Scholar]](https://scholar.google.com/scholar?q=Loop%20invariant)
[[Wikipedia]](https://en.wikipedia.org/wiki/Loop_invariant)

Papers: 
[hehner:vstte:2008](#hehner-vstte-2008),
[tuerk:vstte:2010](#tuerk-vstte-2010)\
Referenced by: 
[papers/hatcliff:compsurv:2012](#papers-hatcliff-compsurv-2012),
[papers/hehner:vstte:2008](#papers-hehner-vstte-2008),
[papers/sharma:pls:2013](#papers-sharma-pls-2013),
[papers/tuerk:vstte:2010](#papers-tuerk-vstte-2010),
[notes/modular-verification](#notes-modular-verification)\


todo

For an alternative approach,
see [hehner:vstte:2008] and [tuerk:vstte:2010].



[hehner:vstte:2008]: #papers-hehner-vstte-2008
[tuerk:vstte:2010]: #papers-tuerk-vstte-2010
# Magic wand {#notes-magic-wand}


[[Google Scholar]](https://scholar.google.com/scholar?q=Magic%20wand)

Notes: 
[Permission logic](#Permission logic),
[Rust language](#Rust language),
[Separation logic](#Separation logic)\
Papers: 
[astrauskas:oopsla:2019](#astrauskas-oopsla-2019),
[blom:ijsttt:2015](#blom-ijsttt-2015),
[schwerhoff:ecoop:2015](#schwerhoff-ecoop-2015)\
Referenced by: 
[papers/blom:ijsttt:2015](#papers-blom-ijsttt-2015),
[papers/hobor:popl:2013](#papers-hobor-popl-2013),
[papers/krishnaswami:tldi:2010](#papers-krishnaswami-tldi-2010),
[papers/muller:vmcai:2016](#papers-muller-vmcai-2016),
[papers/schwerhoff:ecoop:2015](#papers-schwerhoff-ecoop-2015),
[papers/tuerk:vstte:2010](#papers-tuerk-vstte-2010),
[notes/prusti-verifier](#notes-prusti-verifier)\


"Magic wand" is the somewhat whimsical name for the intuitionistic implication
operator "—∗" used in [Separation logic] and its generalization [Permission
logic].

I get the impression that magic wands were largely ignored because use of magic
wands hit decidability problems.
Some more recent papers that changed that are:
[schwerhoff:ecoop:2015],
[blom:ijsttt:2015].
They get round the decidability problems by introducing witnesses for
magic wands.

Magic wands are useful for modelling partial data structures such as
all the parts of a tree from the root down except for the bit that is
currently being processed.

Magic wands are also used to model borrow semantics in the [Rust language] by
[astrauskas:oopsla:2019].



[Permission logic]: #notes-permission-logic
[Rust language]: #notes-rust-language
[Separation logic]: #notes-separation-logic
[astrauskas:oopsla:2019]: #papers-astrauskas-oopsla-2019
[blom:ijsttt:2015]: #papers-blom-ijsttt-2015
[schwerhoff:ecoop:2015]: #papers-schwerhoff-ecoop-2015
# Memory coherence {#notes-memory-coherence}


[[Google Scholar]](https://scholar.google.com/scholar?q=Memory%20coherence)
[[Wikipedia]](https://en.wikipedia.org/wiki/Memory_coherence)

Notes: 
[weak memory](#weak memory)\
Papers: 
[li:tocs:1989](#li-tocs-1989)\
Referenced by: 
[papers/li:tocs:1989](#papers-li-tocs-1989)\



[weak memory]: #notes-weak-memory
[li:tocs:1989]: #papers-li-tocs-1989
# Microarchitecture {#notes-microarchitecture}


[[Google Scholar]](https://scholar.google.com/scholar?q=Microarchitecture)
[[Wikipedia]](https://en.wikipedia.org/wiki/Microarchitecture)

Referenced by: 
[papers/asanovic:phd:1998](#papers-asanovic-phd-1998),
[papers/baumann:hotos:2017](#papers-baumann-hotos-2017),
[papers/bell:book:1971](#papers-bell-book-1971),
[papers/bird:sc:1993](#papers-bird-sc-1993),
[papers/fauth:edtc:1995](#papers-fauth-edtc-1995),
[papers/fisher:isca:1983](#papers-fisher-isca-1983),
[papers/fox:ucam:2002](#papers-fox-ucam-2002),
[papers/ge:jce:2016](#papers-ge-jce-2016),
[papers/gross:micro:2016](#papers-gross-micro-2016),
[papers/hennessy:book:2011](#papers-hennessy-book-2011),
[papers/kim:isca:2014](#papers-kim-isca-2014),
[papers/kocher:arxiv:2018](#papers-kocher-arxiv-2018),
[papers/kocher:crypto:1999](#papers-kocher-crypto-1999),
[papers/kozyrakis:phd:2002](#papers-kozyrakis-phd-2002),
[papers/kroening:dac:2001](#papers-kroening-dac-2001),
[papers/kroening:itg:2000](#papers-kroening-itg-2000),
[papers/kumar:isca:2004](#papers-kumar-isca-2004),
[papers/palacharla:micro:1995](#papers-palacharla-micro-1995),
[papers/smith:tocs:1984](#papers-smith-tocs-1984),
[papers/tang:sec:2017](#papers-tang-sec-2017),
[notes/differential-power-analysis](#notes-differential-power-analysis),
[notes/risc-architecture](#notes-risc-architecture),
[notes/speculative-execution](#notes-speculative-execution),
[notes/vector-architecture](#notes-vector-architecture),
[notes/vliw](#notes-vliw)\



# Multiple Instruction Multiple Data (MIMD) {#notes-mimd}


[[Google Scholar]](https://scholar.google.com/scholar?q=Multiple%20Instruction%20Multiple%20Data%20%28MIMD%29)

Notes: 
[parallelism](#parallelism),
[data parallelism](#data parallelism),
[SIMD](#SIMD)\
Papers: 
[flynn:ieeeproc:1966](#flynn-ieeeproc-1966)\
Referenced by: 
[papers/flynn:ieeeproc:1966](#papers-flynn-ieeeproc-1966),
[notes/data-parallelism](#notes-data-parallelism),
[notes/parallelism](#notes-parallelism)\



[parallelism]: #notes-parallelism
[data parallelism]: #notes-data-parallelism
[SIMD]: #notes-simd
[flynn:ieeeproc:1966]: #papers-flynn-ieeeproc-1966
# MIPS architecture {#notes-mips-architecture}


[[Google Scholar]](https://scholar.google.com/scholar?q=MIPS%20architecture)
[[Wikipedia]](https://en.wikipedia.org/wiki/MIPS_architecture)

Notes: 
[instruction set architecture](#instruction set architecture)\
Referenced by: 
[papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019),
[papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019),
[papers/gross:micro:2016](#papers-gross-micro-2016),
[papers/hennessy:micro:1982](#papers-hennessy-micro-1982),
[notes/instruction-set-architecture](#notes-instruction-set-architecture)\


MIPS is an [instruction set architecture].



[instruction set architecture]: #notes-instruction-set-architecture
# MIR interpreter (miri) {#notes-mir-interpreter}


[[Google Scholar]](https://scholar.google.com/scholar?q=MIR%20interpreter%20%28miri%29)
[[Website]](https://github.com/rust-lang/miri)

Notes: 
[Rust language](#Rust language),
[MIR](#MIR),
[undefined behaviour](#undefined behaviour)\
Papers: 
[jung:popl:2020](#jung-popl-2020)\
Referenced by: 
[papers/jung:popl:2020](#papers-jung-popl-2020),
[notes/mir](#notes-mir)\


Miri is an interpreter for the [Rust language]'s
mid-level intermediate representation [MIR]
that detects many kinds of [undefined behaviour].



[Rust language]: #notes-rust-language
[MIR]: #notes-mir
[undefined behaviour]: #notes-undefined-behaviour
[jung:popl:2020]: #papers-jung-popl-2020
# MIR {#notes-mir}


[[Google Scholar]](https://scholar.google.com/scholar?q=MIR)

Notes: 
[Rust language](#Rust language),
[MIR interpreter](#MIR interpreter),
[undefined behaviour](#undefined behaviour)\
Papers: 
[jung:popl:2020](#jung-popl-2020)\
Referenced by: 
[papers/jung:popl:2017](#papers-jung-popl-2017),
[papers/jung:popl:2020](#papers-jung-popl-2020),
[papers/matsushita:esop:2020](#papers-matsushita-esop-2020),
[notes/mir-interpreter](#notes-mir-interpreter)\


MIR is the [Rust language]'s
mid-level intermediate representation.

It has an interpreter [miri][MIR interpreter] that attempts to check many
kinds of [undefined behaviour] that is partly described
in [jung:popl:2020].



[Rust language]: #notes-rust-language
[MIR interpreter]: #notes-mir-interpreter
[undefined behaviour]: #notes-undefined-behaviour
[jung:popl:2020]: #papers-jung-popl-2020
# Model checking {#notes-model-checking}


[[Google Scholar]](https://scholar.google.com/scholar?q=Model%20checking)
[[Wikipedia]](https://en.wikipedia.org/wiki/Model_checking)

Notes: 
[temporal logic](#temporal logic),
[Kripke structure](#Kripke structure),
[Buchi automaton](#Buchi automaton)\
Papers: 
[jhala:compsurv:2009](#jhala-compsurv-2009),
[clarke:cacm:2009](#clarke-cacm-2009),
[mcmillan:ecs:2003](#mcmillan-ecs-2003)\
Referenced by: 
[papers/ball:pldi:2001](#papers-ball-pldi-2001),
[papers/beyer:cav:2011](#papers-beyer-cav-2011),
[papers/beyer:ijsttt:2007](#papers-beyer-ijsttt-2007),
[papers/beyer:sas:2004](#papers-beyer-sas-2004),
[papers/biere:tacas:1999](#papers-biere-tacas-1999),
[papers/chong:icse:2020](#papers-chong-icse-2020),
[papers/clarke:cacm:2009](#papers-clarke-cacm-2009),
[papers/clarke:wlop:1982](#papers-clarke-wlop-1982),
[papers/cook:cav:2018](#papers-cook-cav-2018),
[papers/henzinger:spin:2003](#papers-henzinger-spin-2003),
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[papers/krishnamurthi:fm:2019](#papers-krishnamurthi-fm-2019),
[papers/lal:pldi:2015](#papers-lal-pldi-2015),
[papers/mcmillan:cav:1998](#papers-mcmillan-cav-1998),
[papers/mcmillan:ecs:2003](#papers-mcmillan-ecs-2003),
[papers/pnueli:sfcs:1977](#papers-pnueli-sfcs-1977),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[papers/weigl:arxiv:2019](#papers-weigl-arxiv-2019),
[notes/blast-verifier](#notes-blast-verifier),
[notes/bounded-model-checking](#notes-bounded-model-checking),
[notes/buchi-automaton](#notes-buchi-automaton),
[notes/cpachecker-verifier](#notes-cpachecker-verifier),
[notes/kripke-structure](#notes-kripke-structure),
[notes/partial-order-reduction](#notes-partial-order-reduction),
[notes/sat-solver](#notes-sat-solver),
[notes/symbolic-model-checking](#notes-symbolic-model-checking),
[notes/temporal-logic](#notes-temporal-logic)\


todo

<https://en.wikipedia.org/wiki/Category:Model_checking>

<https://en.wikipedia.org/wiki/Widening_(computer_science)>



[temporal logic]: #notes-temporal-logic
[Kripke structure]: #notes-kripke-structure
[Buchi automaton]: #notes-buchi-automaton
[jhala:compsurv:2009]: #papers-jhala-compsurv-2009
[clarke:cacm:2009]: #papers-clarke-cacm-2009
[mcmillan:ecs:2003]: #papers-mcmillan-ecs-2003
# Modular verification {#notes-modular-verification}


[[Google Scholar]](https://scholar.google.com/scholar?q=Modular%20verification)

Notes: 
[loop invariant](#loop invariant),
[contract driven development](#contract driven development)\
Papers: 
[calcagno:popl:2009](#calcagno-popl-2009)\
Referenced by: 
[papers/barnett:fmco:2005](#papers-barnett-fmco-2005),
[papers/calcagno:popl:2009](#papers-calcagno-popl-2009),
[papers/leino:fosad:2007](#papers-leino-fosad-2007),
[papers/lindner:indin:2018](#papers-lindner-indin-2018),
[notes/contract-driven-development](#notes-contract-driven-development),
[notes/spec-sharp-project](#notes-spec-sharp-project)\


todo

See also [contract driven development].
[loop invariant]

One of the big challenges in modular verification is the effort of
creating contracts for every function in a large, existing codebase.
One attack on that problem is biabduction [calcagno:popl:2009].



[loop invariant]: #notes-loop-invariant
[contract driven development]: #notes-contract-driven-development
[calcagno:popl:2009]: #papers-calcagno-popl-2009
# Natural language {#notes-natural-language}


[[Google Scholar]](https://scholar.google.com/scholar?q=Natural%20language)

Referenced by: 
[papers/burke:lacl:2005](#papers-burke-lacl-2005),
[papers/reid:oopsla:2017](#papers-reid-oopsla-2017)\



# Non-interference {#notes-non-interference}


[[Google Scholar]](https://scholar.google.com/scholar?q=Non-interference)
[[Wikipedia]](https://en.wikipedia.org/wiki/Non-interference_(security))

Notes: 
[information flow](#information flow),
[hyperproperty](#hyperproperty)\
Papers: 
[goguen:secpriv:1982](#goguen-secpriv-1982),
[goguen:secpriv:1984](#goguen-secpriv-1984),
[rushby:sri:1992](#rushby-sri-1992),
[bowman:icfp:2015](#bowman-icfp-2015),
[costanzo:pldi:2016](#costanzo-pldi-2016),
[ferraiuolo:sosp:2017](#ferraiuolo-sosp-2017),
[nelson:sosp:2019](#nelson-sosp-2019),
[tiwari:isca:2009](#tiwari-isca-2009)\
Referenced by: 
[papers/bowman:icfp:2015](#papers-bowman-icfp-2015),
[papers/hritcu:icfp:2013](#papers-hritcu-icfp-2013),
[papers/schwarz:sefm:2016](#papers-schwarz-sefm-2016),
[papers/tiwari:isca:2009](#papers-tiwari-isca-2009),
[notes/hyperproperty](#notes-hyperproperty)\


todo:



[information flow]: #notes-information-flow
[hyperproperty]: #notes-hyperproperty
[goguen:secpriv:1982]: #papers-goguen-secpriv-1982
[goguen:secpriv:1984]: #papers-goguen-secpriv-1984
[rushby:sri:1992]: #papers-rushby-sri-1992
[bowman:icfp:2015]: #papers-bowman-icfp-2015
[costanzo:pldi:2016]: #papers-costanzo-pldi-2016
[ferraiuolo:sosp:2017]: #papers-ferraiuolo-sosp-2017
[nelson:sosp:2019]: #papers-nelson-sosp-2019
[tiwari:isca:2009]: #papers-tiwari-isca-2009
# NOVA hypervisor {#notes-nova-hypervisor}


[[Google Scholar]](https://scholar.google.com/scholar?q=NOVA%20hypervisor)
[[Website]](http://hypervisor.org)

Notes: 
[Coq theorem prover](#Coq theorem prover),
[operating systems](#operating systems)\
Papers: 
[becker:fm:2016](#becker-fm-2016)\
Referenced by: 
[papers/becker:fm:2016](#papers-becker-fm-2016)\


NOVA is a hypervisor (or micro-hypervisor) descended from L4.

todo:


[Coq theorem prover]: #notes-coq-theorem-prover
[operating systems]: #notes-operating-systems
[becker:fm:2016]: #papers-becker-fm-2016
# Operating systems {#notes-operating-systems}


[[Google Scholar]](https://scholar.google.com/scholar?q=Operating%20systems)
[[Wikipedia]](https://en.wikipedia.org/wiki/Operating_system)

Referenced by: 
[papers/draves:sosp:1991](#papers-draves-sosp-1991),
[papers/eide:aspse:2001](#papers-eide-aspse-2001),
[papers/eide:icse:2002](#papers-eide-icse-2002),
[papers/lauer:osr:1979](#papers-lauer-osr-1979),
[papers/regehr:acp4is:2003](#papers-regehr-acp4is-2003),
[papers/reid:osdi:2000](#papers-reid-osdi-2000),
[notes/nova-hypervisor](#notes-nova-hypervisor)\



# Ownership types {#notes-ownership-types}


[[Google Scholar]](https://scholar.google.com/scholar?q=Ownership%20types)

Notes: 
[Rust language](#Rust language),
[Prusti verifier](#Prusti verifier),
[Viper verifier](#Viper verifier)\
Papers: 
[jung:popl:2020](#jung-popl-2020),
[astrauskas:oopsla:2019](#astrauskas-oopsla-2019),
[walker:tic:2001](#walker-tic-2001)\
Referenced by: 
[papers/levy:plos:2015](#papers-levy-plos-2015),
[papers/walker:tic:2001](#papers-walker-tic-2001),
[notes/rust-language](#notes-rust-language)\


todo:

[Rust language],
[Prusti verifier],
[astrauskas:oopsla:2019]



[Rust language]: #notes-rust-language
[Prusti verifier]: #notes-prusti-verifier
[Viper verifier]: #notes-viper-verifier
[jung:popl:2020]: #papers-jung-popl-2020
[astrauskas:oopsla:2019]: #papers-astrauskas-oopsla-2019
[walker:tic:2001]: #papers-walker-tic-2001
# Parallelism {#notes-parallelism}


[[Google Scholar]](https://scholar.google.com/scholar?q=Parallelism)

Notes: 
[SIMD](#SIMD),
[MIMD](#MIMD),
[data parallelism](#data parallelism),
[decoupling](#decoupling),
[speculative execution](#speculative execution),
[threads](#threads)\
Papers: 
[flynn:ieeeproc:1966](#flynn-ieeeproc-1966)\
Referenced by: 
[papers/kumar:isca:2004](#papers-kumar-isca-2004),
[notes/data-parallelism](#notes-data-parallelism),
[notes/mimd](#notes-mimd),
[notes/pipeline-parallelism](#notes-pipeline-parallelism),
[notes/simd](#notes-simd),
[notes/threads](#notes-threads)\



[SIMD]: #notes-simd
[MIMD]: #notes-mimd
[data parallelism]: #notes-data-parallelism
[decoupling]: #notes-decoupling
[speculative execution]: #notes-speculative-execution
[threads]: #notes-threads
[flynn:ieeeproc:1966]: #papers-flynn-ieeeproc-1966
# Partial Order Reduction {#notes-partial-order-reduction}


[[Google Scholar]](https://scholar.google.com/scholar?q=Partial%20Order%20Reduction)
[[Wikipedia]](https://en.wikipedia.org/wiki/Partial_order_reduction)

Notes: 
[model checking](#model checking)\
Referenced by: 
[papers/clarke:cacm:2009](#papers-clarke-cacm-2009),
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[papers/mcmillan:ecs:2003](#papers-mcmillan-ecs-2003)\



[model checking]: #notes-model-checking
# Paxos distributed consensus algorithm {#notes-paxos}


[[Google Scholar]](https://scholar.google.com/scholar?q=Paxos%20distributed%20consensus%20algorithm)
[[Wikipedia]](https://en.wikipedia.org/wiki/Paxos_(computer_science))

Referenced by: 
[papers/corbett:tocs:2013](#papers-corbett-tocs-2013)\





# PDP11 architecture {#notes-pdp11-architecture}


[[Google Scholar]](https://scholar.google.com/scholar?q=PDP11%20architecture)
[[Wikipedia]](https://en.wikipedia.org/wiki/PDP-11)

Is a kind of: 
[instruction set architecture](#instruction set architecture)\
Referenced by: 
[papers/pdp11:book:1973](#papers-pdp11-book-1973),
[notes/instruction-set-architecture](#notes-instruction-set-architecture)\



# Permission accounting {#notes-permission-accounting}


[[Google Scholar]](https://scholar.google.com/scholar?q=Permission%20accounting)

Notes: 
[fractional permissions](#fractional permissions),
[separation logic](#separation logic),
[permission logic](#permission logic)\
Papers: 
[bornat:popl:2005](#bornat-popl-2005),
[heule:ftfjp:2011](#heule-ftfjp-2011)\
Referenced by: 
[papers/astrauskas:oopsla:2019](#papers-astrauskas-oopsla-2019),
[papers/bornat:popl:2005](#papers-bornat-popl-2005),
[papers/heule:ftfjp:2011](#papers-heule-ftfjp-2011),
[papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011),
[papers/jacobs:vstte:2010](#papers-jacobs-vstte-2010),
[papers/leino:fosad:2007](#papers-leino-fosad-2007),
[notes/fractional-permissions](#notes-fractional-permissions)\


A generalization of the notion of [fractional permissions]
for tracking the ownership of shared resources and, in
particular, to track when a resource goes back to having a single
owner.

Includes fractional permissions and permission counting.

Adapted for [separation logic] by [bornat:popl:2005].
Later, [heule:ftfjp:2011] developed a variation that avoids the sometimes ad hoc
choice of what fractions to use.



[fractional permissions]: #notes-fractional-permissions
[separation logic]: #notes-separation-logic
[permission logic]: #notes-permission-logic
[bornat:popl:2005]: #papers-bornat-popl-2005
[heule:ftfjp:2011]: #papers-heule-ftfjp-2011
# Permission logic {#notes-permission-logic}


[[Google Scholar]](https://scholar.google.com/scholar?q=Permission%20logic)

Examples: 
[Chalice verifier](#Chalice verifier),
[Viper verifier](#Viper verifier)\
Notes: 
[separation logic](#separation logic),
[linear logic](#linear logic),
[implicit dynamic frames](#implicit dynamic frames)\
Referenced by: 
[papers/astrauskas:oopsla:2019](#papers-astrauskas-oopsla-2019),
[papers/berdine:aplas:2005](#papers-berdine-aplas-2005),
[papers/berdine:fmco:2005](#papers-berdine-fmco-2005),
[papers/blom:ijsttt:2015](#papers-blom-ijsttt-2015),
[papers/bornat:popl:2005](#papers-bornat-popl-2005),
[papers/brookes:tcs:2006](#papers-brookes-tcs-2006),
[papers/calcagno:popl:2009](#papers-calcagno-popl-2009),
[papers/deline:pldi:2001](#papers-deline-pldi-2001),
[papers/dinsdale-young:popl:2013](#papers-dinsdale-young-popl-2013),
[papers/distefano:tacas:2006](#papers-distefano-tacas-2006),
[papers/heule:ftfjp:2011](#papers-heule-ftfjp-2011),
[papers/heule:vmcai:2013](#papers-heule-vmcai-2013),
[papers/hobor:popl:2013](#papers-hobor-popl-2013),
[papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011),
[papers/jacobs:vstte:2010](#papers-jacobs-vstte-2010),
[papers/jung:popl:2017](#papers-jung-popl-2017),
[papers/kassios:fm:2006](#papers-kassios-fm-2006),
[papers/krishnaswami:tldi:2010](#papers-krishnaswami-tldi-2010),
[papers/leino:fosad:2007](#papers-leino-fosad-2007),
[papers/muller:vmcai:2016](#papers-muller-vmcai-2016),
[papers/nanevski:icfp:2008](#papers-nanevski-icfp-2008),
[papers/nanevski:oopsla:2019](#papers-nanevski-oopsla-2019),
[papers/ohearn:cacm:2019](#papers-ohearn-cacm-2019),
[papers/ohearn:tcs:2007](#papers-ohearn-tcs-2007),
[papers/parkinson:popl:2005](#papers-parkinson-popl-2005),
[papers/penninckx:nfm:2012](#papers-penninckx-nfm-2012),
[papers/philippaerts:scp:2014](#papers-philippaerts-scp-2014),
[papers/reynolds:lics:2002](#papers-reynolds-lics-2002),
[papers/schwerhoff:ecoop:2015](#papers-schwerhoff-ecoop-2015),
[papers/smans:ecoop:2009](#papers-smans-ecoop-2009),
[papers/smans:fmood:2010](#papers-smans-fmood-2010),
[papers/smith:esop:2000](#papers-smith-esop-2000),
[papers/vogels:fmoods:2011](#papers-vogels-fmoods-2011),
[papers/walker:tic:2001](#papers-walker-tic-2001),
[notes/boogie-verifier](#notes-boogie-verifier),
[notes/chalice-verifier](#notes-chalice-verifier),
[notes/fractional-permissions](#notes-fractional-permissions),
[notes/implicit-dynamic-frames](#notes-implicit-dynamic-frames),
[notes/magic-wand](#notes-magic-wand),
[notes/permission-accounting](#notes-permission-accounting),
[notes/prusti-verifier](#notes-prusti-verifier),
[notes/separation-logic](#notes-separation-logic),
[notes/viper-verifier](#notes-viper-verifier)\


Permission logic is a generalization of [separation logic].
All permission logics have

- a notion of resource
- resources follow rules of [linear logic] wrt replication / consumption

Permission logics include
- many variants of [separation logic]
- [implicit dynamic frames]

Systems based on permission logic:

- [Chalice verifier]
- [Viper verifier]



[separation logic]: #notes-separation-logic
[linear logic]: #notes-linear-logic
[implicit dynamic frames]: #notes-implicit-dynamic-frames
# PIN binary instrumentation tool {#notes-pin-tool}

![PIN binary instrumentation tool](https://software.intel.com/content/dam/develop/external/us/en/images/cutout-256675.jpg){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=PIN%20binary%20instrumentation%20tool)
[[Website]](https://software.intel.com/content/www/us/en/develop/articles/pin-a-dynamic-binary-instrumentation-tool.html)
[[Wikipedia]](https://en.wikipedia.org/wiki/Pin_(computer_program))

Referenced by: 
[papers/avgerinos:icse:2014](#papers-avgerinos-icse-2014)\


todo



# Pipeline parallelism {#notes-pipeline-parallelism}


[[Google Scholar]](https://scholar.google.com/scholar?q=Pipeline%20parallelism)
[[Wikipedia]](https://en.wikipedia.org/wiki/Pipeline_(software))

Notes: 
[parallelism](#parallelism)\
Referenced by: 
[papers/bird:sc:1993](#papers-bird-sc-1993),
[papers/bridges:micro:2007](#papers-bridges-micro-2007),
[papers/dai:pldi:2005](#papers-dai-pldi-2005),
[papers/du:sc:2003](#papers-du-sc-2003),
[papers/palacharla:micro:1995](#papers-palacharla-micro-1995),
[papers/reid:cases:2008](#papers-reid-cases-2008),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[papers/smith:tocs:1984](#papers-smith-tocs-1984),
[papers/thies:micro:2007](#papers-thies-micro-2007),
[papers/wolf:codes:2004](#papers-wolf-codes-2004),
[notes/stream-processing](#notes-stream-processing)\



[parallelism]: #notes-parallelism
# Power-PC architecture {#notes-powerpc-architecture}


[[Google Scholar]](https://scholar.google.com/scholar?q=Power-PC%20architecture)
[[Wikipedia]](https://en.wikipedia.org/wiki/PowerPC)

Notes: 
[instruction set architecture](#instruction set architecture)\
Referenced by: 
[papers/gray:micro:2015](#papers-gray-micro-2015),
[papers/myreen:tphols:2009](#papers-myreen-tphols-2009),
[papers/sarkar:pldi:2011](#papers-sarkar-pldi-2011),
[notes/instruction-set-architecture](#notes-instruction-set-architecture),
[notes/sail-language](#notes-sail-language)\


Power-PC is an [instruction set architecture].



[instruction set architecture]: #notes-instruction-set-architecture
# Proof carrying code {#notes-proof-carrying-code}


[[Google Scholar]](https://scholar.google.com/scholar?q=Proof%20carrying%20code)
[[Wikipedia]](https://en.wikipedia.org/wiki/Proof-carrying_code)

Papers: 
[necula:popl:1997](#necula-popl-1997)\
Referenced by: 
[papers/necula:popl:1997](#papers-necula-popl-1997),
[notes/typed-assembly-language](#notes-typed-assembly-language)\


Proof carrying code is code (typically machine code, bytecode, etc.)
accompanied by a proof that the code satisfies some
property such as memory safety, termination, etc.



[necula:popl:1997]: #papers-necula-popl-1997
# Property-based testing {#notes-property-based-testing}


[[Google Scholar]](https://scholar.google.com/scholar?q=Property-based%20testing)
[[Wikipedia]](https://en.wikipedia.org/wiki/QuickCheck)

Notes: 
[unit tests](#unit tests),
[fuzz-testing](#fuzz-testing)\
Papers: 
[claessen:icfp:2000](#claessen-icfp-2000)\
Referenced by: 
[papers/claessen:icfp:2000](#papers-claessen-icfp-2000),
[papers/goodman:ndss:2018](#papers-goodman-ndss-2018),
[papers/maciver:ecoop:2020](#papers-maciver-ecoop-2020),
[papers/tillmann:fse:2005](#papers-tillmann-fse-2005),
[notes/unit-tests](#notes-unit-tests)\





[unit tests]: #notes-unit-tests
[fuzz-testing]: #notes-fuzz-testing
[claessen:icfp:2000]: #papers-claessen-icfp-2000
# Prusti verifier {#notes-prusti-verifier}

![Prusti verifier](https://www.pm.inf.ethz.ch/research/prusti/_jcr_content/rightpar/contextinfo/fullwidthimage/image.imageformat.context.683904319.png){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=Prusti%20verifier)
[[Website]](https://www.pm.inf.ethz.ch/research/prusti.html)

Notes: 
[intermediate verification language](#intermediate verification language),
[permission logic](#permission logic),
[Rust language](#Rust language),
[Viper verifier](#Viper verifier),
[Prusti verifier](#Prusti verifier),
[magic wand](#magic wand)\
Papers: 
[schwerhoff:ecoop:2015](#schwerhoff-ecoop-2015),
[astrauskas:oopsla:2019](#astrauskas-oopsla-2019)\
Referenced by: 
[papers/blom:ijsttt:2015](#papers-blom-ijsttt-2015),
[papers/schwerhoff:ecoop:2015](#papers-schwerhoff-ecoop-2015),
[notes/ownership-types](#notes-ownership-types),
[notes/prusti-verifier](#notes-prusti-verifier),
[notes/rust-language](#notes-rust-language),
[notes/viper-verifier](#notes-viper-verifier)\


Prusti is a verifier for the [Rust language]
based on 
[permission logic] and using the [Viper verifier] as
an [intermediate verification language].
Prusti was developed by ETH Zurich.

An unusual part of its design is that it makes use of
[magic wand]s to model reference borrowing.



[intermediate verification language]: #notes-intermediate-verification-language
[permission logic]: #notes-permission-logic
[Rust language]: #notes-rust-language
[Viper verifier]: #notes-viper-verifier
[Prusti verifier]: #notes-prusti-verifier
[magic wand]: #notes-magic-wand
[schwerhoff:ecoop:2015]: #papers-schwerhoff-ecoop-2015
[astrauskas:oopsla:2019]: #papers-astrauskas-oopsla-2019
# PVS theorem prover {#notes-pvs-theorem-prover}


[[Google Scholar]](https://scholar.google.com/scholar?q=PVS%20theorem%20prover)
[[Wikipedia]](https://en.wikipedia.org/wiki/Prototype_Verification_System)

Is a kind of: 
[interactive theorem prover](#interactive theorem prover)\
Referenced by: 
[papers/beyer:ijsttt:2006](#papers-beyer-ijsttt-2006),
[papers/tahat:fmcad:2019](#papers-tahat-fmcad-2019)\



# Reachability {#notes-reachability}


[[Google Scholar]](https://scholar.google.com/scholar?q=Reachability)

Referenced by: 
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[notes/bounded-model-checking](#notes-bounded-model-checking)\



# Remote procedure call (RPC) {#notes-remote-procedure-call}


[[Google Scholar]](https://scholar.google.com/scholar?q=Remote%20procedure%20call%20%28RPC%29)
[[Wikipedia]](https://en.wikipedia.org/wiki/Remote_procedure_call)

Papers: 
[birrell:tocs:1984](#birrell-tocs-1984),
[ananda:osr:1992](#ananda-osr-1992)\
Referenced by: 
[papers/ananda:osr:1992](#papers-ananda-osr-1992),
[papers/birrell:tocs:1984](#papers-birrell-tocs-1984),
[papers/reid:cases:2008](#papers-reid-cases-2008),
[papers/reid:phd:2019](#papers-reid-phd-2019)\



[birrell:tocs:1984]: #papers-birrell-tocs-1984
[ananda:osr:1992]: #papers-ananda-osr-1992
# Requirements specification {#notes-requirements-specification}


[[Google Scholar]](https://scholar.google.com/scholar?q=Requirements%20specification)

Referenced by: 
[papers/frias:icse:2005](#papers-frias-icse-2005),
[papers/fuxman:isre:2001](#papers-fuxman-isre-2001),
[papers/jackson:tosem:2002](#papers-jackson-tosem-2002),
[papers/reid:oopsla:2017](#papers-reid-oopsla-2017),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[notes/alloy-verifier](#notes-alloy-verifier)\



# Rewrite rules {#notes-rewrite-rules}


[[Google Scholar]](https://scholar.google.com/scholar?q=Rewrite%20rules)
[[Wikipedia]](https://en.wikipedia.org/wiki/Rewriting)

Referenced by: 
[papers/jones:microsoft:2001](#papers-jones-microsoft-2001)\



# RISC architecture {#notes-risc-architecture}


[[Google Scholar]](https://scholar.google.com/scholar?q=RISC%20architecture)
[[Wikipedia]](https://en.wikipedia.org/wiki/Reduced_instruction_set_computer)

Is a kind of: 
[instruction set architecture](#instruction set architecture)\
Notes: 
[microarchitecture](#microarchitecture)\
Papers: 
[patterson:cacm:1985](#patterson-cacm-1985),
[patterson:sigarch:1980](#patterson-sigarch-1980)\
Referenced by: 
[papers/hennessy:micro:1982](#papers-hennessy-micro-1982),
[papers/patterson:cacm:1985](#papers-patterson-cacm-1985),
[papers/patterson:sigarch:1980](#papers-patterson-sigarch-1980),
[papers/seal:book:2000](#papers-seal-book-2000)\



[microarchitecture]: #notes-microarchitecture
[patterson:cacm:1985]: #papers-patterson-cacm-1985
[patterson:sigarch:1980]: #papers-patterson-sigarch-1980
# RISC-V architecture {#notes-riscv-architecture}

![RISC-V architecture](https://content.riscv.org/wp-content/uploads/2018/09/riscv-logo.png){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=RISC-V%20architecture)
[[Website]](https://riscv.org/)
[[Wikipedia]](https://en.wikipedia.org/wiki/RISC-V)

Is a kind of: 
[instruction set architecture](#instruction set architecture)\
Referenced by: 
[papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019),
[papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019),
[papers/lockhart:ispass:2015](#papers-lockhart-ispass-2015),
[papers/nelson:sosp:2019](#papers-nelson-sosp-2019),
[notes/instruction-set-architecture](#notes-instruction-set-architecture)\


RISC-V is an [instruction set architecture].

> RISC-V is a free and open ISA enabling a new era of processor innovation
> through open standard collaboration. Born in academia and research, RISC-V
> ISA delivers a new level of free, extensible software and hardware freedom on
> architecture, paving the way for the next 50 years of computing design and
> innovation.
> <br>--- [RISCV.org](https://riscv.org/)



# Rosette solver {#notes-rosette-solver}

![Rosette solver](https://emina.github.io/rosette/images/rosette-gray.png){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=Rosette%20solver)
[[Website]](https://emina.github.io/rosette/)

Notes: 
[symbolic evaluation](#symbolic evaluation)\
Papers: 
[torlak:onward:2013](#torlak-onward-2013),
[torlak:pldi:2014](#torlak-pldi-2014),
[nelson:sosp:2019](#nelson-sosp-2019),
[weitz:icfp:2017](#weitz-icfp-2017)\
Referenced by: 
[papers/bornholt:oopsla:2018](#papers-bornholt-oopsla-2018),
[papers/nelson:sosp:2019](#papers-nelson-sosp-2019),
[papers/torlak:onward:2013](#papers-torlak-onward-2013),
[papers/torlak:pldi:2014](#papers-torlak-pldi-2014),
[papers/weitz:icfp:2017](#papers-weitz-icfp-2017),
[papers/zorn:iscawddd:2017](#papers-zorn-iscawddd-2017)\


Rosette is a solver-aided programming language that extends Racket with
language constructs for program synthesis, verification, and more.



[symbolic evaluation]: #notes-symbolic-evaluation
[torlak:onward:2013]: #papers-torlak-onward-2013
[torlak:pldi:2014]: #papers-torlak-pldi-2014
[nelson:sosp:2019]: #papers-nelson-sosp-2019
[weitz:icfp:2017]: #papers-weitz-icfp-2017
# RTL {#notes-rtl}


[[Google Scholar]](https://scholar.google.com/scholar?q=RTL)
[[Wikipedia]](https://en.wikipedia.org/wiki/Register-transfer_level)

Papers: 
[systemverilog:ieee:2013](#systemverilog-ieee-2013)\
Referenced by: 
[papers/reid:phd:2019](#papers-reid-phd-2019),
[papers/su:computer:1974](#papers-su-computer-1974),
[papers/systemverilog:ieee:2013](#papers-systemverilog-ieee-2013),
[notes/symbolic-trajectory-evaluation](#notes-symbolic-trajectory-evaluation)\



[systemverilog:ieee:2013]: #papers-systemverilog-ieee-2013
# Rust language {#notes-rust-language}

![Rust language](https://www.rust-lang.org/static/images/rust-logo-blk.svg){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=Rust%20language)
[[Wikipedia]](https://en.wikipedia.org/wiki/Rust_(programming_language))

Notes: 
[ownership types](#ownership types),
[Prusti verifier](#Prusti verifier),
[SMACK verifier](#SMACK verifier)\
Papers: 
[astrauskas:oopsla:2019](#astrauskas-oopsla-2019),
[baranowski:atva:2018](#baranowski-atva-2018),
[jung:popl:2017](#jung-popl-2017),
[jung:popl:2020](#jung-popl-2020),
[levy:apsys:2017](#levy-apsys-2017),
[toman:ase:2015](#toman-ase-2015)\
Referenced by: 
[papers/astrauskas:oopsla:2019](#papers-astrauskas-oopsla-2019),
[papers/balasubramanium:hotos:2017](#papers-balasubramanium-hotos-2017),
[papers/baranowski:atva:2018](#papers-baranowski-atva-2018),
[papers/jung:popl:2017](#papers-jung-popl-2017),
[papers/jung:popl:2020](#papers-jung-popl-2020),
[papers/klabnik:book:2018](#papers-klabnik-book-2018),
[papers/levy:apsys:2017](#papers-levy-apsys-2017),
[papers/levy:plos:2015](#papers-levy-plos-2015),
[papers/levy:sosp:2017](#papers-levy-sosp-2017),
[papers/lindner:indin:2018](#papers-lindner-indin-2018),
[papers/lindner:indin:2019](#papers-lindner-indin-2019),
[papers/matsushita:esop:2020](#papers-matsushita-esop-2020),
[papers/narayanan:hotos:2019](#papers-narayanan-hotos-2019),
[papers/toman:ase:2015](#papers-toman-ase-2015),
[papers/ullrich:msc:2016](#papers-ullrich-msc-2016),
[papers/wang:tase:2018](#papers-wang-tase-2018),
[papers/weiss:arxiv:2018](#papers-weiss-arxiv-2018),
[notes/magic-wand](#notes-magic-wand),
[notes/mir-interpreter](#notes-mir-interpreter),
[notes/mir](#notes-mir),
[notes/ownership-types](#notes-ownership-types),
[notes/prusti-verifier](#notes-prusti-verifier),
[notes/rust-unsafe-code](#notes-rust-unsafe-code),
[notes/viper-verifier](#notes-viper-verifier)\


Rust is a systems programming language that differs from C
in that it aims for high performance without sacrificing memory safety.
It achieves this using an unusual [ownership type system][ownership types] that
largely eliminates aliasing problems and simplifies the creation
of concurrent programs.

Verifiers for Rust include
[Prusti verifier],
[SMACK verifier]



[ownership types]: #notes-ownership-types
[Prusti verifier]: #notes-prusti-verifier
[SMACK verifier]: #notes-smack-verifier
[astrauskas:oopsla:2019]: #papers-astrauskas-oopsla-2019
[baranowski:atva:2018]: #papers-baranowski-atva-2018
[jung:popl:2017]: #papers-jung-popl-2017
[jung:popl:2020]: #papers-jung-popl-2020
[levy:apsys:2017]: #papers-levy-apsys-2017
[toman:ase:2015]: #papers-toman-ase-2015
# Rust unsafe code {#notes-rust-unsafe-code}


[[Google Scholar]](https://scholar.google.com/scholar?q=Rust%20unsafe%20code)
[[Website]](https://doc.rust-lang.org/nomicon/)

Notes: 
[Rust language](#Rust language)\
Papers: 
[jung:popl:2020](#jung-popl-2020)\
Referenced by: 
[papers/jung:popl:2017](#papers-jung-popl-2017),
[papers/jung:popl:2020](#papers-jung-popl-2020),
[papers/toman:ase:2015](#papers-toman-ase-2015)\


todo:

<https://doc.rust-lang.org/nomicon/>



[Rust language]: #notes-rust-language
[jung:popl:2020]: #papers-jung-popl-2020
# S2E verifier {#notes-s2e-verifier}


[[Google Scholar]](https://scholar.google.com/scholar?q=S2E%20verifier)

Notes: 
[symbolic execution](#symbolic execution),
[KLEE verifier](#KLEE verifier)\
Papers: 
[chipounov:hotdep:2009](#chipounov-hotdep-2009),
[chipounov:asplos:2011](#chipounov-asplos-2011),
[chipounov:tcs:2012](#chipounov-tcs-2012)\
Referenced by: 
[papers/chipounov:asplos:2011](#papers-chipounov-asplos-2011),
[papers/chipounov:hotdep:2009](#papers-chipounov-hotdep-2009),
[papers/chipounov:tcs:2012](#papers-chipounov-tcs-2012)\


The S2E verifier is an implementation of the idea of "selective
symbolic execution" described in [chipounov:hotdep:2009].

The tool can analyze application code, complex GUI
libraries, kernel code, device drivers, and even hardware devices.
This allows it to analyze Windows kernel code.
It does this by alternating between concrete execution (using QEMU) and
[symbolic execution] (using the [KLEE verifier]).



[symbolic execution]: #notes-symbolic-execution
[KLEE verifier]: #notes-klee-verifier
[chipounov:hotdep:2009]: #papers-chipounov-hotdep-2009
[chipounov:asplos:2011]: #papers-chipounov-asplos-2011
[chipounov:tcs:2012]: #papers-chipounov-tcs-2012
# SAGE verifier {#notes-sage-verifier}


[[Google Scholar]](https://scholar.google.com/scholar?q=SAGE%20verifier)

Notes: 
[symbolic execution](#symbolic execution),
[fuzz testing](#fuzz testing)\
Referenced by: 
[papers/godefroid:cacm:2020](#papers-godefroid-cacm-2020),
[notes/symbolic-execution](#notes-symbolic-execution)\


SAGE is a [symbolic execution] tool used for whitebox [fuzz testing]
developed at Microsoft.
It is based on the "concolic" or "offline" variant of
"dynamic symbolic execution" and operates at the binary level
by symbolically executing x86 instructions.

SAGE schedules paths to optimize code coverage based on the likelihood of
a path to discover new, unexecuted instructions.



[symbolic execution]: #notes-symbolic-execution
[fuzz testing]: #notes-fuzz-testing
# Sail ISA specification language {#notes-sail-language}


[[Google Scholar]](https://scholar.google.com/scholar?q=Sail%20ISA%20specification%20language)
[[Website]](https://www.cl.cam.ac.uk/~pes20/sail/)

Notes: 
[ISA specification](#ISA specification),
[ASL](#ASL),
[Arm architecture](#Arm architecture),
[CHERI architecture](#CHERI architecture),
[PowerPC architecture](#PowerPC architecture)\
Referenced by: 
[papers/armstrong:arw:2018](#papers-armstrong-arw-2018),
[papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019),
[papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019),
[notes/arm-architecture](#notes-arm-architecture),
[notes/dependent-type](#notes-dependent-type),
[notes/isa-specification](#notes-isa-specification)\


todo:



[ISA specification]: #notes-isa-specification
[ASL]: #notes-asl
[Arm architecture]: #notes-arm-architecture
[CHERI architecture]: #notes-cheri-architecture
[PowerPC architecture]: #notes-powerpc-architecture
# SAT solver {#notes-sat-solver}


[[Google Scholar]](https://scholar.google.com/scholar?q=SAT%20solver)
[[Wikipedia]](https://en.wikipedia.org/wiki/Boolean_satisfiability_problem)

Notes: 
[SMT solver](#SMT solver),
[model checking](#model checking)\
Papers: 
[malik:cacm:2009](#malik-cacm-2009)\
Referenced by: 
[papers/brummayer:sat:2010](#papers-brummayer-sat-2010),
[papers/demoura:cacm:2011](#papers-demoura-cacm-2011),
[papers/krishnamurthi:fm:2019](#papers-krishnamurthi-fm-2019),
[papers/malik:cacm:2009](#papers-malik-cacm-2009),
[notes/smt-solver](#notes-smt-solver)\


SAT solvers are tools that solve the "Boolean satisfiability problem"
([malik:cacm:2009]): finding a set of boolean variable values such that
a boolean formula is true.

SAT is used to reason about hardware, to encode other problems (e.g., graph
problems, etc.), in [model checking], in [SMT solver]s and in many other
applications.

todo:

- CACM overview [malik:cacm:2009]
- [SAT competition website]
- [SMT solver]
- DRAT
- Model counting

[SAT competition website]: http://www.satcompetition.org



[SMT solver]: #notes-smt-solver
[model checking]: #notes-model-checking
[malik:cacm:2009]: #papers-malik-cacm-2009
# Software Defined Radio (SDR) {#notes-sdr}


[[Google Scholar]](https://scholar.google.com/scholar?q=Software%20Defined%20Radio%20%28SDR%29)
[[Wikipedia]](https://en.wikipedia.org/wiki/Software-defined_radio)

Referenced by: 
[papers/lin:sdr:2006](#papers-lin-sdr-2006),
[papers/lin:sips:2006](#papers-lin-sips-2006),
[papers/woh:micro:2008](#papers-woh-micro-2008)\



# SeaHorn verifier {#notes-seahorn-verifier}

![SeaHorn verifier](https://seahorn.github.io/images/seahorn-logo.png){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=SeaHorn%20verifier)
[[Website]](https://seahorn.github.io)

Notes: 
[LLVM compiler](#LLVM compiler),
[abstract interpretation](#abstract interpretation)\
Papers: 
[gurfinkel:cav:2015](#gurfinkel-cav-2015)\
Referenced by: 
[papers/gurfinkel:cav:2015](#papers-gurfinkel-cav-2015),
[notes/extended-static-checking](#notes-extended-static-checking),
[notes/sv-competition](#notes-sv-competition)\


SeaHorn is a framework and tool for verification of safety properties in C programs.
It uses the [LLVM compiler] as a frontend and verification is based on [abstract
interpretation], constrained Horn clauses and PDR/IC3 based model checking.



[LLVM compiler]: #notes-llvm-compiler
[abstract interpretation]: #notes-abstract-interpretation
[gurfinkel:cav:2015]: #papers-gurfinkel-cav-2015
# Search based test generation {#notes-search-based-test-generation}


[[Google Scholar]](https://scholar.google.com/scholar?q=Search%20based%20test%20generation)

Notes: 
[fuzz testing](#fuzz testing),
[symbolic execution](#symbolic execution)\
Referenced by: 
[papers/braione:icse:2018](#papers-braione-icse-2018),
[notes/test-generation](#notes-test-generation),
[notes/unit-tests](#notes-unit-tests)\


Generation of program tests using search techniques.

Contrast with [fuzz testing] and [symbolic execution] (although the
different communities seem to have started talking so expect
hybrid approaches).

One common approach uses genetic algorithms and related techniques
and requires definition of a fitness function to guide the search.



[fuzz testing]: #notes-fuzz-testing
[symbolic execution]: #notes-symbolic-execution
# Security {#notes-security}


[[Google Scholar]](https://scholar.google.com/scholar?q=Security)

Notes: 
[side channel](#side channel)\
Referenced by: 
[papers/baumann:hotos:2017](#papers-baumann-hotos-2017),
[papers/ge:jce:2016](#papers-ge-jce-2016),
[papers/kocher:crypto:1999](#papers-kocher-crypto-1999),
[papers/lowe:csfw:2015](#papers-lowe-csfw-2015),
[papers/mcilroy:arxiv:2019](#papers-mcilroy-arxiv-2019),
[notes/differential-power-analysis](#notes-differential-power-analysis),
[notes/side-channel](#notes-side-channel)\



[side channel]: #notes-side-channel
# Self composition {#notes-self-composition}


[[Google Scholar]](https://scholar.google.com/scholar?q=Self%20composition)

Notes: 
[information flow](#information flow)\
Referenced by: 
[papers/almeida:security:2016](#papers-almeida-security-2016),
[papers/barthe:csfw:2004](#papers-barthe-csfw-2004),
[papers/barthe:iacr:2007](#papers-barthe-iacr-2007),
[papers/barthe:mscs:2011](#papers-barthe-mscs-2011),
[notes/information-flow](#notes-information-flow)\


todo

A technique for reasoning about [information flow]
often used in the cryptography verification community.



[information flow]: #notes-information-flow
# Separation logic {#notes-separation-logic}


[[Google Scholar]](https://scholar.google.com/scholar?q=Separation%20logic)
[[Wikipedia]](https://en.wikipedia.org/wiki/Separation_logic)

Is a kind of: 
[permission logic](#permission logic)\
Notes: 
[alias analysis](#alias analysis),
[shape analysis](#shape analysis)\
Referenced by: 
[papers/berdine:aplas:2005](#papers-berdine-aplas-2005),
[papers/berdine:fmco:2005](#papers-berdine-fmco-2005),
[papers/bornat:popl:2005](#papers-bornat-popl-2005),
[papers/distefano:tacas:2006](#papers-distefano-tacas-2006),
[papers/hatcliff:compsurv:2012](#papers-hatcliff-compsurv-2012),
[papers/hobor:popl:2013](#papers-hobor-popl-2013),
[papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011),
[papers/jacobs:vstte:2010](#papers-jacobs-vstte-2010),
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[papers/krishnaswami:tldi:2010](#papers-krishnaswami-tldi-2010),
[papers/nanevski:oopsla:2019](#papers-nanevski-oopsla-2019),
[papers/ohearn:cacm:2019](#papers-ohearn-cacm-2019),
[papers/ohearn:tcs:2007](#papers-ohearn-tcs-2007),
[papers/parkinson:popl:2005](#papers-parkinson-popl-2005),
[papers/penninckx:nfm:2012](#papers-penninckx-nfm-2012),
[papers/philippaerts:scp:2014](#papers-philippaerts-scp-2014),
[papers/reynolds:lics:2002](#papers-reynolds-lics-2002),
[papers/schwerhoff:ecoop:2015](#papers-schwerhoff-ecoop-2015),
[papers/smans:ecoop:2009](#papers-smans-ecoop-2009),
[papers/tuerk:vstte:2010](#papers-tuerk-vstte-2010),
[papers/vogels:fmoods:2011](#papers-vogels-fmoods-2011),
[notes/biabduction](#notes-biabduction),
[notes/concurrent-separation-logic](#notes-concurrent-separation-logic),
[notes/fractional-permissions](#notes-fractional-permissions),
[notes/frame-rule](#notes-frame-rule),
[notes/implicit-dynamic-frames](#notes-implicit-dynamic-frames),
[notes/magic-wand](#notes-magic-wand),
[notes/permission-accounting](#notes-permission-accounting),
[notes/permission-logic](#notes-permission-logic),
[notes/smallfoot-verifier](#notes-smallfoot-verifier),
[notes/symbolic-execution](#notes-symbolic-execution),
[notes/verifast-verifier](#notes-verifast-verifier)\


Separation logic is an extension of [Hoare
logic](https://en.wikipedia.org/wiki/Hoare_logic)
that adds the
ability to reason about heap-based data structures and,
in particular, about aliasing.
It does this using ideas from linear logic to model
resources that cannot be duplicated.

Variations on the theme of separation logic have been developed
and are collectively referred to as [permission logic].



[alias analysis]: #notes-alias-analysis
[shape analysis]: #notes-shape-analysis
# Shape analysis {#notes-shape-analysis}


[[Google Scholar]](https://scholar.google.com/scholar?q=Shape%20analysis)
[[Wikipedia]](https://en.wikipedia.org/wiki/Shape_analysis_(program_analysis))

Referenced by: 
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[notes/separation-logic](#notes-separation-logic)\



# Side Channel {#notes-side-channel}


[[Google Scholar]](https://scholar.google.com/scholar?q=Side%20Channel)
[[Wikipedia]](https://en.wikipedia.org/wiki/Side-channel_attack)

Notes: 
[security](#security)\
Papers: 
[ge:jce:2016](#ge-jce-2016)\
Referenced by: 
[papers/baumann:hotos:2017](#papers-baumann-hotos-2017),
[papers/ge:jce:2016](#papers-ge-jce-2016),
[papers/kim:isca:2014](#papers-kim-isca-2014),
[papers/kocher:arxiv:2018](#papers-kocher-arxiv-2018),
[papers/kocher:crypto:1999](#papers-kocher-crypto-1999),
[papers/lipp:arxiv:2018](#papers-lipp-arxiv-2018),
[papers/mcilroy:arxiv:2019](#papers-mcilroy-arxiv-2019),
[papers/tang:sec:2017](#papers-tang-sec-2017),
[notes/differential-power-analysis](#notes-differential-power-analysis),
[notes/security](#notes-security)\



[security]: #notes-security
[ge:jce:2016]: #papers-ge-jce-2016
# Single Instruction Multiple Data (SIMD) {#notes-simd}


[[Google Scholar]](https://scholar.google.com/scholar?q=Single%20Instruction%20Multiple%20Data%20%28SIMD%29)

Notes: 
[parallelism](#parallelism),
[data parallelism](#data parallelism),
[SIMD](#SIMD)\
Papers: 
[flynn:ieeeproc:1966](#flynn-ieeeproc-1966)\
Referenced by: 
[papers/boettcher:date:2014](#papers-boettcher-date-2014),
[papers/flynn:ieeeproc:1966](#papers-flynn-ieeeproc-1966),
[papers/kozyrakis:phd:2002](#papers-kozyrakis-phd-2002),
[papers/lee:micro:1996](#papers-lee-micro-1996),
[papers/lin:sdr:2006](#papers-lin-sdr-2006),
[papers/lin:sips:2006](#papers-lin-sips-2006),
[papers/reid:cases:2008](#papers-reid-cases-2008),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[papers/stephens:micro:2017](#papers-stephens-micro-2017),
[papers/tremblay:micro:1996](#papers-tremblay-micro-1996),
[papers/woh:micro:2008](#papers-woh-micro-2008),
[notes/data-parallelism](#notes-data-parallelism),
[notes/mimd](#notes-mimd),
[notes/parallelism](#notes-parallelism),
[notes/simd](#notes-simd),
[notes/vector-architecture](#notes-vector-architecture)\



[parallelism]: #notes-parallelism
[data parallelism]: #notes-data-parallelism
[SIMD]: #notes-simd
[flynn:ieeeproc:1966]: #papers-flynn-ieeeproc-1966
# Specification language for encoding and decoding (SLED) {#notes-sled}


[[Google Scholar]](https://scholar.google.com/scholar?q=Specification%20language%20for%20encoding%20and%20decoding%20%28SLED%29)

Notes: 
[ISA specification](#ISA specification)\
Referenced by: 
[papers/cifuentes:computer:2000](#papers-cifuentes-computer-2000),
[papers/cifuentes:iwpc:1998](#papers-cifuentes-iwpc-1998),
[papers/dias:popl:2010](#papers-dias-popl-2010),
[papers/fernandez:icse:1997](#papers-fernandez-icse-1997),
[papers/ramsey:lctes:1998](#papers-ramsey-lctes-1998),
[papers/ramsey:toplas:1997](#papers-ramsey-toplas-1997),
[notes/isa-specification](#notes-isa-specification)\




[ISA specification]: #notes-isa-specification
# SMACK verifier {#notes-smack-verifier}

![SMACK verifier](https://github.com/smackers/smack/raw/master/docs/smack-logo.png){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=SMACK%20verifier)
[[Website]](https://github.com/smackers/smack)

Notes: 
[LLVM compiler](#LLVM compiler),
[Boogie verifier](#Boogie verifier),
[intermediate verification language](#intermediate verification language)\
Papers: 
[baranowski:atva:2018](#baranowski-atva-2018),
[rakamaric:cav:2014](#rakamaric-cav-2014)\
Referenced by: 
[papers/almeida:security:2016](#papers-almeida-security-2016),
[papers/baranowski:atva:2018](#papers-baranowski-atva-2018),
[papers/barnett:fmco:2005](#papers-barnett-fmco-2005),
[papers/rakamaric:cav:2014](#papers-rakamaric-cav-2014),
[notes/extended-static-checking](#notes-extended-static-checking),
[notes/rust-language](#notes-rust-language),
[notes/sv-competition](#notes-sv-competition)\


SMACK is verifier based on translating LLVM bitcode to
[Boogie][Boogie verifier] (an [intermediate verification language]).



[LLVM compiler]: #notes-llvm-compiler
[Boogie verifier]: #notes-boogie-verifier
[intermediate verification language]: #notes-intermediate-verification-language
[baranowski:atva:2018]: #papers-baranowski-atva-2018
[rakamaric:cav:2014]: #papers-rakamaric-cav-2014
# Smallfoot verifier {#notes-smallfoot-verifier}

![Smallfoot verifier](http://www0.cs.ucl.ac.uk/staff/p.ohearn/smallfoot/foot.jpg){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=Smallfoot%20verifier)
[[Website]](http://www0.cs.ucl.ac.uk/staff/p.ohearn/smallfoot/)

Notes: 
[separation logic](#separation logic)\
Referenced by: 
[papers/berdine:aplas:2005](#papers-berdine-aplas-2005),
[papers/berdine:fmco:2005](#papers-berdine-fmco-2005),
[papers/calcagno:popl:2009](#papers-calcagno-popl-2009),
[notes/symbolic-execution](#notes-symbolic-execution)\


todo



[separation logic]: #notes-separation-logic
# SMT-LIB format {#notes-smt-lib-format}


[[Google Scholar]](https://scholar.google.com/scholar?q=SMT-LIB%20format)
[[Website]](http://smtlib.cs.uiowa.edu/)

Notes: 
[Z3 solver](#Z3 solver),
[SMT solver](#SMT solver),
[foreign function interface](#foreign function interface)\
Referenced by: 
[papers/leino:informatics:2001](#papers-leino-informatics-2001),
[notes/smt-solver](#notes-smt-solver)\


The SMT-LIB format is the de facto standard for representing SMT
problems and so it allows a high degree of portability between
solvers in how problems are presented to solvers.

Standardization of the format was driven by the [SMT-COMP competition] that
uses the SMT-LIB standard in the competition rules.
This forces all SMT solvers that want to compete to, at least, implement
the SMT-LIB format.

The format is based on S-expressions to simplify machine parsing.
(I suspect that it also avoids endless arguing over syntax!)


## Extensions

The more actively developed solvers tend to implement extensions to
the standard.
Some of these are later added to the standard and new tracks are added to
the SMT-COMP competition.


## Associated SMT standards

todo: summarize standards for output of sat and unsat-core output.
(My experience is that there is much more variability here.)

## SMT-LIB language bindings

todo: summarize state of [FFI][foreign function interface] language bindings
(not as well developed, I think).
And mention the [Z3 solver] Python bindings.


## Alternative SMT interfaces

The main alternative is the [Z3 solver] Python binding/library that many use
for its convenience and to access Z3's other features.

The disadvantage of using alternative SMT interfaces is that they tend to be
less portable so you find yourself locked into a single solver.
The main disadvantage of which is that it makes it hard to try other
solvers to see whether they are faster.

[SMT-COMP competition]: https://smt-comp.github.io/



[Z3 solver]: #notes-z3-solver
[SMT solver]: #notes-smt-solver
[foreign function interface]: #notes-foreign-function-interface
# SMT solver {#notes-smt-solver}


[[Google Scholar]](https://scholar.google.com/scholar?q=SMT%20solver)
[[Wikipedia]](https://en.wikipedia.org/wiki/Satisfiability_modulo_theories)

Notes: 
[Z3 solver](#Z3 solver),
[CVC4 solver](#CVC4 solver),
[SMT-LIB format](#SMT-LIB format),
[SAT solver](#SAT solver)\
Papers: 
[barrett:cade:2000](#barrett-cade-2000),
[brummayer:sat:2010](#brummayer-sat-2010),
[mansur:arxiv:2020](#mansur-arxiv-2020),
[stump:fmsd:2013](#stump-fmsd-2013),
[barrett:mlf:2015](#barrett-mlf-2015),
[baldoni:compsurv:2018](#baldoni-compsurv-2018)\
Referenced by: 
[papers/barrett:cade:2000](#papers-barrett-cade-2000),
[papers/barrett:cav:2011](#papers-barrett-cav-2011),
[papers/barrett:mlf:2015](#papers-barrett-mlf-2015),
[papers/barrett:smtlib:2016](#papers-barrett-smtlib-2016),
[papers/brummayer:sat:2010](#papers-brummayer-sat-2010),
[papers/demoura:cacm:2011](#papers-demoura-cacm-2011),
[papers/demoura:tacas:2008](#papers-demoura-tacas-2008),
[papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011),
[papers/jacobs:vstte:2010](#papers-jacobs-vstte-2010),
[papers/krishnamurthi:fm:2019](#papers-krishnamurthi-fm-2019),
[papers/lal:pldi:2015](#papers-lal-pldi-2015),
[papers/leino:icse:2013](#papers-leino-icse-2013),
[papers/leino:lpair:2010](#papers-leino-lpair-2010),
[papers/leino:sac:2009](#papers-leino-sac-2009),
[papers/malik:cacm:2009](#papers-malik-cacm-2009),
[papers/mansur:arxiv:2020](#papers-mansur-arxiv-2020),
[papers/muller:vmcai:2016](#papers-muller-vmcai-2016),
[papers/niemetz:jsat:2015](#papers-niemetz-jsat-2015),
[papers/stump:fmsd:2013](#papers-stump-fmsd-2013),
[papers/tillmann:fse:2005](#papers-tillmann-fse-2005),
[notes/cvc4-solver](#notes-cvc4-solver),
[notes/sat-solver](#notes-sat-solver),
[notes/smt-lib-format](#notes-smt-lib-format),
[notes/z3-solver](#notes-z3-solver)\


todo:

A good summary of SMT from [baldoni:compsurv:2018] is

> Observe that some problems are more naturally described with languages that are
> more expressive than the one of boolean formulas with logical connectives.
> For this reason, satisfiability modulo theories (SMT) generalize the SAT
> problem with supporting theories to capture formulas involving, for instance,
> linear arithmetic and operations over arrays.
> SMT solvers map the atoms in an SMT formula to fresh boolean variables: a SAT
> decision procedure checks the rewritten formula for satisfiability, and
> a theory solver checks the model generated by the SAT procedure.
> <br> --- [baldoni:compsurv:2018]

[SMT-COMP website] is very significant and probably a good way to find SMT
solvers and to select one or two to consider for a new project.

## List of major solvers

- <https://boolector.github.io>
- <https://cvc4.github.io>
- [Z3 solver]
- <https://yices.csl.sri.com>
- <https://stp.github.io>
- <https://alt-ergo.ocamlpro.com>
- <https://ultimate.informatik.uni-freiburg.de/smtinterpol/>
- <https://monteverdi.informatik.uni-freiburg.de/tomcat/Website/?ui=tool&tool=eliminator>

And Vampire, that is a theorem prover pretending to be an SMT solver?
<https://vprover.github.io>

## Testing of SMT solvers

[brummayer:sat:2010] and [mansur:arxiv:2020] tested SMT solvers and found bugs.
There are several proposals such as [stump:fmsd:2013] and [barrett:mlf:2015]
for a proof format that would allow SMT proofs to be checked.


[SMT-COMP website]: https://smt-comp.github.io/


[Z3 solver]: #notes-z3-solver
[CVC4 solver]: #notes-cvc4-solver
[SMT-LIB format]: #notes-smt-lib-format
[SAT solver]: #notes-sat-solver
[barrett:cade:2000]: #papers-barrett-cade-2000
[brummayer:sat:2010]: #papers-brummayer-sat-2010
[mansur:arxiv:2020]: #papers-mansur-arxiv-2020
[stump:fmsd:2013]: #papers-stump-fmsd-2013
[barrett:mlf:2015]: #papers-barrett-mlf-2015
[baldoni:compsurv:2018]: #papers-baldoni-compsurv-2018
# Spec# project {#notes-spec-sharp-project}


[[Google Scholar]](https://scholar.google.com/scholar?q=Spec%23%20project)
[[Website]](https://www.microsoft.com/en-us/research/project/spec/)
[[Wikipedia]](https://en.wikipedia.org/wiki/Spec_Sharp)

Notes: 
[contract driven development](#contract driven development),
[Boogie verifier](#Boogie verifier),
[modular verification](#modular verification)\
Referenced by: 
[papers/barnett:cacm:2011](#papers-barnett-cacm-2011),
[papers/barnett:cassis:2004](#papers-barnett-cassis-2004),
[papers/barnett:fmco:2005](#papers-barnett-fmco-2005),
[papers/barnett:vstte:2005](#papers-barnett-vstte-2005),
[papers/deline:pldi:2001](#papers-deline-pldi-2001),
[papers/hatcliff:compsurv:2012](#papers-hatcliff-compsurv-2012),
[papers/leino:sac:2009](#papers-leino-sac-2009),
[notes/boogie-verifier](#notes-boogie-verifier)\


Spec# is a formal verification language that supports [contract driven
development] / [modular verification].
Spec# was developed by Microsoft Research.

The [Boogie verifier] was part of the Spec# project.



[contract driven development]: #notes-contract-driven-development
[Boogie verifier]: #notes-boogie-verifier
[modular verification]: #notes-modular-verification
# Speculative execution {#notes-speculative-execution}


[[Google Scholar]](https://scholar.google.com/scholar?q=Speculative%20execution)
[[Wikipedia]](https://en.wikipedia.org/wiki/Speculative_execution)

Notes: 
[microarchitecture](#microarchitecture)\
Referenced by: 
[papers/mcilroy:arxiv:2019](#papers-mcilroy-arxiv-2019),
[notes/parallelism](#notes-parallelism)\



[microarchitecture]: #notes-microarchitecture
# Stream Processing {#notes-stream-processing}


[[Google Scholar]](https://scholar.google.com/scholar?q=Stream%20Processing)

Notes: 
[pipeline parallelism](#pipeline parallelism),
[decoupling](#decoupling)\
Referenced by: 
[papers/gordon:asplos:2002](#papers-gordon-asplos-2002),
[papers/thies:ppopp:2005](#papers-thies-ppopp-2005),
[notes/decoupling](#notes-decoupling)\



[pipeline parallelism]: #notes-pipeline-parallelism
[decoupling]: #notes-decoupling
# Superoptimizer {#notes-superoptimizer}


[[Google Scholar]](https://scholar.google.com/scholar?q=Superoptimizer)
[[Wikipedia]](https://en.wikipedia.org/wiki/Superoptimization)

Papers: 
[massalin:asplos:1987](#massalin-asplos-1987),
[bansal:asplos:2006](#bansal-asplos-2006),
[bansal:osdi:2008](#bansal-osdi-2008)\
Referenced by: 
[papers/bansal:asplos:2006](#papers-bansal-asplos-2006),
[papers/bansal:osdi:2008](#papers-bansal-osdi-2008),
[papers/joshi:pldi:2002](#papers-joshi-pldi-2002),
[papers/massalin:asplos:1987](#papers-massalin-asplos-1987)\



[massalin:asplos:1987]: #papers-massalin-asplos-1987
[bansal:asplos:2006]: #papers-bansal-asplos-2006
[bansal:osdi:2008]: #papers-bansal-osdi-2008
# Survey {#notes-survey}


[[Google Scholar]](https://scholar.google.com/scholar?q=Survey)

Referenced by: 
[papers/ananda:osr:1992](#papers-ananda-osr-1992),
[papers/baldoni:compsurv:2018](#papers-baldoni-compsurv-2018),
[papers/barr:tse:2015](#papers-barr-tse-2015),
[papers/bell:procieee:2014](#papers-bell-procieee-2014),
[papers/cadar:cacm:2013](#papers-cadar-cacm-2013),
[papers/clarke:cacm:2009](#papers-clarke-cacm-2009),
[papers/demoura:cacm:2011](#papers-demoura-cacm-2011),
[papers/ge:jce:2016](#papers-ge-jce-2016),
[papers/godefroid:cacm:2020](#papers-godefroid-cacm-2020),
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[papers/malik:cacm:2009](#papers-malik-cacm-2009),
[papers/manes:ieeetse:2019](#papers-manes-ieeetse-2019),
[papers/mcmillan:ecs:2003](#papers-mcmillan-ecs-2003),
[papers/ohearn:cacm:2019](#papers-ohearn-cacm-2019)\




# Software Verification Competition (SV-COMP) {#notes-sv-competition}


[[Google Scholar]](https://scholar.google.com/scholar?q=Software%20Verification%20Competition%20%28SV-COMP%29)
[[Website]](https://sv-comp.sosy-lab.org/2020/)

Notes: 
[extended static checking](#extended static checking),
[AoRTE](#AoRTE),
[CPAchecker verifier](#CPAchecker verifier),
[BLAST verifier](#BLAST verifier),
[FQL](#FQL),
[SeaHorn verifier](#SeaHorn verifier),
[SMACK verifier](#SMACK verifier)\
Referenced by: 
[papers/beyer:cav:2011](#papers-beyer-cav-2011),
[papers/beyer:hvc:2017](#papers-beyer-hvc-2017),
[papers/beyer:ijsttt:2007](#papers-beyer-ijsttt-2007),
[papers/holzer:cav:2008](#papers-holzer-cav-2008),
[papers/visser:tacas:2020](#papers-visser-tacas-2020),
[notes/aorte](#notes-aorte),
[notes/blast-verifier](#notes-blast-verifier),
[notes/cactus-plot](#notes-cactus-plot),
[notes/cpachecker-verifier](#notes-cpachecker-verifier),
[notes/extended-static-checking](#notes-extended-static-checking),
[notes/fql](#notes-fql),
[notes/test-competition](#notes-test-competition)\


SV-COMP is an annual competition between automated software
verification tools that has been running since 2012.

The competition is useful for getting an overview of
the [main software verification
tools](https://sv-comp.sosy-lab.org/2020/systems.php).

The winners in 2020 were:
1. [CPAchecker][CPAchecker verifier]
2. [UAutomizer](https://monteverdi.informatik.uni-freiburg.de/tomcat/Website/)
3. [PeSCo](https://github.com/cedricrupb/cpachecker) (a fork of CPAchecker)



[extended static checking]: #notes-extended-static-checking
[AoRTE]: #notes-aorte
[CPAchecker verifier]: #notes-cpachecker-verifier
[BLAST verifier]: #notes-blast-verifier
[FQL]: #notes-fql
[SeaHorn verifier]: #notes-seahorn-verifier
[SMACK verifier]: #notes-smack-verifier
# Symbolic evaluation {#notes-symbolic-evaluation}


[[Google Scholar]](https://scholar.google.com/scholar?q=Symbolic%20evaluation)
[[Wikipedia]](https://en.wikipedia.org/wiki/Symbolic_execution)

Notes: 
[bounded model checking](#bounded model checking),
[symbolic execution](#symbolic execution)\
Papers: 
[nelson:sosp:2019](#nelson-sosp-2019),
[bornholt:oopsla:2018](#bornholt-oopsla-2018)\
Referenced by: 
[papers/bornholt:oopsla:2018](#papers-bornholt-oopsla-2018),
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[papers/nelson:sosp:2019](#papers-nelson-sosp-2019),
[papers/torlak:onward:2013](#papers-torlak-onward-2013),
[papers/torlak:pldi:2014](#papers-torlak-pldi-2014),
[notes/bounded-model-checking](#notes-bounded-model-checking),
[notes/rosette-solver](#notes-rosette-solver),
[notes/symbolic-execution](#notes-symbolic-execution)\


Following the terminology in section 3.1 of 
[bornholt:oopsla:2018], "symbolic evaluation" is a generalization
of [bounded model checking][bounded model checking] consisting of exploring some paths
through a program collecting symbolic path constraints from conditional
branches.

In [symbolic execution][symbolic execution], a single path is followed at a time which has the
advantage that states do not need to be merged at join points
and so many calculations involve concrete values and so can be
evaluated directly and efficiently.

In [bounded model checking][bounded model checking], all paths are followed at a time
so states have to be merged at join points resulting in many symbolic
values but, with the advantage that it avoids the path explosion
problem seen in [symbolic execution][symbolic execution].



[bounded model checking]: #notes-bounded-model-checking
[symbolic execution]: #notes-symbolic-execution
[nelson:sosp:2019]: #papers-nelson-sosp-2019
[bornholt:oopsla:2018]: #papers-bornholt-oopsla-2018
# Symbolic execution {#notes-symbolic-execution}


[[Google Scholar]](https://scholar.google.com/scholar?q=Symbolic%20execution)
[[Wikipedia]](https://en.wikipedia.org/wiki/Symbolic_execution)

Notes: 
[bounded model checking](#bounded model checking),
[fuzz testing](#fuzz testing),
[separation logic](#separation logic),
[symbolic evaluation](#symbolic evaluation),
[symbolic execution](#symbolic execution),
[DART verifier](#DART verifier),
[KLEE verifier](#KLEE verifier),
[SAGE verifier](#SAGE verifier),
[Smallfoot verifier](#Smallfoot verifier),
[VeriFast verifier](#VeriFast verifier)\
Papers: 
[nelson:sosp:2019](#nelson-sosp-2019),
[bornholt:oopsla:2018](#bornholt-oopsla-2018),
[baldoni:compsurv:2018](#baldoni-compsurv-2018),
[avgerinos:icse:2014](#avgerinos-icse-2014)\
Referenced by: 
[papers/avgerinos:icse:2014](#papers-avgerinos-icse-2014),
[papers/baldoni:compsurv:2018](#papers-baldoni-compsurv-2018),
[papers/ball:dsse:2015](#papers-ball-dsse-2015),
[papers/berdine:aplas:2005](#papers-berdine-aplas-2005),
[papers/berdine:fmco:2005](#papers-berdine-fmco-2005),
[papers/bornholt:oopsla:2018](#papers-bornholt-oopsla-2018),
[papers/braione:icse:2018](#papers-braione-icse-2018),
[papers/bush:spe:2000](#papers-bush-spe-2000),
[papers/cadar:cacm:2013](#papers-cadar-cacm-2013),
[papers/cadar:osdi:2008](#papers-cadar-osdi-2008),
[papers/chipounov:asplos:2011](#papers-chipounov-asplos-2011),
[papers/chipounov:hotdep:2009](#papers-chipounov-hotdep-2009),
[papers/chipounov:tcs:2012](#papers-chipounov-tcs-2012),
[papers/dimjasevic:ifm:2018](#papers-dimjasevic-ifm-2018),
[papers/garg:icse:2013](#papers-garg-icse-2013),
[papers/godefroid:acmq:2012](#papers-godefroid-acmq-2012),
[papers/godefroid:bugs:2005](#papers-godefroid-bugs-2005),
[papers/godefroid:cacm:2020](#papers-godefroid-cacm-2020),
[papers/godefroid:pldi:2005](#papers-godefroid-pldi-2005),
[papers/goodman:ndss:2018](#papers-goodman-ndss-2018),
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[papers/lindner:indin:2018](#papers-lindner-indin-2018),
[papers/lindner:indin:2019](#papers-lindner-indin-2019),
[papers/manes:ieeetse:2019](#papers-manes-ieeetse-2019),
[papers/schwartz:sp:2010](#papers-schwartz-sp-2010),
[papers/stephens:ndss:2016](#papers-stephens-ndss-2016),
[papers/tillmann:fse:2005](#papers-tillmann-fse-2005),
[papers/torlak:pldi:2014](#papers-torlak-pldi-2014),
[papers/visser:tacas:2020](#papers-visser-tacas-2020),
[notes/bounded-model-checking](#notes-bounded-model-checking),
[notes/civl-verifier](#notes-civl-verifier),
[notes/dart-verifier](#notes-dart-verifier),
[notes/fuzz-testing](#notes-fuzz-testing),
[notes/klee-verifier](#notes-klee-verifier),
[notes/s2e-verifier](#notes-s2e-verifier),
[notes/sage-verifier](#notes-sage-verifier),
[notes/search-based-test-generation](#notes-search-based-test-generation),
[notes/symbolic-evaluation](#notes-symbolic-evaluation),
[notes/symbolic-execution](#notes-symbolic-execution),
[notes/test-generation](#notes-test-generation)\


Following the terminology in section 3.1 of
[bornholt:oopsla:2018], [symbolic execution] is a form of
[symbolic evaluation] where a single path is followed at a time.

Following a single path has the advantage that states do not need to be merged
at join points and so many calculations involve concrete values and so can be
evaluated directly and efficiently.  The price paid for this advantage is that
there can be an exponential number of paths.

See also [bounded model checking] and [symbolic evaluation].

Types of symbolic execution include

- (Pure) symbolic execution enumerates paths, collects path conditions
  along those paths and then checks which path conditions are satisfiable.
  (Checking path conditions can be done eagerly to prune infeasible paths
  early.)

  I think this is mostly used in [separation logic] checkers such as
  the [Smallfoot verifier] and the [VeriFast verifier].

- Dynamic Symbolic Execution (DSE) mixes concrete and symbolic execution
  benefiting from the efficiency and decidability of concrete execution and the
  need to use concrete values when interacting with the program environment
  (libraries, OS, etc.) and from the stronger guarantees of symbolic execution.

  - "Offline" DSE (aka "concolic execution") relies on concrete execution
    to drive symbolic execution using an instrumented interpreter/
    simulator/... to build symbolic representations while executing
    with concrete values.

    Used in the [DART verifier].

  - "Online" DSE (aka "Execution Generated Testing" (EGT))
    mixes concrete and symbolic execution
    by using concrete execution whenever the inputs to an operation
    are concrete and using symbolic execution if any inputs are symbolic.

    Used in the [KLEE verifier].

- Static Symbolic Execution (SSE) avoids path explosion by generating
  a symbolic formula representing all paths through a piece of code.
  It does this by merging formulae at join points in a pre-execution pass.

  This approach has significant overlap with [bounded model checking]
  and the term is mostly used in the context of hybrid approaches
  such as [avgerinos:icse:2014].

- Selective Symbolic Execution (SSE)
  interleaves concrete and symbolic execution with a focus on
  performing symbolic execution as much of the code you
  care about as possible.

  (I think this may be a special case of DSE?)

todo: it is probably less useful to have a tree-shaped taxonomy of this topic
than to have a list of design choices that define an N-dimensional taxonomy
where most dimensions include "yes", "no" and "hybrid" on their axis.  This
would better capture how thoroughly the symbolic execution design space has
been explored.



[bounded model checking]: #notes-bounded-model-checking
[fuzz testing]: #notes-fuzz-testing
[separation logic]: #notes-separation-logic
[symbolic evaluation]: #notes-symbolic-evaluation
[symbolic execution]: #notes-symbolic-execution
[DART verifier]: #notes-dart-verifier
[KLEE verifier]: #notes-klee-verifier
[SAGE verifier]: #notes-sage-verifier
[Smallfoot verifier]: #notes-smallfoot-verifier
[VeriFast verifier]: #notes-verifast-verifier
[nelson:sosp:2019]: #papers-nelson-sosp-2019
[bornholt:oopsla:2018]: #papers-bornholt-oopsla-2018
[baldoni:compsurv:2018]: #papers-baldoni-compsurv-2018
[avgerinos:icse:2014]: #papers-avgerinos-icse-2014
# Symbolic model checking {#notes-symbolic-model-checking}


[[Google Scholar]](https://scholar.google.com/scholar?q=Symbolic%20model%20checking)

Is a kind of: 
[model checking](#model checking)\
Notes: 
[BDD](#BDD)\
Papers: 
[mcmillan:cav:1998](#mcmillan-cav-1998)\
Referenced by: 
[papers/clarke:cacm:2009](#papers-clarke-cacm-2009),
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[papers/mcmillan:ecs:2003](#papers-mcmillan-ecs-2003)\



[BDD]: #notes-bdd
[mcmillan:cav:1998]: #papers-mcmillan-cav-1998
# Symbolic trajectory evaluation {#notes-symbolic-trajectory-evaluation}


[[Google Scholar]](https://scholar.google.com/scholar?q=Symbolic%20trajectory%20evaluation)
[[Wikipedia]](https://en.wikipedia.org/wiki/Symbolic_trajectory_evaluation)

Notes: 
[CPU verification](#CPU verification),
[RTL](#RTL)\
Papers: 
[segar:fmsd:1995](#segar-fmsd-1995),
[claessen:sfm:2006](#claessen-sfm-2006)\
Referenced by: 
[papers/claessen:sfm:2006](#papers-claessen-sfm-2006),
[papers/kirankumar:fmcad:2012](#papers-kirankumar-fmcad-2012),
[papers/segar:fmsd:1995](#papers-segar-fmsd-1995)\



[CPU verification]: #notes-cpu-verification
[RTL]: #notes-rtl
[segar:fmsd:1995]: #papers-segar-fmsd-1995
[claessen:sfm:2006]: #papers-claessen-sfm-2006
# Systematization of Knowledge (SoK) {#notes-systematization-of-knowledge}


[[Google Scholar]](https://scholar.google.com/scholar?q=Systematization%20of%20Knowledge%20%28SoK%29)
[[Website]](https://oaklandsok.github.io/)

Papers: 
[shoshitaishvili:sp:2016](#shoshitaishvili-sp-2016)\


Security and cryptography conferences accept papers that
"evaluate, systematize and contextualize existing knowledge."
These include survey papers, evaluate competing approaches, etc.
rather than doing incremental research.

todo:



[shoshitaishvili:sp:2016]: #papers-shoshitaishvili-sp-2016
# Temporal logic {#notes-temporal-logic}


[[Google Scholar]](https://scholar.google.com/scholar?q=Temporal%20logic)
[[Wikipedia]](https://en.wikipedia.org/wiki/Temporal_logic)

Notes: 
[model checking](#model checking),
[Kripke structure](#Kripke structure)\
Papers: 
[clarke:cacm:2009](#clarke-cacm-2009),
[pnueli:sfcs:1977](#pnueli-sfcs-1977)\
Referenced by: 
[papers/clarke:cacm:2009](#papers-clarke-cacm-2009),
[papers/clarke:wlop:1982](#papers-clarke-wlop-1982),
[papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009),
[papers/mcmillan:ecs:2003](#papers-mcmillan-ecs-2003),
[papers/pnueli:sfcs:1977](#papers-pnueli-sfcs-1977),
[notes/buchi-automaton](#notes-buchi-automaton),
[notes/model-checking](#notes-model-checking)\


todo

<https://en.wikipedia.org/wiki/Category:Temporal_logic>

<https://en.wikipedia.org/wiki/Model_checking>


Several kinds of temporal logic exist (<https://en.wikipedia.org/wiki/Temporal_logic#Temporal_logics>) including

- <https://en.wikipedia.org/wiki/Linear_temporal_logic>
- <https://en.wikipedia.org/wiki/Computation_tree_logic>



[model checking]: #notes-model-checking
[Kripke structure]: #notes-kripke-structure
[clarke:cacm:2009]: #papers-clarke-cacm-2009
[pnueli:sfcs:1977]: #papers-pnueli-sfcs-1977
# Test-case reduction {#notes-test-case-reduction}


[[Google Scholar]](https://scholar.google.com/scholar?q=Test-case%20reduction)

Notes: 
[fuzz testing](#fuzz testing)\
Papers: 
[maciver:ecoop:2020](#maciver-ecoop-2020),
[regehr:pldi:2012](#regehr-pldi-2012),
[groce:issta:2017](#groce-issta-2017)\
Referenced by: 
[papers/groce:issta:2017](#papers-groce-issta-2017),
[papers/maciver:ecoop:2020](#papers-maciver-ecoop-2020),
[papers/regehr:pldi:2012](#papers-regehr-pldi-2012),
[notes/unit-tests](#notes-unit-tests)\


- [CReduce](https://embed.cs.utah.edu/creduce/)
  [regehr:pldi:2012]
- [QuickCheck](https://en.wikipedia.org/wiki/QuickCheck)
- Delta debugging
- Hierarchial Delta Debugging (HDD) uses a grammar for the test-case
  format

Instead of focusing on _reduction_, [groce:issta:2017] focused on test-case
_normalization_.



[fuzz testing]: #notes-fuzz-testing
[maciver:ecoop:2020]: #papers-maciver-ecoop-2020
[regehr:pldi:2012]: #papers-regehr-pldi-2012
[groce:issta:2017]: #papers-groce-issta-2017
# Software Testing Competition (Test-Comp) {#notes-test-competition}


[[Google Scholar]](https://scholar.google.com/scholar?q=Software%20Testing%20Competition%20%28Test-Comp%29)
[[Website]](https://test-comp.sosy-lab.org/2020/)

Notes: 
[FQL](#FQL),
[KLEE verifier](#KLEE verifier),
[SV competition](#SV competition)\
Papers: 
[beyer:ase:2019](#beyer-ase-2019)\
Referenced by: 
[papers/beyer:ase:2019](#papers-beyer-ase-2019),
[papers/beyer:hvc:2017](#papers-beyer-hvc-2017)\


TestComp is an annual competition between automated software
verification tools that has been running since 2019.
It uses the same tests and program annotations as [SV competition].
Results and tool descriptions are published in 

A subset of FQL is used to specify problems of two forms:

- Bug finding: generate tests that call the function "_VERIFIER_error".
- Coverage: generate tests that cover all branches of the program.
  - uses the TestCov tool ([beyer:ase:2019])
    tool to evaluate test coverage

The test programs are taken from [SV competition] and are

- Reachability tests - I think on small programs
- Software systems tests - larger, more realistic code like busybox, Linux
  drivers, SQLite.
- Termination (on smaller programs?)

In 2020, the winners were VeriFuzz and LibKluzzer. Their
scores were very close. They were both based on combining fuzzers
with symbolic execution to handle complex conditions.




[FQL]: #notes-fql
[KLEE verifier]: #notes-klee-verifier
[SV competition]: #notes-sv-competition
[beyer:ase:2019]: #papers-beyer-ase-2019
# Test driven development {#notes-test-driven-development}


[[Google Scholar]](https://scholar.google.com/scholar?q=Test%20driven%20development)
[[Wikipedia]](https://en.wikipedia.org/wiki/Test-driven_development)

Referenced by: 
[notes/contract-driven-development](#notes-contract-driven-development)\


todo


# Test generation {#notes-test-generation}


[[Google Scholar]](https://scholar.google.com/scholar?q=Test%20generation)

Notes: 
[fuzz testing](#fuzz testing),
[symbolic execution](#symbolic execution),
[search based test generation](#search based test generation),
[test generation](#test generation)\
Referenced by: 
[papers/babic:fse:2019](#papers-babic-fse-2019),
[papers/braione:icse:2018](#papers-braione-icse-2018),
[papers/visser:tacas:2020](#papers-visser-tacas-2020),
[papers/weigl:arxiv:2019](#papers-weigl-arxiv-2019),
[notes/test-generation](#notes-test-generation),
[notes/unit-tests](#notes-unit-tests)\





[fuzz testing]: #notes-fuzz-testing
[symbolic execution]: #notes-symbolic-execution
[search based test generation]: #notes-search-based-test-generation
[test generation]: #notes-test-generation
# Threads {#notes-threads}


[[Google Scholar]](https://scholar.google.com/scholar?q=Threads)

Notes: 
[parallelism](#parallelism),
[continuations](#continuations)\
Papers: 
[ousterhout:usenix:1996](#ousterhout-usenix-1996),
[vonbehren:hotos:2003](#vonbehren-hotos-2003),
[lauer:osr:1979](#lauer-osr-1979)\
Referenced by: 
[papers/bridges:micro:2007](#papers-bridges-micro-2007),
[papers/dabek:sigops:2002](#papers-dabek-sigops-2002),
[papers/dai:pldi:2005](#papers-dai-pldi-2005),
[papers/draves:sosp:1991](#papers-draves-sosp-1991),
[papers/dunkels:enss:2006](#papers-dunkels-enss-2006),
[papers/lauer:osr:1979](#papers-lauer-osr-1979),
[papers/ousterhout:usenix:1996](#papers-ousterhout-usenix-1996),
[papers/ozer:sbacpad:2007](#papers-ozer-sbacpad-2007),
[papers/reid:cases:2008](#papers-reid-cases-2008),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[papers/vonbehren:hotos:2003](#papers-vonbehren-hotos-2003),
[papers/wang:pldi:2007](#papers-wang-pldi-2007),
[notes/continuations](#notes-continuations),
[notes/events](#notes-events),
[notes/parallelism](#notes-parallelism)\



[parallelism]: #notes-parallelism
[continuations]: #notes-continuations
[ousterhout:usenix:1996]: #papers-ousterhout-usenix-1996
[vonbehren:hotos:2003]: #papers-vonbehren-hotos-2003
[lauer:osr:1979]: #papers-lauer-osr-1979
# Translation validation {#notes-translation-validation}


[[Google Scholar]](https://scholar.google.com/scholar?q=Translation%20validation)

Notes: 
[CompCert compiler](#CompCert compiler)\
Papers: 
[pnueli:tacas:1998](#pnueli-tacas-1998),
[necula:pldi:2000](#necula-pldi-2000),
[samet:phd:1975](#samet-phd-1975)\
Referenced by: 
[papers/leroy:cacm:2009](#papers-leroy-cacm-2009),
[papers/necula:pldi:2000](#papers-necula-pldi-2000),
[papers/pnueli:tacas:1998](#papers-pnueli-tacas-1998),
[papers/samet:ieeetse:1977](#papers-samet-ieeetse-1977),
[papers/samet:phd:1975](#papers-samet-phd-1975),
[papers/sewell:pldi:2013](#papers-sewell-pldi-2013),
[papers/tahat:fmcad:2019](#papers-tahat-fmcad-2019),
[notes/compcert-compiler](#notes-compcert-compiler),
[notes/isa-specification](#notes-isa-specification)\


todo:



[CompCert compiler]: #notes-compcert-compiler
[pnueli:tacas:1998]: #papers-pnueli-tacas-1998
[necula:pldi:2000]: #papers-necula-pldi-2000
[samet:phd:1975]: #papers-samet-phd-1975
# Turing Award {#notes-turing-award}


[[Google Scholar]](https://scholar.google.com/scholar?q=Turing%20Award)
[[Wikipedia]](https://en.wikipedia.org/wiki/Turing_Award)

Referenced by: 
[papers/clarke:cacm:2009](#papers-clarke-cacm-2009)\


The Turing Award is an annual award by the ACM "for contributions of
a technical nature made to the computing community".

See also the [IEEE John von Neumann Medal]
which is more balanced between hardware and software.


IEEE John von Neumann Medal: https://en.wikipedia.org/wiki/IEEE_John_von_Neumann_Medal



# Type Inference {#notes-type-inference}


[[Google Scholar]](https://scholar.google.com/scholar?q=Type%20Inference)

Referenced by: 
[papers/milner:jcss:1978](#papers-milner-jcss-1978),
[papers/reid:fmcad:2016](#papers-reid-fmcad-2016),
[notes/dependent-type](#notes-dependent-type)\



# Typed assembly language {#notes-typed-assembly-language}

![Typed assembly language](http://www.cs.cornell.edu/talc/images/tal-logo-medium-trans.gif){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=Typed%20assembly%20language)
[[Wikipedia]](https://en.wikipedia.org/wiki/Typed_assembly_language)

Notes: 
[proof carrying code](#proof carrying code)\
Papers: 
[morrisett:wcsss:1999](#morrisett-wcsss-1999),
[mycroft:esop:1999](#mycroft-esop-1999)\
Referenced by: 
[papers/morrisett:wcsss:1999](#papers-morrisett-wcsss-1999),
[papers/mycroft:esop:1999](#papers-mycroft-esop-1999),
[papers/walker:popl:2000](#papers-walker-popl-2000),
[papers/walker:tic:2001](#papers-walker-tic-2001),
[papers/xi:icfp:2001](#papers-xi-icfp-2001),
[papers/yang:pldi:2010](#papers-yang-pldi-2010)\


todo:



[proof carrying code]: #notes-proof-carrying-code
[morrisett:wcsss:1999]: #papers-morrisett-wcsss-1999
[mycroft:esop:1999]: #papers-mycroft-esop-1999
# Undefined behaviour {#notes-undefined-behaviour}


[[Google Scholar]](https://scholar.google.com/scholar?q=Undefined%20behaviour)
[[Wikipedia]](https://en.wikipedia.org/wiki/Undefined_behavior)

Notes: 
[Frama-C verifier](#Frama-C verifier)\
Referenced by: 
[papers/jung:popl:2017](#papers-jung-popl-2017),
[papers/jung:popl:2020](#papers-jung-popl-2020),
[papers/toman:ase:2015](#papers-toman-ase-2015),
[notes/frama-c-verifier](#notes-frama-c-verifier),
[notes/mir-interpreter](#notes-mir-interpreter),
[notes/mir](#notes-mir)\


Undefined behaviour is program behaviour that is not defined
by the programming language or by its implementation making
the behaviour of the program unpredictable.

See [Frama-C verifier].



[Frama-C verifier]: #notes-frama-c-verifier
# Under-approximation {#notes-under-approximation}


[[Google Scholar]](https://scholar.google.com/scholar?q=Under-approximation)

Referenced by: 
[papers/cok:bugs:2005](#papers-cok-bugs-2005),
[papers/godefroid:bugs:2005](#papers-godefroid-bugs-2005),
[papers/xie:bugs:2005](#papers-xie-bugs-2005)\




# Unit tests {#notes-unit-tests}


[[Google Scholar]](https://scholar.google.com/scholar?q=Unit%20tests)

Notes: 
[test-case reduction](#test-case reduction),
[test generation](#test generation),
[search-based test generation](#search-based test generation),
[property-based testing](#property-based testing)\
Referenced by: 
[papers/braione:icse:2018](#papers-braione-icse-2018),
[papers/claessen:icfp:2000](#papers-claessen-icfp-2000),
[papers/dimjasevic:ifm:2018](#papers-dimjasevic-ifm-2018),
[papers/garg:icse:2013](#papers-garg-icse-2013),
[papers/goodman:ndss:2018](#papers-goodman-ndss-2018),
[papers/maciver:ecoop:2020](#papers-maciver-ecoop-2020),
[papers/tillmann:fse:2005](#papers-tillmann-fse-2005),
[papers/weigl:arxiv:2019](#papers-weigl-arxiv-2019),
[notes/property-based-testing](#notes-property-based-testing)\






[test-case reduction]: #notes-test-case-reduction
[test generation]: #notes-test-generation
[search-based test generation]: #notes-search-based-test-generation
[property-based testing]: #notes-property-based-testing
# VCC verifier {#notes-vcc-verifier}

![VCC verifier](https://www.microsoft.com/en-us/research/uploads/prod/2016/02/vcc-vcc-150x139.png){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=VCC%20verifier)
[[Website]](https://www.microsoft.com/en-us/research/project/vcc-a-verifier-for-concurrent-c/)

Notes: 
[Boogie verifier](#Boogie verifier),
[Z3 solver](#Z3 solver),
[auto-active verification](#auto-active verification)\
Referenced by: 
[papers/cohen:cav:2010](#papers-cohen-cav-2010),
[papers/cohen:entcs:2009](#papers-cohen-entcs-2009),
[papers/legoues:sefm:2011](#papers-legoues-sefm-2011),
[papers/leinenbach:fm:2009](#papers-leinenbach-fm-2009),
[papers/vogels:fmoods:2011](#papers-vogels-fmoods-2011)\


VCC is a [auto-active program verifier][auto-active verification] for concurrent C programs
based on "two-state invariants" that specify the legal state transitions.

VCC was developed by Microsoft Research and
was used for a (partial?) verification of Microsoft's Hyper-V hypervisor.

VCC is built using the [Boogie verifier] and [Z3 solver].



[Boogie verifier]: #notes-boogie-verifier
[Z3 solver]: #notes-z3-solver
[auto-active verification]: #notes-auto-active-verification
# Vector architecture {#notes-vector-architecture}


[[Google Scholar]](https://scholar.google.com/scholar?q=Vector%20architecture)
[[Wikipedia]](https://en.wikipedia.org/wiki/Vector_processor)

Notes: 
[SIMD](#SIMD),
[data parallelism](#data parallelism),
[Instruction Set Architecture](#Instruction Set Architecture),
[microarchitecture](#microarchitecture)\
Referenced by: 
[papers/asanovic:phd:1998](#papers-asanovic-phd-1998),
[papers/blelloch:book:1990](#papers-blelloch-book-1990),
[papers/boettcher:date:2014](#papers-boettcher-date-2014),
[papers/kozyrakis:phd:2002](#papers-kozyrakis-phd-2002),
[papers/lee:micro:1996](#papers-lee-micro-1996),
[papers/lin:sdr:2006](#papers-lin-sdr-2006),
[papers/lin:sips:2006](#papers-lin-sips-2006),
[papers/peleg:micro:1996](#papers-peleg-micro-1996),
[papers/reid:cases:2008](#papers-reid-cases-2008),
[papers/reid:phd:2019](#papers-reid-phd-2019),
[papers/stephens:micro:2017](#papers-stephens-micro-2017),
[papers/tremblay:micro:1996](#papers-tremblay-micro-1996),
[papers/woh:micro:2008](#papers-woh-micro-2008),
[notes/cray-architecture](#notes-cray-architecture)\



[SIMD]: #notes-simd
[data parallelism]: #notes-data-parallelism
[Instruction Set Architecture]: #notes-instruction-set-architecture
[microarchitecture]: #notes-microarchitecture
# VeriFast verifier {#notes-verifast-verifier}


[[Google Scholar]](https://scholar.google.com/scholar?q=VeriFast%20verifier)
[[Website]](https://github.com/verifast/verifast)

Notes: 
[separation logic](#separation logic),
[fractional permissions](#fractional permissions)\
Papers: 
[jacobs:nfm:2011](#jacobs-nfm-2011),
[philippaerts:scp:2014](#philippaerts-scp-2014),
[jacobs:vstte:2010](#jacobs-vstte-2010),
[penninckx:nfm:2012](#penninckx-nfm-2012)\
Referenced by: 
[papers/berdine:fmco:2005](#papers-berdine-fmco-2005),
[papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011),
[papers/jacobs:vstte:2010](#papers-jacobs-vstte-2010),
[papers/penninckx:nfm:2012](#papers-penninckx-nfm-2012),
[papers/philippaerts:scp:2014](#papers-philippaerts-scp-2014),
[papers/tuerk:vstte:2010](#papers-tuerk-vstte-2010),
[papers/vogels:fmoods:2011](#papers-vogels-fmoods-2011),
[notes/annotation-burden](#notes-annotation-burden),
[notes/auto-active-verification](#notes-auto-active-verification),
[notes/symbolic-execution](#notes-symbolic-execution)\


VeriFast is a verifier for C and Java programs
based on [separation logic]
developed
at KU Leuven.
VeriFast includes support for
[fractional permissions]



[separation logic]: #notes-separation-logic
[fractional permissions]: #notes-fractional-permissions
[jacobs:nfm:2011]: #papers-jacobs-nfm-2011
[philippaerts:scp:2014]: #papers-philippaerts-scp-2014
[jacobs:vstte:2010]: #papers-jacobs-vstte-2010
[penninckx:nfm:2012]: #papers-penninckx-nfm-2012
# Verification tool competition {#notes-verification-competition}


[[Google Scholar]](https://scholar.google.com/scholar?q=Verification%20tool%20competition)

Referenced by: 
[papers/nyxbrain:sc2:2017](#papers-nyxbrain-sc2-2017),
[papers/sutcliffe:ai:2001](#papers-sutcliffe-ai-2001)\


Competitions for (automatic) verification tools compare tools against a common
set of benchmarks and typically compare results based on how many of the
benchmarks can be verified within a given time.  The need to have a common
input/output language and the creation of a growing set of benchmarks helps
drive a research area forward.

(There are also competitions for [auto-active verification] tools and
interactive verification tools but these also test the expertise of the humans
driving the tools.)



# Verification condition generator {#notes-verification-condition-generator}


[[Google Scholar]](https://scholar.google.com/scholar?q=Verification%20condition%20generator)
[[Wikipedia]](https://en.wikipedia.org/wiki/Verification_condition_generator)

Notes: 
[Boogie verifier](#Boogie verifier)\
Referenced by: 
[papers/barnett:fmco:2005](#papers-barnett-fmco-2005),
[notes/boogie-verifier](#notes-boogie-verifier),
[notes/viper-verifier](#notes-viper-verifier)\


todo

Examples include
[Boogie verifier]



[Boogie verifier]: #notes-boogie-verifier
# Viper verifier {#notes-viper-verifier}

![Viper verifier](https://www.pm.inf.ethz.ch/research/viper/_jcr_content/rightpar/contextinfo/fullwidthimage/image.imageformat.context.1607183700.png){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=Viper%20verifier)
[[Website]](https://www.pm.inf.ethz.ch/research/viper.html)

Notes: 
[intermediate verification language](#intermediate verification language),
[Rust language](#Rust language),
[permission logic](#permission logic),
[Prusti verifier](#Prusti verifier),
[verification condition generator](#verification condition generator)\
Referenced by: 
[papers/astrauskas:oopsla:2019](#papers-astrauskas-oopsla-2019),
[papers/blom:ijsttt:2015](#papers-blom-ijsttt-2015),
[papers/muller:vmcai:2016](#papers-muller-vmcai-2016),
[papers/schwerhoff:ecoop:2015](#papers-schwerhoff-ecoop-2015),
[notes/intermediate-verification-language](#notes-intermediate-verification-language),
[notes/ownership-types](#notes-ownership-types),
[notes/permission-logic](#notes-permission-logic),
[notes/prusti-verifier](#notes-prusti-verifier)\


Viper is an [intermediate verification language] based on
[permission logic] developed at ETH Zürich.

Frontends include [Prusti verifier] for the [Rust language].



[intermediate verification language]: #notes-intermediate-verification-language
[Rust language]: #notes-rust-language
[permission logic]: #notes-permission-logic
[Prusti verifier]: #notes-prusti-verifier
[verification condition generator]: #notes-verification-condition-generator
# Very Long Instruction Word (VLIW) {#notes-vliw}


[[Google Scholar]](https://scholar.google.com/scholar?q=Very%20Long%20Instruction%20Word%20%28VLIW%29)
[[Wikipedia]](https://en.wikipedia.org/wiki/Very_long_instruction_word)

Notes: 
[microarchitecture](#microarchitecture)\
Referenced by: 
[papers/fisher:isca:1983](#papers-fisher-isca-1983),
[papers/lin:sdr:2006](#papers-lin-sdr-2006),
[papers/lin:sips:2006](#papers-lin-sips-2006),
[papers/reid:cases:2008](#papers-reid-cases-2008),
[papers/woh:micro:2008](#papers-woh-micro-2008)\



[microarchitecture]: #notes-microarchitecture
# Weak memory {#notes-weak-memory}


[[Google Scholar]](https://scholar.google.com/scholar?q=Weak%20memory)

Referenced by: 
[papers/alglave:toplas:2014](#papers-alglave-toplas-2014),
[papers/chong:asplos:2008](#papers-chong-asplos-2008),
[papers/li:tocs:1989](#papers-li-tocs-1989),
[papers/lustig:asplos:2016](#papers-lustig-asplos-2016),
[papers/stewart:difts:2014](#papers-stewart-difts-2014),
[papers/wickerson:popl:2017](#papers-wickerson-popl-2017),
[papers/zhang:fmcad:2018](#papers-zhang-fmcad-2018),
[notes/distributed-shared-memory](#notes-distributed-shared-memory),
[notes/isa-specification](#notes-isa-specification),
[notes/memory-coherence](#notes-memory-coherence)\




# Why3 verifier {#notes-why3-verifier}

![Why3 verifier](https://gitlab.inria.fr/uploads/-/system/project/avatar/4309/logo.png){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=Why3%20verifier)
[[Website]](http://why3.lri.fr)

Referenced by: 
[papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012),
[papers/filliatre:cav:2007](#papers-filliatre-cav-2007),
[papers/filliatre:esop:2013](#papers-filliatre-esop-2013),
[papers/filliatre:fem:2004](#papers-filliatre-fem-2004)\


> Why3 is a platform for deductive program verification. It provides a rich
> language for specification and programming, called WhyML, and relies on
> external theorem provers, both automated and interactive, to discharge
> verification conditions.

todo:



# x86 architecture {#notes-x86-architecture}


[[Google Scholar]](https://scholar.google.com/scholar?q=x86%20architecture)
[[Wikipedia]](https://en.wikipedia.org/wiki/X86)

Notes: 
[instruction set architecture](#instruction set architecture)\
Referenced by: 
[papers/dasgupta:pldi:2019](#papers-dasgupta-pldi-2019),
[papers/degenbaev:phd:2012](#papers-degenbaev-phd-2012),
[papers/goel:acl2:2013](#papers-goel-acl2-2013),
[papers/goel:fmcad:2014](#papers-goel-fmcad-2014),
[papers/goel:pcs:2017](#papers-goel-pcs-2017),
[papers/goel:phd:2016](#papers-goel-phd-2016),
[papers/heule:pldi:2016](#papers-heule-pldi-2016),
[papers/kaufmann:utaustin:2012](#papers-kaufmann-utaustin-2012),
[papers/kirankumar:fmcad:2012](#papers-kirankumar-fmcad-2012),
[papers/martignoni:asplos:2012](#papers-martignoni-asplos-2012),
[papers/maus:amast:2008](#papers-maus-amast-2008),
[papers/morrisett:pldi:2012](#papers-morrisett-pldi-2012),
[papers/morrisett:wcsss:1999](#papers-morrisett-wcsss-1999),
[papers/myreen:tphols:2009](#papers-myreen-tphols-2009),
[papers/peleg:micro:1996](#papers-peleg-micro-1996),
[papers/roessle:cpp:2019](#papers-roessle-cpp-2019),
[papers/sarkar:popl:2009](#papers-sarkar-popl-2009),
[notes/instruction-set-architecture](#notes-instruction-set-architecture)\


x86 is an [instruction set architecture].



[instruction set architecture]: #notes-instruction-set-architecture
# Z3 theorem prover {#notes-z3-solver}

![Z3 theorem prover](https://upload.wikimedia.org/wikipedia/commons/thumb/0/01/Z3_Theorem_Prover_Logo_329x329.jpg/150px-Z3_Theorem_Prover_Logo_329x329.jpg){width=200px}

[[Google Scholar]](https://scholar.google.com/scholar?q=Z3%20theorem%20prover)
[[Website]](https://github.com/Z3Prover/z3)
[[Wikipedia]](https://en.wikipedia.org/wiki/Z3_Theorem_Prover)

Notes: 
[SMT solver](#SMT solver)\
Papers: 
[demoura:tacas:2008](#demoura-tacas-2008)\
Referenced by: 
[papers/avgerinos:icse:2014](#papers-avgerinos-icse-2014),
[papers/barnett:fmco:2005](#papers-barnett-fmco-2005),
[papers/demoura:tacas:2008](#papers-demoura-tacas-2008),
[papers/leino:icse:2013](#papers-leino-icse-2013),
[papers/leino:lpair:2010](#papers-leino-lpair-2010),
[notes/smt-lib-format](#notes-smt-lib-format),
[notes/smt-solver](#notes-smt-solver),
[notes/vcc-verifier](#notes-vcc-verifier)\


Z3 is a theorem prover developed by Microsoft Research.
The core of Z3 is an [SMT solver] but it has many other features.



[SMT solver]: #notes-smt-solver
[demoura:tacas:2008]: #papers-demoura-tacas-2008
# Author Index

- Mark D. Aagaard: [papers/aagaard:charme:2001](#papers-aagaard-charme-2001), [papers/aagaard:fmcad:2000](#papers-aagaard-fmcad-2000), [papers/higgins:hldvt:2004](#papers-higgins-hldvt-2004)
- Martín Abadi: [papers/abadi:tcs:1991](#papers-abadi-tcs-1991)
- Oskar Abrahamsson: [papers/loow:pldi:2019](#papers-loow-pldi-2019)
- Vikram Adve: [papers/dasgupta:pldi:2019](#papers-dasgupta-pldi-2019)
- Edward Aftandilian: [papers/sadowski:cacm:2018](#papers-sadowski-cacm-2018)
- Gagan Agrawal: [papers/du:sc:2003](#papers-du-sc-2003)
- Nazareno M. Aguirre: [papers/frias:icse:2005](#papers-frias-icse-2005)
- Amal Ahmed: [papers/bowman:icfp:2015](#papers-bowman-icfp-2015), [papers/weiss:arxiv:2018](#papers-weiss-arxiv-2018)
- Alex Aiken: [papers/bansal:asplos:2006](#papers-bansal-asplos-2006), [papers/bansal:osdi:2008](#papers-bansal-osdi-2008), [papers/heule:pldi:2016](#papers-heule-pldi-2016), [papers/sharma:oopsla:2012](#papers-sharma-oopsla-2012), [papers/sharma:pls:2013](#papers-sharma-pls-2013), [papers/xie:bugs:2005](#papers-xie-bugs-2005)
- Bashir M. Al-Hashimi: [papers/boettcher:date:2014](#papers-boettcher-date-2014)
- Kenneth L. Albin: [papers/albin:cli:1995](#papers-albin-cli-1995), [papers/lahiri:hldvt:2001](#papers-lahiri-hldvt-2001)
- Jonathan Aldrich: [papers/krishnaswami:tldi:2010](#papers-krishnaswami-tldi-2010)
- Jade Alglave: [papers/alglave:toplas:2014](#papers-alglave-toplas-2014), [papers/sarkar:pldi:2011](#papers-sarkar-pldi-2011), [papers/sarkar:popl:2009](#papers-sarkar-popl-2009)
- Muneeb Ali: [papers/dunkels:enss:2006](#papers-dunkels-enss-2006)
- Mohammad Amin Alipour: [papers/zhang:issta:2014](#papers-zhang-issta-2014)
- Eyad Alkassar: [papers/alkassar:vstte:2010](#papers-alkassar-vstte-2010), [papers/alkassar:vstte:2012](#papers-alkassar-vstte-2012)
- José Bacelar Almeida: [papers/almeida:security:2016](#papers-almeida-security-2016)
- Sidney Amani: [papers/amani:asplos:2016](#papers-amani-asplos-2016)
- Saman P. Amarasinghe: [papers/gordon:asplos:2002](#papers-gordon-asplos-2002), [papers/thies:micro:2007](#papers-thies-micro-2007), [papers/thies:ppopp:2005](#papers-thies-ppopp-2005)
- Arthur Azevedo de Amorim: [papers/hritcu:icfp:2013](#papers-hritcu-icfp-2013), [papers/pierce:book:2016](#papers-pierce-book-2016)
- Akkihebbal L. Ananda: [papers/ananda:osr:1992](#papers-ananda-osr-1992)
- Michael P. Andersen: [papers/levy:plos:2015](#papers-levy-plos-2015)
- David Andersen: [papers/spencer:security:1999](#papers-spencer-security-1999)
- Jonathan Anderson: [papers/woodruff:isca:2014](#papers-woodruff-isca-2014)
- June Andronick: [papers/andronick:icse:2012](#papers-andronick-icse-2012), [papers/klein:sosp:2009](#papers-klein-sosp-2009)
- Jorge Aparicius: [papers/lindner:indin:2018](#papers-lindner-indin-2018)
- Alasdair Armstrong: [papers/armstrong:arw:2018](#papers-armstrong-arw-2018), [papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019), [papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019)
- Arvind: [papers/choi:icfp:2017](#papers-choi-icfp-2017)
- Krste Asanović: [papers/asanovic:phd:1998](#papers-asanovic-phd-1998)
- Vytautas Astrauskas: [papers/astrauskas:oopsla:2019](#papers-astrauskas-oopsla-2019)
- David August: [papers/bridges:micro:2007](#papers-bridges-micro-2007)
- Lennart Augustsson: [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999)
- Thanassis Avgerinos: [papers/avgerinos:icse:2014](#papers-avgerinos-icse-2014), [papers/schwartz:sp:2010](#papers-schwartz-sp-2010)
- Jeremy Avigad: [papers/demoura:cade:2015](#papers-demoura-cade-2015)
- Domagoj Babić: [papers/babic:fse:2019](#papers-babic-fse-2019)
- Alberto Bacchelli: [papers/sadowski:icse-seip:2018](#papers-sadowski-icse-seip-2018)
- Gogul Balakrishnan: [papers/garg:icse:2013](#papers-garg-icse-2013)
- Abhiram Balasubramanian: [papers/balasubramanium:hotos:2017](#papers-balasubramanium-hotos-2017)
- Roberto Baldoni: [papers/baldoni:compsurv:2018](#papers-baldoni-compsurv-2018)
- Thomas Ball: [papers/ball:dsse:2015](#papers-ball-dsse-2015), [papers/ball:pldi:2001](#papers-ball-pldi-2001)
- Anindya Banerjee: [papers/nanevski:oopsla:2019](#papers-nanevski-oopsla-2019)
- Sorav Bansal: [papers/bansal:asplos:2006](#papers-bansal-asplos-2006), [papers/bansal:osdi:2008](#papers-bansal-osdi-2008)
- Marek S. Baranowski: [papers/balasubramanium:hotos:2017](#papers-balasubramanium-hotos-2017), [papers/baranowski:atva:2018](#papers-baranowski-atva-2018), [papers/narayanan:hotos:2019](#papers-narayanan-hotos-2019)
- Mario R. Barbacci: [papers/barbacci2:computer:1973](#papers-barbacci2-computer-1973), [papers/barbacci:afips:1977](#papers-barbacci-afips-1977), [papers/barbacci:cmu:1972](#papers-barbacci-cmu-1972), [papers/barbacci:computer:1973](#papers-barbacci-computer-1973), [papers/barbacci:computer:1977](#papers-barbacci-computer-1977), [papers/barbacci:computer:1978](#papers-barbacci-computer-1978), [papers/barbacci:dac:1979](#papers-barbacci-dac-1979), [papers/barbacci:icse:1988](#papers-barbacci-icse-1988), [papers/barbacci:ieee:1981](#papers-barbacci-ieee-1981), [papers/barbacci:ieeetc:1975](#papers-barbacci-ieeetc-1975), [papers/barbacci:ieeetc:1981](#papers-barbacci-ieeetc-1981), [papers/barbacci:isca:1973](#papers-barbacci-isca-1973), [papers/chu:ieeedtc:1992](#papers-chu-ieeedtc-1992), [papers/dam:ieeetc:1981](#papers-dam-ieeetc-1981), [papers/djordjevic:cj:1985](#papers-djordjevic-cj-1985)
- Manuel Barbosa: [papers/almeida:security:2016](#papers-almeida-security-2016)
- Mike Barnett: [papers/barnett:cacm:2011](#papers-barnett-cacm-2011), [papers/barnett:cassis:2004](#papers-barnett-cassis-2004), [papers/barnett:fmco:2005](#papers-barnett-fmco-2005), [papers/barnett:vstte:2005](#papers-barnett-vstte-2005), [papers/cousot:oopsla:2012](#papers-cousot-oopsla-2012)
- Earl T. Barr: [papers/barr:tse:2015](#papers-barr-tse-2015)
- Clark W. Barrett: [papers/barrett:cade:2000](#papers-barrett-cade-2000), [papers/barrett:cav:2011](#papers-barrett-cav-2011), [papers/barrett:mlf:2015](#papers-barrett-mlf-2015), [papers/barrett:smtlib:2016](#papers-barrett-smtlib-2016)
- John Barstow: [papers/kuhne:fmcad:2010](#papers-kuhne-fmcad-2010)
- Gilles Barthe: [papers/almeida:security:2016](#papers-almeida-security-2016), [papers/barthe:csfw:2004](#papers-barthe-csfw-2004), [papers/barthe:iacr:2007](#papers-barthe-iacr-2007), [papers/barthe:mscs:2011](#papers-barthe-mscs-2011)
- Dave Barton: [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999)
- Forest Baskett: [papers/hennessy:micro:1982](#papers-hennessy-micro-1982)
- Théophile Bastian: [papers/bastian:oopsla:2019](#papers-bastian-oopsla-2019)
- Christopher Batten: [papers/lockhart:ispass:2015](#papers-lockhart-ispass-2015)
- Mark Batty: [papers/wickerson:popl:2017](#papers-wickerson-popl-2017)
- Patrick Baudin: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- Thomas Bauereiss: [papers/armstrong:arw:2018](#papers-armstrong-arw-2018), [papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019), [papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019), [papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020)
- Andrew Baumann: [papers/baumann:hotos:2017](#papers-baumann-hotos-2017), [papers/ferraiuolo:sosp:2017](#papers-ferraiuolo-sosp-2017), [papers/nelson:sosp:2019](#papers-nelson-sosp-2019)
- Hanno Becker: [papers/becker:fm:2016](#papers-becker-fm-2016)
- Bernhard Beckert: [papers/weigl:arxiv:2019](#papers-weigl-arxiv-2019)
- Joel Beeren: [papers/amani:asplos:2016](#papers-amani-asplos-2016)
- Robert von Behren: [papers/gay:pldi:2003](#papers-gay-pldi-2003), [papers/vonbehren:hotos:2003](#papers-vonbehren-hotos-2003)
- C. Gordon Bell: [papers/barbacci2:computer:1973](#papers-barbacci2-computer-1973), [papers/barbacci:cmu:1972](#papers-barbacci-cmu-1972), [papers/barbacci:computer:1973](#papers-barbacci-computer-1973), [papers/bell:afips:1970](#papers-bell-afips-1970), [papers/bell:book:1971](#papers-bell-book-1971), [papers/bell:cacm:2008](#papers-bell-cacm-2008), [papers/bell:procieee:2014](#papers-bell-procieee-2014)
- Josh Berdine: [papers/berdine:aplas:2005](#papers-berdine-aplas-2005), [papers/berdine:fmco:2005](#papers-berdine-fmco-2005)
- Brian N. Bershad: [papers/bershad:cmpcon:1993](#papers-bershad-cmpcon-1993), [papers/draves:sosp:1991](#papers-draves-sosp-1991)
- William R. Bevier: [papers/bevier:jar:1989](#papers-bevier-jar-1989)
- Dirk Beyer: [papers/beyer:ase:2019](#papers-beyer-ase-2019), [papers/beyer:cav:2011](#papers-beyer-cav-2011), [papers/beyer:hvc:2017](#papers-beyer-hvc-2017), [papers/beyer:ijsttt:2007](#papers-beyer-ijsttt-2007), [papers/beyer:sas:2004](#papers-beyer-sas-2004)
- Sven Beyer: [papers/beyer:ijsttt:2006](#papers-beyer-ijsttt-2006), [papers/kuhne:fmcad:2010](#papers-kuhne-fmcad-2010)
- Abhijith Bharadwaj: [papers/verbeek:fmmsd:2019](#papers-verbeek-fmmsd-2019)
- Abhishek Bhattacharjee: [papers/lustig:asplos:2016](#papers-lustig-asplos-2016)
- Armin Biere: [papers/biere:tacas:1999](#papers-biere-tacas-1999), [papers/brummayer:sat:2010](#papers-brummayer-sat-2010), [papers/niemetz:jsat:2015](#papers-niemetz-jsat-2015)
- Gavin Bierman: [papers/parkinson:popl:2005](#papers-parkinson-popl-2005)
- Stuart Biles: [papers/ozer:sbacpad:2007](#papers-ozer-sbacpad-2007), [papers/stephens:micro:2017](#papers-stephens-micro-2017)
- Peter L. Bird: [papers/bird:sc:1993](#papers-bird-sc-1993)
- Lars Birkedal: [papers/dinsdale-young:popl:2013](#papers-dinsdale-young-popl-2013), [papers/krishnaswami:tldi:2010](#papers-krishnaswami-tldi-2010), [papers/nanevski:icfp:2008](#papers-nanevski-icfp-2008), [papers/skorstengaard:esop:2018](#papers-skorstengaard-esop-2018), [papers/skorstengaard:popl:2019](#papers-skorstengaard-popl-2019)
- Andrew D. Birrell: [papers/birrell:tocs:1984](#papers-birrell-tocs-1984)
- Nikolaj Bjørner: [papers/demoura:cacm:2011](#papers-demoura-cacm-2011), [papers/demoura:tacas:2008](#papers-demoura-tacas-2008)
- Alan F. Blackwell: [papers/green:tutorial:1998](#papers-green-tutorial-1998)
- Allan Blanchard: [papers/blanchard:fmics:2015](#papers-blanchard-fmics-2015)
- Frédéric Blanqui: [papers/blanqui:rapido:2011](#papers-blanqui-rapido-2011)
- Guy E. Blelloch: [papers/blelloch:book:1990](#papers-blelloch-book-1990)
- Stefan Blom: [papers/blom:ijsttt:2015](#papers-blom-ijsttt-2015)
- Joshua Bockenek: [papers/verbeek:fmmsd:2019](#papers-verbeek-fmmsd-2019)
- Rastislav Bodik: [papers/torlak:onward:2013](#papers-torlak-onward-2013), [papers/torlak:pldi:2014](#papers-torlak-pldi-2014)
- Martin Bodin: [papers/bodin:popl:2014](#papers-bodin-popl-2014)
- Matthias Boettcher: [papers/boettcher:date:2014](#papers-boettcher-date-2014), [papers/stephens:micro:2017](#papers-stephens-micro-2017)
- Richard Bonichon: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- Edson Borin: [papers/silva:sbac:2016](#papers-silva-sbac-2016)
- Jörg Bormann: [papers/kuhne:fmcad:2010](#papers-kuhne-fmcad-2010)
- Richard Bornat: [papers/bornat:popl:2005](#papers-bornat-popl-2005)
- James Bornholt: [papers/bornholt:oopsla:2018](#papers-bornholt-oopsla-2018), [papers/nelson:sosp:2017](#papers-nelson-sosp-2017), [papers/nelson:sosp:2019](#papers-nelson-sosp-2019), [papers/sigurbjarnarson:osdi:2016](#papers-sigurbjarnarson-osdi-2016), [papers/sigurbjarnarson:osdi:2018](#papers-sigurbjarnarson-osdi-2018)
- Bernard Botella: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- Richard Boulton: [papers/boulton:tpcd:1993](#papers-boulton-tpcd-1993)
- Timothy Bourke: [papers/murray:secpriv:2013](#papers-murray-secpriv-2013)
- Brian Boutel: [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999)
- William J. Bowman: [papers/bowman:icfp:2015](#papers-bowman-icfp-2015)
- Silas Boyd-Wickizer: [papers/zeldovich:osdi:2006](#papers-zeldovich-osdi-2006)
- Thomas Braibant: [papers/sarkar:popl:2009](#papers-sarkar-popl-2009)
- Martin Nyx Brain: [papers/nyxbrain:sc2:2017](#papers-nyxbrain-sc2-2017)
- Pietro Braione: [papers/braione:icse:2018](#papers-braione-icse-2018)
- Matthew Brassil: [papers/murray:secpriv:2013](#papers-murray-secpriv-2013)
- Eric Brewer: [papers/gay:pldi:2003](#papers-gay-pldi-2003), [papers/vonbehren:hotos:2003](#papers-vonbehren-hotos-2003)
- Matthew Bridges: [papers/bridges:micro:2007](#papers-bridges-micro-2007)
- Bishop C. Brock: [papers/albin:cli:1995](#papers-albin-cli-1995)
- Micah Brodsky: [papers/krohn:sosp:2007](#papers-krohn-sosp-2007)
- Stephen Brookes: [papers/brookes:tcs:2006](#papers-brookes-tcs-2006)
- Richard Bruce: [papers/woh:micro:2008](#papers-woh-micro-2008)
- David Brumley: [papers/avgerinos:icse:2014](#papers-avgerinos-icse-2014), [papers/schwartz:sp:2010](#papers-schwartz-sp-2010)
- Robert Brummayer: [papers/brummayer:sat:2010](#papers-brummayer-sat-2010)
- Randal E. Bryant: [papers/lahiri:cav:2003](#papers-lahiri-cav-2003), [papers/segar:fmsd:1995](#papers-segar-fmsd-1995), [papers/velev:dac:2000](#papers-velev-dac-2000)
- Stefan Bucur: [papers/babic:fse:2019](#papers-babic-fse-2019)
- Jerry R. Burch: [papers/burch:cav:1994](#papers-burch-cav-1994)
- David A. Burke: [papers/burke:lacl:2005](#papers-burke-lacl-2005)
- Mike Burrows: [papers/chang:tocs:2012](#papers-chang-tocs-2012)
- Warren Burton: [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999)
- Anton Burtsev: [papers/balasubramanium:hotos:2017](#papers-balasubramanium-hotos-2017), [papers/narayanan:hotos:2019](#papers-narayanan-hotos-2019)
- William R. Bush: [papers/bush:spe:2000](#papers-bush-spe-2000)
- Marcel Böhme: [papers/bohme2:fse:2020](#papers-bohme2-fse-2020), [papers/bohme:fse:2020](#papers-bohme-fse-2020)
- Cristian Cadar: [papers/cadar:cacm:2013](#papers-cadar-cacm-2013), [papers/cadar:osdi:2008](#papers-cadar-osdi-2008)
- Cristiano Calcagno: [papers/berdine:aplas:2005](#papers-berdine-aplas-2005), [papers/berdine:fmco:2005](#papers-berdine-fmco-2005), [papers/bornat:popl:2005](#papers-bornat-popl-2005), [papers/calcagno:popl:2009](#papers-calcagno-popl-2009)
- Brian Campbell: [papers/armstrong:arw:2018](#papers-armstrong-arw-2018), [papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019), [papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019), [papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020)
- Bradford Campbell: [papers/levy:apsys:2017](#papers-levy-apsys-2017), [papers/levy:plos:2015](#papers-levy-plos-2015), [papers/levy:sosp:2017](#papers-levy-sosp-2017)
- Mark Campbell: [papers/liu:cpsspc:2018](#papers-liu-cpsspc-2018)
- George Candea: [papers/chipounov:asplos:2011](#papers-chipounov-asplos-2011), [papers/chipounov:hotdep:2009](#papers-chipounov-hotdep-2009), [papers/chipounov:tcs:2012](#papers-chipounov-tcs-2012), [papers/wagner:hotos:2013](#papers-wagner-hotos-2013)
- Chandler Carruth: [papers/wright:icsm:2013](#papers-wright-icsm-2013)
- Chris Casinghino: [papers/pierce:book:2016](#papers-pierce-book-2016)
- Ghila Castelnuovo: [papers/naik:popl:2012](#papers-naik-popl-2012)
- Bruno Castro-Karney: [papers/sigurbjarnarson:osdi:2018](#papers-sigurbjarnarson-osdi-2018)
- Roderic Geoffrey Galton Cattell: [papers/cattell:phd:1978](#papers-cattell-phd-1978), [papers/cattell:toplas:1980](#papers-cattell-toplas-1980)
- Luis Ceze: [papers/zorn:iscawddd:2017](#papers-zorn-iscawddd-2017)
- Sang Kil Cha: [papers/avgerinos:icse:2014](#papers-avgerinos-icse-2014), [papers/bohme:fse:2020](#papers-bohme-fse-2020), [papers/manes:ieeetse:2019](#papers-manes-ieeetse-2019)
- Suhyun Cha: [papers/weigl:arxiv:2019](#papers-weigl-arxiv-2019)
- Sagar Chaki: [papers/franklin:cmu:2008](#papers-franklin-cmu-2008), [papers/vasudevan:secpriv:2013](#papers-vasudevan-secpriv-2013), [papers/vasudevan:usenix:2016](#papers-vasudevan-usenix-2016)
- Chaitali Chakrabarti: [papers/lin:sips:2006](#papers-lin-sips-2006), [papers/woh:micro:2008](#papers-woh-micro-2008)
- Manuel Chakravarty: [papers/chakravarty:haskffi:2003](#papers-chakravarty-haskffi-2003)
- Tushar Chandra: [papers/chang:tocs:2012](#papers-chang-tocs-2012)
- Vikram Chandrasekhar: [papers/thies:micro:2007](#papers-thies-micro-2007)
- Bor-Yuh Evan Chang: [papers/barnett:fmco:2005](#papers-barnett-fmco-2005)
- Fay Chang: [papers/chang:tocs:2012](#papers-chang-tocs-2012)
- Arthur Chargueraud: [papers/bodin:popl:2014](#papers-bodin-popl-2014)
- Shaunak Chatterjee: [papers/chatterjee:tacas:2007](#papers-chatterjee-tacas-2007)
- Zilin Chen: [papers/amani:asplos:2016](#papers-amani-asplos-2016)
- Yaohui Chen: [papers/babic:fse:2019](#papers-babic-fse-2019)
- Hao Chen: [papers/gu:osdi:2016](#papers-gu-osdi-2016)
- Yang Chen: [papers/regehr:pldi:2012](#papers-regehr-pldi-2012)
- Rick Chen: [papers/reid:cav:2016](#papers-reid-cav-2016)
- Gautham N. Chinya: [papers/wang:pldi:2007](#papers-wang-pldi-2007)
- Vitaly Chipounov: [papers/chipounov:asplos:2011](#papers-chipounov-asplos-2011), [papers/chipounov:hotdep:2009](#papers-chipounov-hotdep-2009), [papers/chipounov:tcs:2012](#papers-chipounov-tcs-2012)
- David Chisnall: [papers/woodruff:isca:2014](#papers-woodruff-isca-2014)
- Adam J. Chlipala: [papers/beyer:sas:2004](#papers-beyer-sas-2004), [papers/choi:icfp:2017](#papers-choi-icfp-2017)
- Joonwon Choi: [papers/choi:icfp:2017](#papers-choi-icfp-2017)
- Nathan Chong: [papers/chong:asplos:2008](#papers-chong-asplos-2008), [papers/chong:icse:2020](#papers-chong-icse-2020)
- Frederic T. Chong: [papers/tiwari:asplos:2009](#papers-tiwari-asplos-2009), [papers/tiwari:isca:2009](#papers-tiwari-isca-2009), [papers/tiwari:isca:2011](#papers-tiwari-isca-2011)
- Andy Chou: [papers/chou:bugs:2005](#papers-chou-bugs-2005)
- Maria Christakis: [papers/mansur:arxiv:2020](#papers-mansur-arxiv-2020)
- Yaohan Chu: [papers/chu:ieeedtc:1992](#papers-chu-ieeedtc-1992)
- Peter Chubb: [papers/amani:asplos:2016](#papers-amani-asplos-2016)
- Luke Church: [papers/macvean:ppig:2016](#papers-macvean-ppig-2016), [papers/sadowski:icse-seip:2018](#papers-sadowski-icse-seip-2018)
- Berkeley Churchill: [papers/sharma:oopsla:2012](#papers-sharma-oopsla-2012)
- Cristina Cifuentes: [papers/cifuentes:computer:2000](#papers-cifuentes-computer-2000), [papers/cifuentes:iwpc:1998](#papers-cifuentes-iwpc-1998)
- Alessandro Cimatti: [papers/biere:tacas:1999](#papers-biere-tacas-1999)
- Craig Citro: [papers/macvean:ppig:2016](#papers-macvean-ppig-2016)
- Koen Claessen: [papers/claessen:icfp:2000](#papers-claessen-icfp-2000), [papers/claessen:sfm:2006](#papers-claessen-sfm-2006)
- David Clark: [papers/clark:entcs:2002](#papers-clark-entcs-2002)
- Edmund M. Clarke: [papers/biere:tacas:1999](#papers-biere-tacas-1999), [papers/clarke:cacm:2009](#papers-clarke-cacm-2009), [papers/clarke:cav:2000](#papers-clarke-cav-2000), [papers/clarke:tacas:2004](#papers-clarke-tacas-2004), [papers/clarke:wlop:1982](#papers-clarke-wlop-1982)
- Michael R. Clarkson: [papers/clarkson:jcs:2010](#papers-clarkson-jcs-2010)
- Natan Cliffer: [papers/krohn:sosp:2007](#papers-krohn-sosp-2007)
- David Cock: [papers/cock:ccs:2014](#papers-cock-ccs-2014), [papers/ge:jce:2016](#papers-ge-jce-2016), [papers/klein:sosp:2009](#papers-klein-sosp-2009)
- Ernie Cohen: [papers/alkassar:vstte:2012](#papers-alkassar-vstte-2012), [papers/cohen:cav:2010](#papers-cohen-cav-2010), [papers/cohen:entcs:2009](#papers-cohen-entcs-2009)
- David R. Cok: [papers/cok:bugs:2005](#papers-cok-bugs-2005), [papers/noonan:pldi:2016](#papers-noonan-pldi-2016)
- Jamison D. Collins: [papers/wang:pldi:2007](#papers-wang-pldi-2007)
- Jeremy Condit: [papers/condit:popl:2009](#papers-condit-popl-2009), [papers/vonbehren:hotos:2003](#papers-vonbehren-hotos-2003)
- George A. Constantinides: [papers/wickerson:popl:2017](#papers-wickerson-popl-2017)
- Christopher L. Conway: [papers/barrett:cav:2011](#papers-barrett-cav-2011)
- Melvin E. Conway: [papers/conway:cacm:1963](#papers-conway-cacm-1963)
- Byron Cook: [papers/aagaard:charme:2001](#papers-aagaard-charme-2001), [papers/chong:icse:2020](#papers-chong-icse-2020), [papers/cook:cav:2018](#papers-cook-cav-2018)
- Emilio Coppa: [papers/baldoni:compsurv:2018](#papers-baldoni-compsurv-2018)
- Thierry Coquand: [papers/coquand:eurocal:1985](#papers-coquand-eurocal-1985)
- James C. Corbett: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Joe Corbett-Davies: [papers/liu:cpsspc:2018](#papers-liu-cpsspc-2018)
- Jacopo Corbetta: [papers/stephens:ndss:2016](#papers-stephens-ndss-2016)
- Lucas C. Cordeiro: [papers/monteiro:arxiv:2019](#papers-monteiro-arxiv-2019)
- Digital Equipment Corporation: [papers/pdp11:book:1973](#papers-pdp11-book-1973)
- Loïc Correnson: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- David Costanzo: [papers/costanzo:pldi:2016](#papers-costanzo-pldi-2016), [papers/gu:osdi:2016](#papers-gu-osdi-2016)
- Patrick Cousot: [papers/cousot:oopsla:2012](#papers-cousot-oopsla-2012)
- Radhia Cousot: [papers/cousot:oopsla:2012](#papers-cousot-oopsla-2012)
- Karl Crary: [papers/morrisett:wcsss:1999](#papers-morrisett-wcsss-1999)
- Juan Manuel Crespo: [papers/becker:fm:2016](#papers-becker-fm-2016)
- David Culler: [papers/gay:pldi:2003](#papers-gay-pldi-2003), [papers/levy:plos:2015](#papers-levy-plos-2015)
- Pascal Cuoq: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012), [papers/regehr:pldi:2012](#papers-regehr-pldi-2012)
- Pedro R. D'Argenio: [papers/barthe:csfw:2004](#papers-barthe-csfw-2004), [papers/barthe:mscs:2011](#papers-barthe-mscs-2011)
- Daniele Cono D'elia: [papers/baldoni:compsurv:2018](#papers-baldoni-compsurv-2018)
- Frank Dabek: [papers/dabek:sigops:2002](#papers-dabek-sigops-2002)
- Jinquan Dai: [papers/dai:pldi:2005](#papers-dai-pldi-2005)
- Ross Daly: [papers/kim:isca:2014](#papers-kim-isca-2014)
- Andries van Dam: [papers/dam:ieeetc:1981](#papers-dam-ieeetc-1981)
- Mads Dam: [papers/dam:ted:2013](#papers-dam-ted-2013), [papers/dam:trusted:2013](#papers-dam-trusted-2013), [papers/khakpour:cpp:2013](#papers-khakpour-cpp-2013), [papers/schwarz:sefm:2016](#papers-schwarz-sefm-2016)
- Werner Damm: [papers/damm:fmoods:1999](#papers-damm-fmoods-1999)
- Hoang-Hai Dang: [papers/jung:popl:2020](#papers-jung-popl-2020)
- Jakub Daniel: [papers/ball:dsse:2015](#papers-ball-dsse-2015)
- Zaynah Dargaye: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- Sandeep Dasgupta: [papers/dasgupta:pldi:2019](#papers-dasgupta-pldi-2019)
- Anupam Datta: [papers/franklin:cmu:2008](#papers-franklin-cmu-2008), [papers/vasudevan:secpriv:2013](#papers-vasudevan-secpriv-2013), [papers/vasudevan:usenix:2016](#papers-vasudevan-usenix-2016)
- John Daughtry: [papers/macvean:ppig:2016](#papers-macvean-ppig-2016)
- James H. Davenport: [papers/nyxbrain:sc2:2017](#papers-nyxbrain-sc2-2017)
- Jack W. Davidson: [papers/ramsey:lctes:1998](#papers-ramsey-lctes-1998)
- Jared Davis: [papers/slobodova:memocode:2011](#papers-slobodova-memocode-2011)
- Brooks Davis: [papers/woodruff:isca:2014](#papers-woodruff-isca-2014)
- Nancy A. Day: [papers/aagaard:charme:2001](#papers-aagaard-charme-2001)
- Robert DeLine: [papers/barnett:fmco:2005](#papers-barnett-fmco-2005), [papers/barnett:vstte:2005](#papers-barnett-vstte-2005), [papers/deline:pldi:2001](#papers-deline-pldi-2001)
- Will Deacon: [papers/flur:popl:2016](#papers-flur-popl-2016)
- Jeffrey Dean: [papers/chang:tocs:2012](#papers-chang-tocs-2012), [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Randall W. Dean: [papers/draves:sosp:1991](#papers-draves-sosp-1991)
- Ulan Degenbaev: [papers/degenbaev:phd:2012](#papers-degenbaev-phd-2012)
- Germán Andrés Delbianco: [papers/nanevski:oopsla:2019](#papers-nanevski-oopsla-2019)
- Anastasios Deligiannis: [papers/reid:cav:2016](#papers-reid-cav-2016)
- Camil Demetrescu: [papers/baldoni:compsurv:2018](#papers-baldoni-compsurv-2018)
- Onur Demir: [papers/deng:hasp:2019](#papers-deng-hasp-2019)
- Giovanni Denaro: [papers/braione:icse:2018](#papers-braione-icse-2018)
- Shuwen Deng: [papers/deng:hasp:2019](#papers-deng-hasp-2019)
- Dorothy E. Denning: [papers/denning:cacm:1976](#papers-denning-cacm-1976)
- Philip Derrin: [papers/klein:sosp:2009](#papers-klein-sosp-2009)
- Morgan Deters: [papers/barrett:cav:2011](#papers-barrett-cav-2011)
- Dominique Devriese: [papers/skorstengaard:esop:2018](#papers-skorstengaard-esop-2018), [papers/skorstengaard:popl:2019](#papers-skorstengaard-popl-2019)
- João Dias: [papers/dias:popl:2010](#papers-dias-popl-2010)
- Donald L. Dietmeyer: [papers/chu:ieeedtc:1992](#papers-chu-ieeedtc-1992)
- David L. Dill: [papers/barrett:cade:2000](#papers-barrett-cade-2000), [papers/burch:cav:1994](#papers-burch-cav-1994)
- Marko Dimjašević: [papers/dimjasevic:ifm:2018](#papers-dimjasevic-ifm-2018)
- Thomas Dinsdale-Young: [papers/dinsdale-young:popl:2013](#papers-dinsdale-young-popl-2013)
- Dino Distefano: [papers/calcagno:popl:2009](#papers-calcagno-popl-2009), [papers/distefano:tacas:2006](#papers-distefano-tacas-2006)
- David R. Ditzel: [papers/patterson:sigarch:1980](#papers-patterson-sigarch-1980)
- Jovan Djordjevic: [papers/djordjevic:cj:1985](#papers-djordjevic-cj-1985)
- Alastair F. Donaldson: [papers/maciver:ecoop:2020](#papers-maciver-ecoop-2020)
- Floris Van Doorn: [papers/demoura:cade:2015](#papers-demoura-cade-2015)
- Richard P. Draves: [papers/draves:sosp:1991](#papers-draves-sosp-1991)
- Derek Dreyer: [papers/jung:popl:2017](#papers-jung-popl-2017), [papers/jung:popl:2020](#papers-jung-popl-2020)
- Wei Du: [papers/du:sc:2003](#papers-du-sc-2003)
- James R. Duley: [papers/chu:ieeedtc:1992](#papers-chu-ieeedtc-1992)
- Daniel Dunbar: [papers/cadar:osdi:2008](#papers-cadar-osdi-2008)
- Adam Dunkels: [papers/dunkels:enss:2006](#papers-dunkels-enss-2006)
- Usit Duongsaa: [papers/regehr:lctes:2006](#papers-regehr-lctes-2006)
- François Dupressoir: [papers/almeida:security:2016](#papers-almeida-security-2016)
- Simon Duquennoy: [papers/mangano:crisis:2016](#papers-mangano-crisis-2016)
- Andrew Dutcher: [papers/shoshitaishvili:sp:2016](#papers-shoshitaishvili-sp-2016), [papers/stephens:ndss:2016](#papers-stephens-ndss-2016)
- Nikil Dutt: [papers/mishra:book:2008](#papers-mishra-book-2008)
- Prabal Dutta: [papers/levy:apsys:2017](#papers-levy-apsys-2017), [papers/levy:plos:2015](#papers-levy-plos-2015), [papers/levy:sosp:2017](#papers-levy-sosp-2017)
- Matthew B. Dwyer: [papers/siegel:sc:2015](#papers-siegel-sc-2015)
- Alex Eagle: [papers/sadowski:cacm:2018](#papers-sadowski-cacm-2018)
- Jacob Eapen: [papers/stephens:micro:2017](#papers-stephens-micro-2017)
- John G. Edenhofner: [papers/siegel:sc:2015](#papers-siegel-sc-2015)
- Petros Efstathopoulos: [papers/efstathopoulos:sosp:2005](#papers-efstathopoulos-sosp-2005)
- Manuel Egele: [papers/manes:ieeetse:2019](#papers-manes-ieeetse-2019)
- Eric Eide: [papers/eide:aspse:2001](#papers-eide-aspse-2001), [papers/eide:icse:2002](#papers-eide-icse-2002), [papers/regehr:pldi:2012](#papers-regehr-pldi-2012), [papers/reid:osdi:2000](#papers-reid-osdi-2000)
- Dhammika Elkaduwe: [papers/klein:sosp:2009](#papers-klein-sosp-2009)
- Chucky Ellison: [papers/regehr:pldi:2012](#papers-regehr-pldi-2012)
- Kevin Elphinstone: [papers/klein:sosp:2009](#papers-klein-sosp-2009)
- E. Allen Emerson: [papers/clarke:cacm:2009](#papers-clarke-cacm-2009), [papers/clarke:wlop:1982](#papers-clarke-wlop-1982)
- M. Van Emmerik: [papers/cifuentes:computer:2000](#papers-cifuentes-computer-2000)
- Michael Emmi: [papers/almeida:security:2016](#papers-almeida-security-2016), [papers/rakamaric:cav:2014](#papers-rakamaric-cav-2014)
- Kai Engelhardt: [papers/klein:sosp:2009](#papers-klein-sosp-2009)
- Dawson Engler: [papers/cadar:osdi:2008](#papers-cadar-osdi-2008)
- Michael Epstein: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Johan Eriksson: [papers/lindner:indin:2019](#papers-lindner-indin-2019)
- Michael D. Ernst: [papers/ernst:icse:2016](#papers-ernst-icse-2016), [papers/weitz:icfp:2017](#papers-weitz-icfp-2017)
- Gerben Essink: [papers/wolf:codes:2004](#papers-wolf-codes-2004)
- Mbou Eyole: [papers/boettcher:date:2014](#papers-boettcher-date-2014), [papers/stephens:micro:2017](#papers-stephens-micro-2017)
- Brandon Falk: [papers/bohme2:fse:2020](#papers-bohme2-fse-2020)
- Stephan Falke: [papers/merz:vstte:2012](#papers-merz-vstte-2012)
- Adin D. Falkoff: [papers/falkoff:ibm:1964](#papers-falkoff-ibm-1964)
- Chris Fallin: [papers/kim:isca:2014](#papers-kim-isca-2014)
- Keith I. Farkas: [papers/kumar:isca:2004](#papers-kumar-isca-2004)
- Joseph Fasel: [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999)
- Andreas Fauth: [papers/fauth:edtc:1995](#papers-fauth-edtc-1995)
- Siji Feng: [papers/shoshitaishvili:sp:2016](#papers-shoshitaishvili-sp-2016)
- Mary F. Fernández: [papers/fernandez:icse:1997](#papers-fernandez-icse-1997), [papers/ramsey:toplas:1997](#papers-ramsey-toplas-1997)
- Andrew Ferraiuolo: [papers/ferraiuolo:asplos:2017](#papers-ferraiuolo-asplos-2017), [papers/ferraiuolo:ccs:2018](#papers-ferraiuolo-ccs-2018), [papers/ferraiuolo:dac:2017](#papers-ferraiuolo-dac-2017), [papers/ferraiuolo:sosp:2017](#papers-ferraiuolo-sosp-2017), [papers/liu:cpsspc:2018](#papers-liu-cpsspc-2018)
- Renato Ferreira: [papers/du:sc:2003](#papers-du-sc-2003)
- Andrew Fikes: [papers/chang:tocs:2012](#papers-chang-tocs-2012), [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Daniele Filaretti: [papers/bodin:popl:2014](#papers-bodin-popl-2014)
- Jean-Christophe Filliâtre: [papers/filliatre:cav:2007](#papers-filliatre-cav-2007), [papers/filliatre:esop:2013](#papers-filliatre-esop-2013), [papers/filliatre:fem:2004](#papers-filliatre-fem-2004)
- Sigbjorn Finne: [papers/chakravarty:haskffi:2003](#papers-chakravarty-haskffi-2003)
- Irene Finocchi: [papers/baldoni:compsurv:2018](#papers-baldoni-compsurv-2018)
- Bernd Fischer: [papers/fischer:ase:2013](#papers-fischer-ase-2013)
- Joseph A. Fisher: [papers/fisher:isca:1983](#papers-fisher-isca-1983)
- Nils Fitinghoff: [papers/lindner:indin:2019](#papers-lindner-indin-2019)
- Matthew Flatt: [papers/eide:aspse:2001](#papers-eide-aspse-2001), [papers/reid:osdi:2000](#papers-reid-osdi-2000)
- Krisztián Flautner: [papers/lin:sdr:2006](#papers-lin-sdr-2006), [papers/lin:sips:2006](#papers-lin-sips-2006), [papers/reid:cases:2008](#papers-reid-cases-2008), [papers/woh:micro:2008](#papers-woh-micro-2008)
- Shaked Flur: [papers/armstrong:arw:2018](#papers-armstrong-arw-2018), [papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019), [papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019), [papers/flur:popl:2016](#papers-flur-popl-2016)
- Michael J. Flynn: [papers/flynn:ieeeproc:1966](#papers-flynn-ieeeproc-1966)
- Pedro Fonseca: [papers/fonseca:ecs:2017](#papers-fonseca-ecs-2017)
- Pascal Fontaine: [papers/barrett:mlf:2015](#papers-barrett-mlf-2015), [papers/barrett:smtlib:2016](#papers-barrett-smtlib-2016)
- Anthony C. J. Fox: [papers/fox:cambridge:2001](#papers-fox-cambridge-2001), [papers/fox:itp:2010](#papers-fox-itp-2010), [papers/fox:itp:2012](#papers-fox-itp-2012), [papers/fox:itps:2015](#papers-fox-itps-2015), [papers/fox:tphols:2003](#papers-fox-tphols-2003), [papers/fox:ucam:2002](#papers-fox-ucam-2002), [papers/loow:pldi:2019](#papers-loow-pldi-2019), [papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020)
- Jason Franklin: [papers/franklin:cmu:2008](#papers-franklin-cmu-2008)
- Marita Franzke: [papers/rieman:chi:1995](#papers-rieman-chi-1995)
- Christopher W. Fraser: [papers/fraser:sigart:1977](#papers-fraser-sigart-1977)
- Louis Fredriksen: [papers/miller:cacm:1990](#papers-miller-cacm-1990)
- Markus Freericks: [papers/fauth:edtc:1995](#papers-fauth-edtc-1995)
- Jon French: [papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019), [papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019)
- Cliff Frey: [papers/efstathopoulos:sosp:2005](#papers-efstathopoulos-sosp-2005)
- Marcelo F. Frias: [papers/frias:icse:2005](#papers-frias-icse-2005)
- Vladimir Frolov: [papers/kaivola:cav:2009](#papers-kaivola-cav-2009)
- Christopher Frost: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- J. J. Furman: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Ariel Fuxman: [papers/fuxman:isre:2001](#papers-fuxman-isre-2001)
- Ignacio Fábregas: [papers/nanevski:oopsla:2019](#papers-nanevski-oopsla-2019)
- Manuel Fähndrich: [papers/barnett:cacm:2011](#papers-barnett-cacm-2011), [papers/barnett:vstte:2005](#papers-barnett-vstte-2005), [papers/deline:pldi:2001](#papers-deline-pldi-2001), [papers/fahndrich:foveoos:2010](#papers-fahndrich-foveoos-2010)
- Marco Gaboardi: [papers/pierce:book:2016](#papers-pierce-book-2016)
- Giacomo Gabrielli: [papers/boettcher:date:2014](#papers-boettcher-date-2014), [papers/stephens:micro:2017](#papers-stephens-micro-2017)
- Mikhail R. Gadelha: [papers/monteiro:arxiv:2019](#papers-monteiro-arxiv-2019)
- Juan P. Galeotti: [papers/frias:icse:2005](#papers-frias-icse-2005)
- Jacek Galowicz: [papers/becker:fm:2016](#papers-becker-fm-2016)
- Peter Gammie: [papers/murray:secpriv:2013](#papers-murray-secpriv-2013)
- Edward Gan: [papers/morrisett:pldi:2012](#papers-morrisett-pldi-2012)
- Dennis Gannon: [papers/veldhuizen:oo:1998](#papers-veldhuizen-oo-1998)
- Xin Gao: [papers/murray:secpriv:2013](#papers-murray-secpriv-2013)
- Philippa Gardner: [papers/bodin:popl:2014](#papers-bodin-popl-2014), [papers/dinsdale-young:popl:2013](#papers-dinsdale-young-popl-2013)
- Pranav Garg: [papers/garg:icse:2013](#papers-garg-icse-2013)
- David Gay: [papers/gay:pldi:2003](#papers-gay-pldi-2003)
- Qian Ge: [papers/cock:ccs:2014](#papers-cock-ccs-2014), [papers/ge:jce:2016](#papers-ge-jce-2016)
- Jaco Geldenhuys: [papers/visser:tacas:2020](#papers-visser-tacas-2020)
- Y. Serhan Gener: [papers/deng:hasp:2019](#papers-deng-hasp-2019)
- Daniel Genkin: [papers/kocher:arxiv:2018](#papers-kocher-arxiv-2018), [papers/lipp:arxiv:2018](#papers-lipp-arxiv-2018)
- Vlad Georgescu: [papers/chipounov:hotdep:2009](#papers-chipounov-hotdep-2009)
- Sanjay Ghemawat: [papers/chang:tocs:2012](#papers-chang-tocs-2012), [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Branden Ghena: [papers/levy:apsys:2017](#papers-levy-apsys-2017), [papers/levy:plos:2015](#papers-levy-plos-2015), [papers/levy:sosp:2017](#papers-levy-sosp-2017)
- Soumava Ghosh: [papers/goel:fmcad:2014](#papers-goel-fmcad-2014)
- Rajnish Ghughal: [papers/kaivola:cav:2009](#papers-kaivola-cav-2009), [papers/kirankumar:fmcad:2012](#papers-kirankumar-fmcad-2012)
- Daniel B. Giffin: [papers/levy:sosp:2017](#papers-levy-sosp-2017)
- David Gilday: [papers/reid:cav:2016](#papers-reid-cav-2016), [papers/stewart:difts:2014](#papers-stewart-difts-2014)
- John Gill: [papers/hennessy:micro:1982](#papers-hennessy-micro-1982)
- Milind Girkar: [papers/wang:pldi:2007](#papers-wang-pldi-2007)
- Neal Glew: [papers/morrisett:wcsss:1999](#papers-morrisett-wcsss-1999)
- Patrice Godefroid: [papers/godefroid:acmq:2012](#papers-godefroid-acmq-2012), [papers/godefroid:bugs:2005](#papers-godefroid-bugs-2005), [papers/godefroid:cacm:2020](#papers-godefroid-cacm-2020), [papers/godefroid:pldi:2005](#papers-godefroid-pldi-2005), [papers/godefroid:pldi:2012](#papers-godefroid-pldi-2012)
- Shilpi Goel: [papers/goel:acl2:2013](#papers-goel-acl2-2013), [papers/goel:fmcad:2014](#papers-goel-fmcad-2014), [papers/goel:pcs:2017](#papers-goel-pcs-2017), [papers/goel:phd:2016](#papers-goel-phd-2016)
- Jeffrey van Gogh: [papers/sadowski:icse:2015](#papers-sadowski-icse-2015)
- Joseph A. Goguen: [papers/goguen:secpriv:1982](#papers-goguen-secpriv-1982), [papers/goguen:secpriv:1984](#papers-goguen-secpriv-1984)
- Peter Goodman: [papers/goodman:ndss:2018](#papers-goodman-ndss-2018)
- Robert L. Gordon: [papers/barbacci:afips:1977](#papers-barbacci-afips-1977)
- Andrew Gordon: [papers/boulton:tpcd:1993](#papers-boulton-tpcd-1993)
- Michael J. C. Gordon: [papers/boulton:tpcd:1993](#papers-boulton-tpcd-1993), [papers/myreen:tphols:2009](#papers-myreen-tphols-2009)
- Michael I. Gordon: [papers/gordon:asplos:2002](#papers-gordon-asplos-2002)
- Pronnoy Goswami: [papers/tahat:fmcad:2019](#papers-tahat-fmcad-2019)
- Claire Le Goues: [papers/legoues:sefm:2011](#papers-legoues-sefm-2011)
- Paul Govereau: [papers/nanevski:icfp:2008](#papers-nanevski-icfp-2008)
- Kathryn E. Gray: [papers/armstrong:arw:2018](#papers-armstrong-arw-2018), [papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019), [papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019), [papers/flur:popl:2016](#papers-flur-popl-2016), [papers/gray:micro:2015](#papers-gray-micro-2015)
- Thomas R. G. Green: [papers/green:pandc:1990](#papers-green-pandc-1990), [papers/green:tutorial:1998](#papers-green-tutorial-1998)
- Michael Greenberg: [papers/pierce:book:2016](#papers-pierce-book-2016)
- David A. Greve: [papers/greve:fmcad:1998](#papers-greve-fmcad-1998)
- Alberto Griggio: [papers/nyxbrain:sc2:2017](#papers-nyxbrain-sc2-2017)
- Edmund Grimley-Evans: [papers/reid:cases:2008](#papers-reid-cases-2008)
- Rebecca E. Grinter: [papers/smetters:nspw:2002](#papers-smetters-nspw-2002)
- Alex Groce: [papers/goodman:ndss:2018](#papers-goodman-ndss-2018), [papers/groce:issta:2017](#papers-groce-issta-2017), [papers/zhang:issta:2014](#papers-zhang-issta-2014)
- John Grosen: [papers/shoshitaishvili:sp:2016](#papers-shoshitaishvili-sp-2016), [papers/stephens:ndss:2016](#papers-stephens-ndss-2016)
- Thomas R. Gross: [papers/gross:micro:2016](#papers-gross-micro-2016), [papers/hennessy:micro:1982](#papers-hennessy-micro-1982), [papers/subhlok:ppopp:1993](#papers-subhlok-ppopp-1993)
- Dan Grossman: [papers/grossman:esop:2002](#papers-grossman-esop-2002), [papers/morrisett:wcsss:1999](#papers-morrisett-wcsss-1999), [papers/zorn:iscawddd:2017](#papers-zorn-iscawddd-2017)
- Robert E. Gruber: [papers/chang:tocs:2012](#papers-chang-tocs-2012)
- Orna Grumberg: [papers/clarke:cav:2000](#papers-clarke-cav-2000)
- Daniel Gruss: [papers/kocher:arxiv:2018](#papers-kocher-arxiv-2018), [papers/lipp:arxiv:2018](#papers-lipp-arxiv-2018)
- Benjamin Grégoire: [papers/barthe:iacr:2007](#papers-barthe-iacr-2007)
- Ronghui Gu: [papers/costanzo:pldi:2016](#papers-costanzo-pldi-2016), [papers/gu:osdi:2016](#papers-gu-osdi-2016), [papers/nelson:sosp:2019](#papers-nelson-sosp-2019)
- Roberto Guanciale: [papers/dam:ted:2013](#papers-dam-ted-2013), [papers/dam:trusted:2013](#papers-dam-trusted-2013)
- Andrey Gubarev: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Aarti Gupta: [papers/garg:icse:2013](#papers-garg-icse-2013), [papers/huang:todaes:2019](#papers-huang-todaes-2019), [papers/zhang:fmcad:2018](#papers-zhang-fmcad-2018)
- Arpan Gupta: [papers/kirankumar:fmcad:2012](#papers-kirankumar-fmcad-2012)
- Saurabh Gupta: [papers/sharma:pls:2013](#papers-sharma-pls-2013)
- Arie Gurfinkel: [papers/gurfinkel:cav:2015](#papers-gurfinkel-cav-2015)
- Samuel Z. Guyer: [papers/guyer:dsl:1999](#papers-guyer-dsl-1999)
- Doğuhan Gümüşoğlu: [papers/deng:hasp:2019](#papers-deng-hasp-2019)
- Werner Haas: [papers/kocher:arxiv:2018](#papers-kocher-arxiv-2018), [papers/lipp:arxiv:2018](#papers-lipp-arxiv-2018)
- Brian Hackett: [papers/condit:popl:2009](#papers-condit-popl-2009), [papers/xie:bugs:2005](#papers-xie-bugs-2005)
- Liana Hadarean: [papers/barrett:cav:2011](#papers-barrett-cav-2011), [papers/stump:fmsd:2013](#papers-stump-fmsd-2013)
- Gregory D. Hager: [papers/peterson:padl:2001](#papers-peterson-padl-2001), [papers/reid:icse:1999](#papers-reid-icse-1999)
- Constantine Halatsis: [papers/dam:ieeetc:1981](#papers-dam-ieeetc-1981)
- Mike Hamburg: [papers/kocher:arxiv:2018](#papers-kocher-arxiv-2018), [papers/lipp:arxiv:2018](#papers-lipp-arxiv-2018)
- Kevin Hammond: [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999)
- HyungSeok Han: [papers/manes:ieeetse:2019](#papers-manes-ieeetse-2019)
- Choongwoo Han: [papers/manes:ieeetse:2019](#papers-manes-ieeetse-2019)
- Ben Hardekopf: [papers/tiwari:isca:2011](#papers-tiwari-isca-2011)
- David S. Hardin: [papers/hardin:acl2:2006](#papers-hardin-acl2-2006)
- David Harel: [papers/damm:fmoods:1999](#papers-damm-fmoods-1999)
- Bharath Hariharan: [papers/sharma:pls:2013](#papers-sharma-pls-2013)
- Mark Harman: [papers/barr:tse:2015](#papers-barr-tse-2015)
- Robert Harper: [papers/xi:icfp:2001](#papers-xi-icfp-2001)
- John Harrison: [papers/boulton:tpcd:1993](#papers-boulton-tpcd-1993)
- Luddy Harrison: [papers/dai:pldi:2005](#papers-dai-pldi-2005)
- Adrian Harwood: [papers/mavin:isre:2009](#papers-mavin-isre-2009)
- John Hatcliff: [papers/hatcliff:compsurv:2012](#papers-hatcliff-compsurv-2012)
- Christophe Hauser: [papers/shoshitaishvili:sp:2016](#papers-shoshitaishvili-sp-2016)
- Chris Hawblitzel: [papers/ferraiuolo:sosp:2017](#papers-ferraiuolo-sosp-2017), [papers/hawblitzel:osdi:2014](#papers-hawblitzel-osdi-2014), [papers/yang:pldi:2010](#papers-yang-pldi-2010)
- Shaobo He: [papers/baranowski:atva:2018](#papers-baranowski-atva-2018)
- Liang He: [papers/tremblay:micro:1996](#papers-tremblay-micro-1996)
- Eric C. R. Hehner: [papers/hehner:vstte:2008](#papers-hehner-vstte-2008)
- Gernot Heiser: [papers/amani:asplos:2016](#papers-amani-asplos-2016), [papers/cock:ccs:2014](#papers-cock-ccs-2014), [papers/ge:jce:2016](#papers-ge-jce-2016), [papers/klein:sosp:2009](#papers-klein-sosp-2009)
- Christopher Heiser: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Claude Helmstetter: [papers/blanqui:rapido:2011](#papers-blanqui-rapido-2011)
- Fergus Henderson: [papers/chakravarty:haskffi:2003](#papers-chakravarty-haskffi-2003), [papers/jones:pldi:1999](#papers-jones-pldi-1999)
- John L. Hennessy: [papers/gross:micro:2016](#papers-gross-micro-2016), [papers/hennessy:book:2011](#papers-hennessy-book-2011), [papers/hennessy:micro:1982](#papers-hennessy-micro-1982)
- Tomas Henriksson: [papers/wolf:codes:2004](#papers-wolf-codes-2004)
- Ulrich Hensel: [papers/becker:fm:2016](#papers-becker-fm-2016)
- Thomas A. Henzinger: [papers/beyer:ijsttt:2007](#papers-beyer-ijsttt-2007), [papers/beyer:sas:2004](#papers-beyer-sas-2004), [papers/henzinger:spin:2003](#papers-henzinger-spin-2003)
- John Herbert: [papers/boulton:tpcd:1993](#papers-boulton-tpcd-1993)
- Philippe Herrmann: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- Stefan Heule: [papers/heule:ftfjp:2011](#papers-heule-ftfjp-2011), [papers/heule:pldi:2016](#papers-heule-pldi-2016), [papers/heule:vmcai:2013](#papers-heule-vmcai-2013), [papers/weitz:icfp:2017](#papers-weitz-icfp-2017)
- Mike Hibler: [papers/spencer:security:1999](#papers-spencer-security-1999)
- J. Thomas Higgins: [papers/higgins:hldvt:2004](#papers-higgins-hldvt-2004)
- Fredrick J. Hill: [papers/chu:ieeedtc:1992](#papers-chu-ieeedtc-1992)
- Mark A. Hillebrand: [papers/alkassar:vstte:2010](#papers-alkassar-vstte-2010)
- Ralf Hinze: [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999)
- Yoichi Hirai: [papers/becker:fm:2016](#papers-becker-fm-2016)
- Alex Hixon: [papers/amani:asplos:2016](#papers-amani-asplos-2016)
- C. A. R. Hoare: [papers/jones:microsoft:2001](#papers-jones-microsoft-2001), [papers/jones:pldi:1999](#papers-jones-pldi-1999)
- Aquinas Hobor: [papers/hobor:popl:2013](#papers-hobor-popl-2013)
- Peter Hochschild: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Henry Hoffmann: [papers/gordon:asplos:2002](#papers-gordon-asplos-2002)
- Michael Hohmuth: [papers/hohmuth:plos:2005](#papers-hohmuth-plos-2005), [papers/hohmuth:sigops:2002](#papers-hohmuth-sigops-2002)
- Josie Holmes: [papers/groce:issta:2017](#papers-groce-issta-2017)
- Andreas Holzer: [papers/holzer:cav:2008](#papers-holzer-cav-2008), [papers/holzer:hvc:2010](#papers-holzer-hvc-2010)
- Mark Horowitz: [papers/lie:secpri:2003](#papers-lie-secpri-2003), [papers/lie:sosp:2003](#papers-lie-sosp-2003)
- Matt Horsnell: [papers/stephens:micro:2017](#papers-stephens-micro-2017)
- Brad Hosler: [papers/djordjevic:cj:1985](#papers-djordjevic-cj-1985)
- Falk Howar: [papers/dimjasevic:ifm:2018](#papers-dimjasevic-ifm-2018)
- Rosemary Howbrigg: [papers/barbacci:afips:1977](#papers-barbacci-afips-1977)
- Jon Howell: [papers/hawblitzel:osdi:2014](#papers-hawblitzel-osdi-2014)
- David Hoyes: [papers/reid:cav:2016](#papers-reid-cav-2016)
- Cătǎlin Hriţcu: [papers/hritcu:icfp:2013](#papers-hritcu-icfp-2013), [papers/pierce:book:2016](#papers-pierce-book-2016)
- Wilson C. Hsieh: [papers/chang:tocs:2012](#papers-chang-tocs-2012), [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Wei Hu: [papers/oberg:dac:2010](#papers-oberg-dac-2010)
- Weizhe Hua: [papers/ferraiuolo:dac:2017](#papers-ferraiuolo-dac-2017)
- Bo Huang: [papers/dai:pldi:2005](#papers-dai-pldi-2005)
- Bo-Yuan Huang: [papers/huang:todaes:2019](#papers-huang-todaes-2019)
- Paul Hudak: [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999), [papers/li:tocs:1989](#papers-li-tocs-1989), [papers/peterson:padl:2001](#papers-peterson-padl-2001), [papers/reid:icse:1999](#papers-reid-icse-1999)
- Gérard Huet: [papers/coquand:eurocal:1985](#papers-coquand-eurocal-1985)
- John Hughes: [papers/claessen:icfp:2000](#papers-claessen-icfp-2000), [papers/hritcu:icfp:2013](#papers-hritcu-icfp-2013), [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999)
- Marieke Huisman: [papers/blom:ijsttt:2015](#papers-blom-ijsttt-2015)
- Sebastian Hunt: [papers/clark:entcs:2002](#papers-clark-entcs-2002)
- Ray Hunt: [papers/pearce:compsurv:2013](#papers-pearce-compsurv-2013)
- IEEE: [papers/systemverilog:ieee:2013](#papers-systemverilog-ieee-2013)
- Berkin Ilbeyi: [papers/lockhart:ispass:2015](#papers-lockhart-ispass-2015)
- Omar Inverso: [papers/fischer:ase:2013](#papers-fischer-ase-2013)
- Ali Irturk: [papers/oberg:dac:2010](#papers-oberg-dac-2010)
- Samin Ishtiaq: [papers/chong:asplos:2008](#papers-chong-asplos-2008)
- Alexander Ivanov: [papers/liu:cpsspc:2018](#papers-liu-cpsspc-2018)
- Franjo Ivančić: [papers/babic:fse:2019](#papers-babic-fse-2019), [papers/garg:icse:2013](#papers-garg-icse-2013)
- Kenneth E. Iverson: [papers/falkoff:ibm:1964](#papers-falkoff-ibm-1964)
- Thomas Jablin: [papers/bridges:micro:2007](#papers-bridges-micro-2007)
- Daniel Jackson: [papers/jackson:tosem:2002](#papers-jackson-tosem-2002)
- Christian Jacobi: [papers/beyer:ijsttt:2006](#papers-beyer-ijsttt-2006)
- Bart Jacobs: [papers/barnett:fmco:2005](#papers-barnett-fmco-2005), [papers/barnett:vstte:2005](#papers-barnett-vstte-2005), [papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011), [papers/jacobs:vstte:2010](#papers-jacobs-vstte-2010), [papers/penninckx:nfm:2012](#papers-penninckx-nfm-2012), [papers/philippaerts:scp:2014](#papers-philippaerts-scp-2014), [papers/smans:ecoop:2009](#papers-smans-ecoop-2009), [papers/smans:fmood:2010](#papers-smans-fmood-2010), [papers/vogels:fmoods:2011](#papers-vogels-fmoods-2011)
- Joshua Jaffe: [papers/kocher:crypto:1999](#papers-kocher-crypto-1999)
- Ciera Jaspan: [papers/sadowski:cacm:2018](#papers-sadowski-cacm-2018), [papers/sadowski:icse:2015](#papers-sadowski-icse-2015)
- Daniel Jasper: [papers/wright:icsm:2013](#papers-wright-icsm-2013)
- Ross Jeffery: [papers/andronick:icse:2012](#papers-andronick-icse-2012)
- Somesh Jha: [papers/clarke:cav:2000](#papers-clarke-cav-2000)
- Ranjit Jhala: [papers/beyer:ijsttt:2007](#papers-beyer-ijsttt-2007), [papers/beyer:sas:2004](#papers-beyer-sas-2004), [papers/henzinger:spin:2003](#papers-henzinger-spin-2003), [papers/jhala:cav:2001](#papers-jhala-cav-2001), [papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009)
- Limin Jia: [papers/vasudevan:secpriv:2013](#papers-vasudevan-secpriv-2013), [papers/vasudevan:usenix:2016](#papers-vasudevan-usenix-2016)
- Hong Jiang: [papers/wang:pldi:2007](#papers-wang-pldi-2007)
- Alexandre Joannou: [papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020)
- Kristofer Johannisson: [papers/burke:lacl:2005](#papers-burke-lacl-2005)
- Bill Johnson: [papers/chu:ieeedtc:1992](#papers-chu-ieeedtc-1992)
- Kirk L. Johnson: [papers/johnson:osr:1995](#papers-johnson-osr-1995)
- Dylan Johnson: [papers/nelson:sosp:2017](#papers-nelson-sosp-2017)
- Thomas Johnsson: [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999)
- Vania Joloboff: [papers/blanqui:rapido:2011](#papers-blanqui-rapido-2011)
- Robert B. Jones: [papers/aagaard:charme:2001](#papers-aagaard-charme-2001), [papers/aagaard:fmcad:2000](#papers-aagaard-fmcad-2000)
- Simon L. Peyton Jones: [papers/chakravarty:haskffi:2003](#papers-chakravarty-haskffi-2003), [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999), [papers/jones:hw:1997](#papers-jones-hw-1997), [papers/jones:microsoft:2001](#papers-jones-microsoft-2001), [papers/jones:pldi:1999](#papers-jones-pldi-1999)
- Mark Jones: [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999)
- J. Joosten: [papers/dam:ieeetc:1981](#papers-dam-ieeetc-1981)
- Rajeev Joshi: [papers/joshi:pldi:2002](#papers-joshi-pldi-2002)
- Sarang Joshi: [papers/tahat:fmcad:2019](#papers-tahat-fmcad-2019)
- Norman P. Jouppi: [papers/gross:micro:2016](#papers-gross-micro-2016), [papers/hennessy:micro:1982](#papers-hennessy-micro-1982), [papers/kumar:isca:2004](#papers-kumar-isca-2004)
- Jacques-Henri Jourdan: [papers/jung:popl:2017](#papers-jung-popl-2017)
- Dejan Jovanović: [papers/barrett:cav:2011](#papers-barrett-cav-2011)
- Warren A. Hunt Jr.: [papers/albin:cli:1995](#papers-albin-cli-1995), [papers/bevier:jar:1989](#papers-bevier-jar-1989), [papers/goel:acl2:2013](#papers-goel-acl2-2013), [papers/goel:fmcad:2014](#papers-goel-fmcad-2014), [papers/goel:pcs:2017](#papers-goel-pcs-2017), [papers/hunt:jar:1989](#papers-hunt-jar-1989), [papers/hunt:lncs:1994](#papers-hunt-lncs-1994), [papers/hunt:micro:1999](#papers-hunt-micro-1999), [papers/kaufmann:utaustin:2012](#papers-kaufmann-utaustin-2012), [papers/slobodova:memocode:2011](#papers-slobodova-memocode-2011)
- Benjamin Jun: [papers/kocher:crypto:1999](#papers-kocher-crypto-1999)
- Ralf Jung: [papers/jung:popl:2017](#papers-jung-popl-2017), [papers/jung:popl:2020](#papers-jung-popl-2020)
- M. Frans Kaashoek: [papers/dabek:sigops:2002](#papers-dabek-sigops-2002), [papers/efstathopoulos:sosp:2005](#papers-efstathopoulos-sosp-2005), [papers/johnson:osr:1995](#papers-johnson-osr-1995), [papers/krohn:sosp:2007](#papers-krohn-sosp-2007)
- Temesghen Kahsai: [papers/gurfinkel:cav:2015](#papers-gurfinkel-cav-2015)
- Roope Kaivola: [papers/kaivola:cav:2009](#papers-kaivola-cav-2009)
- Konstantinos Kallas: [papers/chong:icse:2020](#papers-chong-icse-2020)
- Jeehoon Kang: [papers/jung:popl:2020](#papers-jung-popl-2020)
- Sebastian Kanthak: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Michal Karczmarek: [papers/gordon:asplos:2002](#papers-gordon-asplos-2002), [papers/thies:ppopp:2005](#papers-thies-ppopp-2005)
- Ioannis T. Kassios: [papers/kassios:fm:2006](#papers-kassios-fm-2006)
- Ryan Kastner: [papers/oberg:dac:2010](#papers-oberg-dac-2010), [papers/tiwari:isca:2011](#papers-tiwari-isca-2011)
- Matt Kaufmann: [papers/goel:acl2:2013](#papers-goel-acl2-2013), [papers/goel:fmcad:2014](#papers-goel-fmcad-2014), [papers/goel:pcs:2017](#papers-goel-pcs-2017), [papers/kaufmann:ieeetse:1997](#papers-kaufmann-ieeetse-1997), [papers/kaufmann:utaustin:2012](#papers-kaufmann-utaustin-2012)
- Will Keen: [papers/reid:cav:2016](#papers-reid-cav-2016)
- Stephen Kell: [papers/bastian:oopsla:2019](#papers-bastian-oopsla-2019)
- Kevin Kellar: [papers/groce:issta:2017](#papers-groce-issta-2017)
- Gabriele Keller: [papers/amani:asplos:2016](#papers-amani-asplos-2016)
- M. Erkan Keremoglu: [papers/beyer:cav:2011](#papers-beyer-cav-2011)
- Gabriel Kerneis: [papers/gray:micro:2015](#papers-gray-micro-2015)
- Danny Kershaw: [papers/woh:micro:2008](#papers-woh-micro-2008)
- Narges Khakpour: [papers/khakpour:cpp:2013](#papers-khakpour-cpp-2013)
- Kareem Khazem: [papers/chong:icse:2020](#papers-chong-icse-2020), [papers/cook:cav:2018](#papers-cook-cav-2018)
- Gregor Kiczales: [papers/kiczales:iwoos:1991](#papers-kiczales-iwoos-1991)
- Jieung Kim: [papers/gu:osdi:2016](#papers-gu-osdi-2016)
- Yoongu Kim: [papers/kim:isca:2014](#papers-kim-isca-2014)
- Jeremie Kim: [papers/kim:isca:2014](#papers-kim-isca-2014)
- Tim King: [papers/babic:fse:2019](#papers-babic-fse-2019), [papers/barrett:cav:2011](#papers-barrett-cav-2011)
- Samuel Talmadge King: [papers/mai:asplos:2013](#papers-mai-asplos-2013)
- V. M. Achutha KiranKumar: [papers/kirankumar:fmcad:2012](#papers-kirankumar-fmcad-2012)
- Florent Kirchner: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- Steve Klabnik: [papers/klabnik:book:2018](#papers-klabnik-book-2018)
- Nils Klarlund: [papers/godefroid:pldi:2005](#papers-godefroid-pldi-2005)
- Gerwin Klein: [papers/amani:asplos:2016](#papers-amani-asplos-2016), [papers/andronick:icse:2012](#papers-andronick-icse-2012), [papers/klein:sosp:2009](#papers-klein-sosp-2009), [papers/murray:secpriv:2013](#papers-murray-secpriv-2013), [papers/sewell:pldi:2013](#papers-sewell-pldi-2013)
- Manuel Klimek: [papers/wright:icsm:2013](#papers-wright-icsm-2013)
- Naoki Kobayashi: [papers/matsushita:esop:2020](#papers-matsushita-esop-2020)
- Paul Kocher: [papers/kocher:arxiv:2018](#papers-kocher-arxiv-2018), [papers/kocher:crypto:1999](#papers-kocher-crypto-1999), [papers/lipp:arxiv:2018](#papers-lipp-arxiv-2018)
- Erwin A. de Kock: [papers/wolf:codes:2004](#papers-wolf-codes-2004)
- Eugene Kogan: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Eng Kiat Koh: [papers/ananda:osr:1992](#papers-ananda-osr-1992)
- Eddie Kohler: [papers/efstathopoulos:sosp:2005](#papers-efstathopoulos-sosp-2005), [papers/krohn:sosp:2007](#papers-krohn-sosp-2007), [papers/zeldovich:osdi:2006](#papers-zeldovich-osdi-2006)
- Rafal Kolanski: [papers/andronick:icse:2012](#papers-andronick-icse-2012), [papers/klein:sosp:2009](#papers-klein-sosp-2009)
- Anvesh Komuravelli: [papers/gurfinkel:cav:2015](#papers-gurfinkel-cav-2015)
- Soonho Kong: [papers/demoura:cade:2015](#papers-demoura-cade-2015)
- Nikolai Kosmatov: [papers/blanchard:fmics:2015](#papers-blanchard-fmics-2015), [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012), [papers/mangano:crisis:2016](#papers-mangano-crisis-2016)
- Mikhail Kovalev: [papers/alkassar:vstte:2012](#papers-alkassar-vstte-2012)
- Marcin Kowalczyk: [papers/chakravarty:haskffi:2003](#papers-chakravarty-haskffi-2003)
- Christoforos Kozyrakis: [papers/kozyrakis:phd:2002](#papers-kozyrakis-phd-2002)
- Robbert Krebbers: [papers/jung:popl:2017](#papers-jung-popl-2017)
- Shriram Krishnamurthi: [papers/krishnamurthi:fm:2019](#papers-krishnamurthi-fm-2019)
- Arvind Krishnamurthy: [papers/fonseca:ecs:2017](#papers-fonseca-ecs-2017)
- Neel R. Krishnaswami: [papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019), [papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019), [papers/krishnaswami:tldi:2010](#papers-krishnaswami-tldi-2010)
- Daniel Kroening: [papers/clarke:tacas:2004](#papers-clarke-tacas-2004), [papers/cook:cav:2018](#papers-cook-cav-2018), [papers/kroening:dac:2001](#papers-kroening-dac-2001), [papers/kroening:itg:2000](#papers-kroening-itg-2000)
- Maxwell Krohn: [papers/efstathopoulos:sosp:2005](#papers-efstathopoulos-sosp-2005), [papers/krohn:sosp:2007](#papers-krohn-sosp-2007)
- Christopher Kruegel: [papers/shoshitaishvili:sp:2016](#papers-shoshitaishvili-sp-2016), [papers/stephens:ndss:2016](#papers-stephens-ndss-2016)
- Wido Kruijtzer: [papers/wolf:codes:2004](#papers-wolf-codes-2004)
- Daniel Kröning: [papers/beyer:ijsttt:2006](#papers-beyer-ijsttt-2006)
- Rakesh Kumar: [papers/kumar:isca:2004](#papers-kumar-isca-2004)
- Ramana Kumar: [papers/kumar:popl:2014](#papers-kumar-popl-2014), [papers/loow:pldi:2019](#papers-loow-pldi-2019)
- César Kunz: [papers/becker:fm:2016](#papers-becker-fm-2016)
- Markus Kusano: [papers/babic:fse:2019](#papers-babic-fse-2019)
- Volodymyr Kuznetsov: [papers/chipounov:asplos:2011](#papers-chipounov-asplos-2011), [papers/chipounov:tcs:2012](#papers-chipounov-tcs-2012), [papers/wagner:hotos:2013](#papers-wagner-hotos-2013)
- Ulrich Kühne: [papers/kuhne:fmcad:2010](#papers-kuhne-fmcad-2010)
- Shuvendu K. Lahiri: [papers/chatterjee:tacas:2007](#papers-chatterjee-tacas-2007), [papers/condit:popl:2009](#papers-condit-popl-2009), [papers/lahiri:cav:2003](#papers-lahiri-cav-2003), [papers/lahiri:hldvt:2001](#papers-lahiri-hldvt-2001), [papers/lal:cav:2012](#papers-lal-cav-2012)
- Konrad Lai: [papers/kim:isca:2014](#papers-kim-isca-2014)
- Akash Lal: [papers/lal:cav:2012](#papers-lal-cav-2012), [papers/lal:fse:2014](#papers-lal-fse-2014), [papers/lal:pldi:2015](#papers-lal-pldi-2015)
- Andrew A. Lamb: [papers/gordon:asplos:2002](#papers-gordon-asplos-2002)
- Leslie Lamport: [papers/abadi:tcs:1991](#papers-abadi-tcs-1991)
- Leonidas Lampropoulos: [papers/hritcu:icfp:2013](#papers-hritcu-icfp-2013)
- Vincent Laporte: [papers/barthe:iacr:2007](#papers-barthe-iacr-2007)
- Hugh C. Lauer: [papers/lauer:osr:1979](#papers-lauer-osr-1979)
- John Launchbury: [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999)
- Ben Laurie: [papers/woodruff:isca:2014](#papers-woodruff-isca-2014)
- Gary T. Leavens: [papers/hatcliff:compsurv:2012](#papers-hatcliff-compsurv-2012)
- Ji Hye Lee: [papers/kim:isca:2014](#papers-kim-isca-2014)
- Donghyuk Lee: [papers/kim:isca:2014](#papers-kim-isca-2014)
- Ruby B. Lee: [papers/lee:micro:1996](#papers-lee-micro-1996)
- Chris Leger: [papers/gordon:asplos:2002](#papers-gordon-asplos-2002)
- Daan Leijen: [papers/chakravarty:haskffi:2003](#papers-chakravarty-haskffi-2003)
- Dirk Leinenbach: [papers/beyer:ijsttt:2006](#papers-beyer-ijsttt-2006), [papers/leinenbach:fm:2009](#papers-leinenbach-fm-2009)
- K. Rustan M. Leino: [papers/barnett:cacm:2011](#papers-barnett-cacm-2011), [papers/barnett:cassis:2004](#papers-barnett-cassis-2004), [papers/barnett:fmco:2005](#papers-barnett-fmco-2005), [papers/barnett:vstte:2005](#papers-barnett-vstte-2005), [papers/hatcliff:compsurv:2012](#papers-hatcliff-compsurv-2012), [papers/heule:ftfjp:2011](#papers-heule-ftfjp-2011), [papers/heule:vmcai:2013](#papers-heule-vmcai-2013), [papers/legoues:sefm:2011](#papers-legoues-sefm-2011), [papers/leino:fosad:2007](#papers-leino-fosad-2007), [papers/leino:icse:2013](#papers-leino-icse-2013), [papers/leino:informatics:2001](#papers-leino-informatics-2001), [papers/leino:lpair:2010](#papers-leino-lpair-2010), [papers/leino:sac:2009](#papers-leino-sac-2009), [papers/leino:tacas:2010](#papers-leino-tacas-2010)
- Thomas Lemberger: [papers/beyer:ase:2019](#papers-beyer-ase-2019), [papers/beyer:hvc:2017](#papers-beyer-hvc-2017)
- Matthieu Lemerre: [papers/blanchard:fmics:2015](#papers-blanchard-fmics-2015)
- Caroline Lemieux: [papers/babic:fse:2019](#papers-babic-fse-2019)
- Jay Lepreau: [papers/eide:aspse:2001](#papers-eide-aspse-2001), [papers/eide:icse:2002](#papers-eide-icse-2002), [papers/regehr:rtss:2003](#papers-regehr-rtss-2003), [papers/reid:osdi:2000](#papers-reid-osdi-2000), [papers/spencer:security:1999](#papers-spencer-security-1999)
- Flavio Lerda: [papers/clarke:tacas:2004](#papers-clarke-tacas-2004)
- Xavier Leroy: [papers/leroy:cacm:2009](#papers-leroy-cacm-2009)
- M. Letheren: [papers/dam:ieeetc:1981](#papers-dam-ieeetc-1981)
- Josh Levenberg: [papers/potvin:cacm:2016](#papers-potvin-cacm-2016)
- Michael Y. Levin: [papers/godefroid:acmq:2012](#papers-godefroid-acmq-2012)
- Timothy Levin: [papers/tiwari:isca:2011](#papers-tiwari-isca-2011)
- Philip Levis: [papers/gay:pldi:2003](#papers-gay-pldi-2003), [papers/levy:apsys:2017](#papers-levy-apsys-2017), [papers/levy:plos:2015](#papers-levy-plos-2015), [papers/levy:sosp:2017](#papers-levy-sosp-2017)
- Amit Levy: [papers/levy:apsys:2017](#papers-levy-apsys-2017), [papers/levy:plos:2015](#papers-levy-plos-2015), [papers/levy:sosp:2017](#papers-levy-sosp-2017)
- Corey Lewis: [papers/murray:secpriv:2013](#papers-murray-secpriv-2013)
- Hongyi Li: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Long Li: [papers/dai:pldi:2005](#papers-dai-pldi-2005)
- Kai Li: [papers/li:tocs:1989](#papers-li-tocs-1989)
- Xun Li: [papers/tiwari:isca:2009](#papers-tiwari-isca-2009), [papers/tiwari:isca:2011](#papers-tiwari-isca-2011)
- Percy Liang: [papers/sharma:pls:2013](#papers-sharma-pls-2013)
- David Lie: [papers/lie:secpri:2003](#papers-lie-secpri-2003), [papers/lie:sosp:2003](#papers-lie-sosp-2003)
- Japheth Lim: [papers/amani:asplos:2016](#papers-amani-asplos-2016)
- Jasper Lin: [papers/gordon:asplos:2002](#papers-gordon-asplos-2002)
- Calvin Lin: [papers/guyer:dsl:1999](#papers-guyer-dsl-1999)
- Yuan Lin: [papers/lin:sdr:2006](#papers-lin-sdr-2006), [papers/lin:sips:2006](#papers-lin-sips-2006), [papers/reid:cases:2008](#papers-reid-cases-2008), [papers/woh:micro:2008](#papers-woh-micro-2008)
- Per Lindgren: [papers/lindner:indin:2018](#papers-lindner-indin-2018), [papers/lindner:indin:2019](#papers-lindner-indin-2019)
- Marcus Lindner: [papers/lindner:indin:2018](#papers-lindner-indin-2018), [papers/lindner:indin:2019](#papers-lindner-indin-2019)
- Moritz Lipp: [papers/kocher:arxiv:2018](#papers-kocher-arxiv-2018), [papers/lipp:arxiv:2018](#papers-lipp-arxiv-2018)
- Jed Liu: [papers/liu:cpsspc:2018](#papers-liu-cpsspc-2018)
- Alexander Lloyd: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Derek Lockhart: [papers/lockhart:ispass:2015](#papers-lockhart-ispass-2015)
- Alexey Loginov: [papers/noonan:pldi:2016](#papers-noonan-pldi-2016)
- Francesco Logozzo: [papers/cousot:oopsla:2012](#papers-cousot-oopsla-2012), [papers/fahndrich:foveoos:2010](#papers-fahndrich-foveoos-2010), [papers/logozzo:vmcai:2011](#papers-logozzo-vmcai-2011)
- Florian Lonsing: [papers/brummayer:sat:2010](#papers-brummayer-sat-2010)
- Nuno P. Lopes: [papers/lopes:pldi:2015](#papers-lopes-pldi-2015)
- Jacob R. Lorch: [papers/hawblitzel:osdi:2014](#papers-hawblitzel-osdi-2014)
- Peter Loscocco: [papers/spencer:security:1999](#papers-spencer-security-1999)
- Frédéric Loulergue: [papers/blanchard:fmics:2015](#papers-blanchard-fmics-2015)
- Alberto Lovato: [papers/ernst:icse:2016](#papers-ernst-icse-2016)
- Gavin Lowe: [papers/lowe:csfw:2015](#papers-lowe-csfw-2015)
- Yuan Lu: [papers/clarke:cav:2000](#papers-clarke-cav-2000)
- Corine Lu: [papers/deng:hasp:2019](#papers-deng-hasp-2019)
- Kasper Luckow: [papers/dimjasevic:ifm:2018](#papers-dimjasevic-ifm-2018)
- Guei-Yuan Lueh: [papers/wang:pldi:2007](#papers-wang-pldi-2007)
- Mark Luk: [papers/seshadri:sosp:2007](#papers-seshadri-sosp-2007)
- Mulong Luo: [papers/liu:cpsspc:2018](#papers-liu-cpsspc-2018)
- Ziqing Luo: [papers/siegel:sc:2015](#papers-siegel-sc-2015)
- Daniel Lustig: [papers/lustig:asplos:2016](#papers-lustig-asplos-2016)
- Steven Lyubomirsky: [papers/weitz:icfp:2017](#papers-weitz-icfp-2017)
- Andreas Lööw: [papers/loow:pldi:2019](#papers-loow-pldi-2019)
- David R. MacIver: [papers/maciver:ecoop:2020](#papers-maciver-ecoop-2020)
- Damiano Macedonio: [papers/ernst:icse:2016](#papers-ernst-icse-2016)
- Andrew Macvean: [papers/macvean:ppig:2016](#papers-macvean-ppig-2016)
- Parthasarathy Madhusudan: [papers/mai:asplos:2013](#papers-mai-asplos-2013)
- Naoto Maeda: [papers/garg:icse:2013](#papers-garg-icse-2013)
- Sergio Maffeis: [papers/bodin:popl:2014](#papers-bodin-popl-2014)
- Grigorios Magklis: [papers/stephens:micro:2017](#papers-stephens-micro-2017)
- Scott A. Mahlke: [papers/lin:sdr:2006](#papers-lin-sdr-2006), [papers/lin:sips:2006](#papers-lin-sips-2006), [papers/woh:micro:2008](#papers-woh-micro-2008)
- Haohui Mai: [papers/mai:asplos:2013](#papers-mai-asplos-2013)
- Rupak Majumdar: [papers/ball:pldi:2001](#papers-ball-pldi-2001), [papers/beyer:ijsttt:2007](#papers-beyer-ijsttt-2007), [papers/beyer:sas:2004](#papers-beyer-sas-2004), [papers/henzinger:spin:2003](#papers-henzinger-spin-2003), [papers/jhala:compsurv:2009](#papers-jhala-compsurv-2009)
- Pasquale Malacaria: [papers/clark:entcs:2002](#papers-clark-entcs-2002)
- Sharad Malik: [papers/huang:todaes:2019](#papers-huang-todaes-2019), [papers/malik:cacm:2009](#papers-malik-cacm-2009), [papers/zhang:fmcad:2018](#papers-zhang-fmcad-2018)
- Yatin Manerkar: [papers/zhang:fmcad:2018](#papers-zhang-fmcad-2018)
- Valentin Manes: [papers/bohme:fse:2020](#papers-bohme-fse-2020)
- Frédéric Mangano: [papers/mangano:crisis:2016](#papers-mangano-crisis-2016)
- Stefan Mangard: [papers/kocher:arxiv:2018](#papers-kocher-arxiv-2018), [papers/lipp:arxiv:2018](#papers-lipp-arxiv-2018)
- Petros Maniatis: [papers/martignoni:asplos:2012](#papers-martignoni-asplos-2012), [papers/vasudevan:usenix:2016](#papers-vasudevan-usenix-2016)
- Muhammad Numair Mansur: [papers/mansur:arxiv:2020](#papers-mansur-arxiv-2020)
- Heiko Mantel: [papers/mantel:pls:2007](#papers-mantel-pls-2007), [papers/mantel:sp:2001](#papers-mantel-sp-2001)
- Valentin J.M. Manès: [papers/manes:ieeetse:2019](#papers-manes-ieeetse-2019)
- Luc Maranget: [papers/alglave:toplas:2014](#papers-alglave-toplas-2014), [papers/flur:popl:2016](#papers-flur-popl-2016), [papers/sarkar:pldi:2011](#papers-sarkar-pldi-2011)
- Claude Marché: [papers/filliatre:cav:2007](#papers-filliatre-cav-2007), [papers/filliatre:fem:2004](#papers-filliatre-fem-2004)
- Andre V. Marianiello: [papers/siegel:sc:2015](#papers-siegel-sc-2015)
- Simon Marlow: [papers/chakravarty:haskffi:2003](#papers-chakravarty-haskffi-2003), [papers/jones:pldi:1999](#papers-jones-pldi-1999)
- Lorenzo Martignoni: [papers/martignoni:asplos:2012](#papers-martignoni-asplos-2012)
- Alejandro Martinez: [papers/stephens:micro:2017](#papers-stephens-micro-2017)
- Margaret Martonosi: [papers/lustig:asplos:2016](#papers-lustig-asplos-2016), [papers/zhang:fmcad:2018](#papers-zhang-fmcad-2018)
- Alexia Massalin: [papers/massalin:asplos:1987](#papers-massalin-asplos-1987)
- Daniel Matichuk: [papers/murray:secpriv:2013](#papers-murray-secpriv-2013)
- Yusuke Matsushita: [papers/matsushita:esop:2020](#papers-matsushita-esop-2020)
- Andrea Mattavelli: [papers/braione:icse:2018](#papers-braione-icse-2018)
- Stefan Maus: [papers/maus:amast:2008](#papers-maus-amast-2008)
- Alistair Mavin: [papers/mavin:isre:2009](#papers-mavin-isre-2009)
- David Maze: [papers/gordon:asplos:2002](#papers-gordon-asplos-2002)
- David Mazières: [papers/dabek:sigops:2002](#papers-dabek-sigops-2002), [papers/efstathopoulos:sosp:2005](#papers-efstathopoulos-sosp-2005), [papers/zeldovich:osdi:2006](#papers-zeldovich-osdi-2006)
- Bita Mazloom: [papers/tiwari:asplos:2009](#papers-tiwari-asplos-2009)
- Stephen McCamant: [papers/martignoni:asplos:2012](#papers-martignoni-asplos-2012)
- Jonathan McCune: [papers/vasudevan:secpriv:2013](#papers-vasudevan-secpriv-2013)
- Kenneth L. McMillan: [papers/jhala:cav:2001](#papers-jhala-cav-2001), [papers/mcmillan:cav:1998](#papers-mcmillan-cav-1998), [papers/mcmillan:ecs:2003](#papers-mcmillan-ecs-2003)
- Phil McMinn: [papers/barr:tse:2015](#papers-barr-tse-2015)
- Scott McPeak: [papers/necula:cc:2002](#papers-necula-cc-2002)
- Ross Mcilroy: [papers/mcilroy:arxiv:2019](#papers-mcilroy-arxiv-2019)
- Erik Meijer: [papers/chakravarty:haskffi:2003](#papers-chakravarty-haskffi-2003), [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999)
- Thomas F. Melham: [papers/aagaard:fmcad:2000](#papers-aagaard-fmcad-2000)
- Ali S. Meli: [papers/gordon:asplos:2002](#papers-gordon-asplos-2002)
- Sergey Melnik: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- David Menendez: [papers/lopes:pldi:2015](#papers-lopes-pldi-2015)
- Florian Merz: [papers/merz:vstte:2012](#papers-merz-vstte-2012)
- José Meseguer: [papers/goguen:secpriv:1982](#papers-goguen-secpriv-1982), [papers/goguen:secpriv:1984](#papers-goguen-secpriv-1984)
- Heinrich Meyr: [papers/zivojnovic:vlsi:1996](#papers-zivojnovic-vlsi-1996)
- Barton P. Miller: [papers/miller:cacm:1990](#papers-miller-cacm-1990)
- Liam Miller-Cushon: [papers/sadowski:cacm:2018](#papers-sadowski-cacm-2018)
- Todd Millstein: [papers/ball:pldi:2001](#papers-ball-pldi-2001)
- Robin Milner: [papers/milner:jcss:1978](#papers-milner-jcss-1978)
- Prabhat Mishra: [papers/mishra:book:2008](#papers-mishra-book-2008)
- John C. Mitchell: [papers/lie:secpri:2003](#papers-lie-secpri-2003)
- David Molnar: [papers/godefroid:acmq:2012](#papers-godefroid-acmq-2012)
- Rosemary Monahan: [papers/leino:sac:2009](#papers-leino-sac-2009)
- Benjamin Monate: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- Jean-François Monin: [papers/blanqui:rapido:2011](#papers-blanqui-rapido-2011)
- Felipe R. Monteiro: [papers/chong:icse:2020](#papers-chong-icse-2020), [papers/monteiro:arxiv:2019](#papers-monteiro-arxiv-2019)
- J. Strother Moore: [papers/bevier:jar:1989](#papers-bevier-jar-1989), [papers/kaufmann:ieeetse:1997](#papers-kaufmann-ieeetse-1997)
- Simon W. Moore: [papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020), [papers/woodruff:isca:2014](#papers-woodruff-isca-2014)
- Robert Morris: [papers/dabek:sigops:2002](#papers-dabek-sigops-2002), [papers/efstathopoulos:sosp:2005](#papers-efstathopoulos-sosp-2005), [papers/krohn:sosp:2007](#papers-krohn-sosp-2007)
- Greg Morrisett: [papers/morrisett:pldi:2012](#papers-morrisett-pldi-2012), [papers/morrisett:wcsss:1999](#papers-morrisett-wcsss-1999), [papers/nanevski:icfp:2008](#papers-nanevski-icfp-2008), [papers/smith:esop:2000](#papers-smith-esop-2000), [papers/walker:tic:2001](#papers-walker-tic-2001)
- Michał Moskal: [papers/cohen:cav:2010](#papers-cohen-cav-2010), [papers/cohen:entcs:2009](#papers-cohen-entcs-2009), [papers/legoues:sefm:2011](#papers-legoues-sefm-2011), [papers/maus:amast:2008](#papers-maus-amast-2008)
- Leonardo de Moura: [papers/barrett:mlf:2015](#papers-barrett-mlf-2015), [papers/demoura:cacm:2011](#papers-demoura-cacm-2011), [papers/demoura:cade:2015](#papers-demoura-cade-2015), [papers/demoura:tacas:2008](#papers-demoura-tacas-2008)
- Yannick Moy: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- Trevor N. Mudge: [papers/lin:sdr:2006](#papers-lin-sdr-2006), [papers/lin:sips:2006](#papers-lin-sips-2006), [papers/woh:micro:2008](#papers-woh-micro-2008)
- Silvia Mueller: [papers/kroening:itg:2000](#papers-kroening-itg-2000)
- Robert Mullenix: [papers/lin:sdr:2006](#papers-lin-sdr-2006)
- Dominic P. Mulligan: [papers/gray:micro:2015](#papers-gray-micro-2015)
- Prashanth Mundkur: [papers/armstrong:arw:2018](#papers-armstrong-arw-2018), [papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019), [papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019)
- Toby Murray: [papers/amani:asplos:2016](#papers-amani-asplos-2016), [papers/cock:ccs:2014](#papers-cock-ccs-2014), [papers/murray:secpriv:2013](#papers-murray-secpriv-2013)
- Onur Mutlu: [papers/kim:isca:2014](#papers-kim-isca-2014)
- David Mwaura: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Alan Mycroft: [papers/mycroft:esop:1999](#papers-mycroft-esop-1999)
- Andrew C. Myers: [papers/ferraiuolo:asplos:2017](#papers-ferraiuolo-asplos-2017), [papers/ferraiuolo:ccs:2018](#papers-ferraiuolo-ccs-2018), [papers/ferraiuolo:dac:2017](#papers-ferraiuolo-dac-2017), [papers/liu:cpsspc:2018](#papers-liu-cpsspc-2018), [papers/myers:csfw:2004](#papers-myers-csfw-2004), [papers/zdancewic:csfw:2001](#papers-zdancewic-csfw-2001), [papers/zdancewic:csfw:2003](#papers-zdancewic-csfw-2003), [papers/zhang:asplos:2015](#papers-zhang-asplos-2015)
- John Mylopoulos: [papers/fuxman:isre:2001](#papers-fuxman-isre-2001)
- Magnus O. Myreen: [papers/fox:itp:2010](#papers-fox-itp-2010), [papers/kumar:popl:2014](#papers-kumar-popl-2014), [papers/loow:pldi:2019](#papers-loow-pldi-2019), [papers/myreen:itp:2012](#papers-myreen-itp-2012), [papers/myreen:tphols:2009](#papers-myreen-tphols-2009), [papers/sarkar:popl:2009](#papers-sarkar-popl-2009), [papers/sewell:pldi:2013](#papers-sewell-pldi-2013)
- Shashidhar Mysore: [papers/tiwari:asplos:2009](#papers-tiwari-asplos-2009)
- Jan Tobias Mühlberg: [papers/penninckx:nfm:2012](#papers-penninckx-nfm-2012), [papers/philippaerts:scp:2014](#papers-philippaerts-scp-2014)
- Peter Müller: [papers/astrauskas:oopsla:2019](#papers-astrauskas-oopsla-2019), [papers/barnett:cacm:2011](#papers-barnett-cacm-2011), [papers/hatcliff:compsurv:2012](#papers-hatcliff-compsurv-2012), [papers/heule:ftfjp:2011](#papers-heule-ftfjp-2011), [papers/heule:vmcai:2013](#papers-heule-vmcai-2013), [papers/leino:fosad:2007](#papers-leino-fosad-2007), [papers/muller:vmcai:2016](#papers-muller-vmcai-2016)
- Santosh Nagarakatte: [papers/lopes:pldi:2015](#papers-lopes-pldi-2015)
- Yutaka Nagashima: [papers/amani:asplos:2016](#papers-amani-asplos-2016)
- David Nagle: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Armaghan Naik: [papers/kaivola:cav:2009](#papers-kaivola-cav-2009)
- Mayur Naik: [papers/naik:popl:2012](#papers-naik-popl-2012), [papers/xie:bugs:2005](#papers-xie-bugs-2005)
- Keiko Nakata: [papers/becker:fm:2016](#papers-becker-fm-2016)
- Aleksandar Nanevski: [papers/nanevski:icfp:2008](#papers-nanevski-icfp-2008), [papers/nanevski:oopsla:2019](#papers-nanevski-oopsla-2019)
- Naren Narasimhan: [papers/kaivola:cav:2009](#papers-kaivola-cav-2009)
- Arjun Narayan: [papers/hawblitzel:osdi:2014](#papers-hawblitzel-osdi-2014)
- Vikram Narayanan: [papers/narayanan:hotos:2019](#papers-narayanan-hotos-2019)
- Venkatesh Narayanan: [papers/tremblay:micro:1996](#papers-tremblay-micro-1996)
- Francesco Zappa Nardelli: [papers/bastian:oopsla:2019](#papers-bastian-oopsla-2019), [papers/sarkar:popl:2009](#papers-sarkar-popl-2009)
- Daiva Naudziuniene: [papers/bodin:popl:2014](#papers-bodin-popl-2014)
- David A. Naumann: [papers/naumann:fmco:2004](#papers-naumann-fmco-2004)
- Jorge A. Navas: [papers/gurfinkel:cav:2015](#papers-gurfinkel-cav-2015)
- Matthew Naylor: [papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020)
- George C. Necula: [papers/necula:cc:2002](#papers-necula-cc-2002), [papers/necula:pldi:2000](#papers-necula-pldi-2000), [papers/necula:popl:1997](#papers-necula-popl-1997)
- Roger M. Needham: [papers/lauer:osr:1979](#papers-lauer-osr-1979)
- Bruce Jay Nelson: [papers/birrell:tocs:1984](#papers-birrell-tocs-1984)
- Greg Nelson: [papers/joshi:pldi:2002](#papers-joshi-pldi-2002)
- Tim Nelson: [papers/krishnamurthi:fm:2019](#papers-krishnamurthi-fm-2019)
- Luke Nelson: [papers/nelson:sosp:2017](#papers-nelson-sosp-2017), [papers/nelson:sosp:2019](#papers-nelson-sosp-2019), [papers/sigurbjarnarson:osdi:2018](#papers-sigurbjarnarson-osdi-2018)
- Hamed Nemati: [papers/dam:ted:2013](#papers-dam-ted-2013), [papers/dam:trusted:2013](#papers-dam-trusted-2013)
- Peter G. Neumann: [papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020), [papers/woodruff:isca:2014](#papers-woodruff-isca-2014)
- Daniel Nevill: [papers/stewart:difts:2014](#papers-stewart-difts-2014)
- Allen C. Newell: [papers/barbacci:cmu:1972](#papers-barbacci-cmu-1972), [papers/bell:afips:1970](#papers-bell-afips-1970), [papers/bell:book:1971](#papers-bell-book-1971)
- James Newsome: [papers/vasudevan:secpriv:2013](#papers-vasudevan-secpriv-2013)
- Carol Nichols: [papers/klabnik:book:2018](#papers-klabnik-book-2018)
- Aina Niemetz: [papers/niemetz:jsat:2015](#papers-niemetz-jsat-2015)
- Kyndylan Nienhuis: [papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020)
- Tobias Nipkow: [papers/nipkow:book:2002](#papers-nipkow-book-2002)
- Matt Noonan: [papers/noonan:pldi:2016](#papers-noonan-pldi-2016)
- Thomas Nordin: [papers/jones:hw:1997](#papers-jones-hw-1997)
- Aditya V. Nori: [papers/sharma:pls:2013](#papers-sharma-pls-2013)
- Michael Norrish: [papers/klein:sosp:2009](#papers-klein-sosp-2009), [papers/kumar:popl:2014](#papers-kumar-popl-2014), [papers/loow:pldi:2019](#papers-loow-pldi-2019)
- Robert M. Norton: [papers/armstrong:arw:2018](#papers-armstrong-arw-2018), [papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019), [papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019), [papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020), [papers/woodruff:isca:2014](#papers-woodruff-isca-2014)
- Mark Novak: [papers/mavin:isre:2009](#papers-mavin-isre-2009)
- Liam O'Connor: [papers/amani:asplos:2016](#papers-amani-asplos-2016)
- J. Michael O'Connor: [papers/tremblay:micro:1996](#papers-tremblay-micro-1996)
- David R. O'Hallaron: [papers/subhlok:ppopp:1993](#papers-subhlok-ppopp-1993)
- Peter W. O'Hearn: [papers/berdine:aplas:2005](#papers-berdine-aplas-2005), [papers/berdine:fmco:2005](#papers-berdine-fmco-2005), [papers/bornat:popl:2005](#papers-bornat-popl-2005), [papers/calcagno:popl:2009](#papers-calcagno-popl-2009), [papers/distefano:tacas:2006](#papers-distefano-tacas-2006), [papers/ohearn:cacm:2019](#papers-ohearn-cacm-2019), [papers/ohearn:tcs:2007](#papers-ohearn-tcs-2007)
- John W. O'Leary: [papers/aagaard:fmcad:2000](#papers-aagaard-fmcad-2000)
- Jason Oberg: [papers/oberg:dac:2010](#papers-oberg-dac-2010)
- Jason K. Oberg: [papers/tiwari:isca:2011](#papers-tiwari-isca-2011)
- Duckki Oe: [papers/stump:fmsd:2013](#papers-stump-fmsd-2013)
- Greg Ordy: [papers/chu:ieeedtc:1992](#papers-chu-ieeedtc-1992)
- John Ousterhout: [papers/ousterhout:usenix:1996](#papers-ousterhout-usenix-1996)
- Scott Owens: [papers/kumar:popl:2014](#papers-kumar-popl-2014), [papers/sarkar:popl:2009](#papers-sarkar-popl-2009)
- Anne Pacalet: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- Subbarao Palacharla: [papers/palacharla:micro:1995](#papers-palacharla-micro-1995)
- Aurojit Panda: [papers/balasubramanium:hotos:2017](#papers-balasubramanium-hotos-2017)
- Sudhindra Pandav: [papers/kaivola:cav:2009](#papers-kaivola-cav-2009)
- Sven Panne: [papers/chakravarty:haskffi:2003](#papers-chakravarty-haskffi-2003)
- Pat Pannuto: [papers/levy:apsys:2017](#papers-levy-apsys-2017), [papers/levy:plos:2015](#papers-levy-plos-2015), [papers/levy:sosp:2017](#papers-levy-sosp-2017)
- Alan Parker: [papers/barbacci:computer:1978](#papers-barbacci-computer-1978)
- Michael A. Parker: [papers/regehr:rtss:2003](#papers-regehr-rtss-2003)
- Matthew Parkinson: [papers/bornat:popl:2005](#papers-bornat-popl-2005), [papers/dinsdale-young:popl:2013](#papers-dinsdale-young-popl-2013), [papers/hatcliff:compsurv:2012](#papers-hatcliff-compsurv-2012), [papers/parkinson:popl:2005](#papers-parkinson-popl-2005)
- Gennaro Parlato: [papers/fischer:ase:2013](#papers-fischer-ase-2013)
- Bryan Parno: [papers/ferraiuolo:sosp:2017](#papers-ferraiuolo-sosp-2017), [papers/hawblitzel:osdi:2014](#papers-hawblitzel-osdi-2014)
- Andrei Paskevich: [papers/filliatre:esop:2013](#papers-filliatre-esop-2013)
- Ashan Pathirane: [papers/reid:cav:2016](#papers-reid-cav-2016)
- David A. Patterson: [papers/hennessy:book:2011](#papers-hennessy-book-2011), [papers/patterson:cacm:1985](#papers-patterson-cacm-1985), [papers/patterson:sigarch:1980](#papers-patterson-sigarch-1980)
- Daniel Patterson: [papers/weiss:arxiv:2018](#papers-weiss-arxiv-2018)
- Wolfgang J. Paul: [papers/alkassar:vstte:2010](#papers-alkassar-vstte-2010), [papers/alkassar:vstte:2012](#papers-alkassar-vstte-2012), [papers/beyer:ijsttt:2006](#papers-beyer-ijsttt-2006), [papers/kroening:dac:2001](#papers-kroening-dac-2001), [papers/kroening:itg:2000](#papers-kroening-itg-2000)
- Lawrence C. Paulson: [papers/nipkow:book:2002](#papers-nipkow-book-2002)
- Michael Pearce: [papers/pearce:compsurv:2013](#papers-pearce-compsurv-2013)
- Stefan Pees: [papers/zivojnovic:vlsi:1996](#papers-zivojnovic-vlsi-1996)
- Edgar Pek: [papers/mai:asplos:2013](#papers-mai-asplos-2013)
- Alex Peleg: [papers/peleg:micro:1996](#papers-peleg-micro-1996)
- Willem Penninckx: [papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011), [papers/penninckx:nfm:2012](#papers-penninckx-nfm-2012), [papers/philippaerts:scp:2014](#papers-philippaerts-scp-2014)
- Stuart Pernsteiner: [papers/toman:ase:2015](#papers-toman-ase-2015)
- Adrian Perrig: [papers/seshadri:sosp:2007](#papers-seshadri-sosp-2007)
- John Peterson: [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999), [papers/peterson:hw:1995](#papers-peterson-hw-1995), [papers/peterson:padl:2001](#papers-peterson-padl-2001), [papers/reid:hw:1995](#papers-reid-hw-1995), [papers/reid:icse:1999](#papers-reid-icse-1999), [papers/reid:yale:1998](#papers-reid-yale-1998)
- Elena Petrova: [papers/alkassar:vstte:2010](#papers-alkassar-vstte-2010)
- Mauro Pezzè: [papers/braione:icse:2018](#papers-braione-icse-2018)
- Pieter Philippaerts: [papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011), [papers/philippaerts:scp:2014](#papers-philippaerts-scp-2014)
- Benjamin C. Pierce: [papers/hritcu:icfp:2013](#papers-hritcu-icfp-2013), [papers/pierce:book:2016](#papers-pierce-book-2016)
- Frank Piessens: [papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011), [papers/jacobs:vstte:2010](#papers-jacobs-vstte-2010), [papers/penninckx:nfm:2012](#papers-penninckx-nfm-2012), [papers/philippaerts:scp:2014](#papers-philippaerts-scp-2014), [papers/smans:ecoop:2009](#papers-smans-ecoop-2009), [papers/smans:fmood:2010](#papers-smans-fmood-2010), [papers/vogels:fmoods:2011](#papers-vogels-fmoods-2011)
- Jonathan D. Pincus: [papers/bush:spe:2000](#papers-bush-spe-2000)
- Flávia Pisani: [papers/silva:sbac:2016](#papers-silva-sbac-2016)
- Marco Pistore: [papers/fuxman:isre:2001](#papers-fuxman-isre-2001)
- Carl Pixley: [papers/lahiri:hldvt:2001](#papers-lahiri-hldvt-2001)
- Amir Pnueli: [papers/pnueli:sfcs:1977](#papers-pnueli-sfcs-1977), [papers/pnueli:tacas:1998](#papers-pnueli-tacas-1998)
- Federico Poli: [papers/astrauskas:oopsla:2019](#papers-astrauskas-oopsla-2019)
- Mario Polino: [papers/shoshitaishvili:sp:2016](#papers-shoshitaishvili-sp-2016)
- Carlos G. López Pombo: [papers/frias:icse:2005](#papers-frias-icse-2005)
- Pongsin Poosankam: [papers/martignoni:asplos:2012](#papers-martignoni-asplos-2012)
- Rachel Potvin: [papers/potvin:cacm:2016](#papers-potvin-cacm-2016)
- Johan Van Praet: [papers/fauth:edtc:1995](#papers-fauth-edtc-1995)
- Mathias Preiner: [papers/niemetz:jsat:2015](#papers-niemetz-jsat-2015)
- Nathanael Premillieu: [papers/stephens:micro:2017](#papers-stephens-micro-2017)
- Thomas Prescher: [papers/kocher:arxiv:2018](#papers-kocher-arxiv-2018), [papers/lipp:arxiv:2018](#papers-lipp-arxiv-2018)
- Virgile Prevosto: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- Steven Przybylski: [papers/gross:micro:2016](#papers-gross-micro-2016), [papers/hennessy:micro:1982](#papers-hennessy-micro-1982)
- Armand Puccetti: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- Christopher Pulte: [papers/armstrong:arw:2018](#papers-armstrong-arw-2018), [papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019), [papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019), [papers/flur:popl:2016](#papers-flur-popl-2016), [papers/gray:micro:2015](#papers-gray-micro-2015)
- Shaz Qadeer: [papers/chatterjee:tacas:2007](#papers-chatterjee-tacas-2007), [papers/condit:popl:2009](#papers-condit-popl-2009), [papers/lal:cav:2012](#papers-lal-cav-2012), [papers/lal:fse:2014](#papers-lal-fse-2014), [papers/lal:pldi:2015](#papers-lal-pldi-2015)
- Ning Qu: [papers/franklin:cmu:2008](#papers-franklin-cmu-2008), [papers/seshadri:sosp:2007](#papers-seshadri-sosp-2007)
- Sean Quinlan: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Rodric M. Rabbah: [papers/thies:ppopp:2005](#papers-thies-ppopp-2005)
- Shree P. Rahul: [papers/necula:cc:2002](#papers-necula-cc-2002)
- Sriram K. Rajamani: [papers/ball:pldi:2001](#papers-ball-pldi-2001)
- Zvonimir Rakamarić: [papers/balasubramanium:hotos:2017](#papers-balasubramanium-hotos-2017), [papers/baranowski:atva:2018](#papers-baranowski-atva-2018), [papers/chatterjee:tacas:2007](#papers-chatterjee-tacas-2007), [papers/dimjasevic:ifm:2018](#papers-dimjasevic-ifm-2018), [papers/narayanan:hotos:2019](#papers-narayanan-hotos-2019), [papers/rakamaric:cav:2014](#papers-rakamaric-cav-2014)
- Norman Ramsey: [papers/dias:popl:2010](#papers-dias-popl-2010), [papers/fernandez:icse:1997](#papers-fernandez-icse-1997), [papers/ramsey:lctes:1998](#papers-ramsey-lctes-1998), [papers/ramsey:toplas:1997](#papers-ramsey-toplas-1997)
- Keith Randall: [papers/joshi:pldi:2002](#papers-joshi-pldi-2002)
- Parthasarathy Ranganathan: [papers/kumar:isca:2004](#papers-kumar-isca-2004)
- Rajesh Rao: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Richard F. Rashid: [papers/draves:sosp:1991](#papers-draves-sosp-1991)
- Jakob von Raumer: [papers/demoura:cade:2015](#papers-demoura-cade-2015)
- Binoy Ravindran: [papers/roessle:cpp:2019](#papers-roessle-cpp-2019), [papers/tahat:fmcad:2019](#papers-tahat-fmcad-2019), [papers/verbeek:fmmsd:2019](#papers-verbeek-fmmsd-2019)
- Alasdair Rawsthorne: [papers/bird:sc:1993](#papers-bird-sc-1993)
- Alexandre Rebert: [papers/avgerinos:icse:2014](#papers-avgerinos-icse-2014)
- David Redmiles: [papers/rieman:chi:1995](#papers-rieman-chi-1995)
- Erik Reeber: [papers/kaivola:cav:2009](#papers-kaivola-cav-2009)
- John Regehr: [papers/eide:icse:2002](#papers-eide-icse-2002), [papers/lopes:pldi:2015](#papers-lopes-pldi-2015), [papers/regehr:acp4is:2003](#papers-regehr-acp4is-2003), [papers/regehr:asplos:2004](#papers-regehr-asplos-2004), [papers/regehr:emsoft:2003](#papers-regehr-emsoft-2003), [papers/regehr:lctes:2006](#papers-regehr-lctes-2006), [papers/regehr:pldi:2012](#papers-regehr-pldi-2012), [papers/regehr:rtss:2003](#papers-regehr-rtss-2003), [papers/regehr:tecs:2005](#papers-regehr-tecs-2005)
- Alastair D. Reid: [papers/armstrong:arw:2018](#papers-armstrong-arw-2018), [papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019), [papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019), [papers/boettcher:date:2014](#papers-boettcher-date-2014), [papers/chakravarty:haskffi:2003](#papers-chakravarty-haskffi-2003), [papers/eide:aspse:2001](#papers-eide-aspse-2001), [papers/eide:icse:2002](#papers-eide-icse-2002), [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999), [papers/jones:hw:1997](#papers-jones-hw-1997), [papers/jones:pldi:1999](#papers-jones-pldi-1999), [papers/lin:sdr:2006](#papers-lin-sdr-2006), [papers/lin:sips:2006](#papers-lin-sips-2006), [papers/ozer:sbacpad:2007](#papers-ozer-sbacpad-2007), [papers/peterson:hw:1995](#papers-peterson-hw-1995), [papers/peterson:padl:2001](#papers-peterson-padl-2001), [papers/regehr:acp4is:2003](#papers-regehr-acp4is-2003), [papers/regehr:asplos:2004](#papers-regehr-asplos-2004), [papers/regehr:emsoft:2003](#papers-regehr-emsoft-2003), [papers/regehr:rtss:2003](#papers-regehr-rtss-2003), [papers/regehr:tecs:2005](#papers-regehr-tecs-2005), [papers/reid:cases:2008](#papers-reid-cases-2008), [papers/reid:cav:2016](#papers-reid-cav-2016), [papers/reid:fmcad:2016](#papers-reid-fmcad-2016), [papers/reid:gfpw:1989](#papers-reid-gfpw-1989), [papers/reid:gfpw:1993](#papers-reid-gfpw-1993), [papers/reid:gfpw:1994](#papers-reid-gfpw-1994), [papers/reid:hw:1995](#papers-reid-hw-1995), [papers/reid:icse:1999](#papers-reid-icse-1999), [papers/reid:ifl:1998](#papers-reid-ifl-1998), [papers/reid:msc:1993](#papers-reid-msc-1993), [papers/reid:oopsla:2017](#papers-reid-oopsla-2017), [papers/reid:osdi:2000](#papers-reid-osdi-2000), [papers/reid:phd:2019](#papers-reid-phd-2019), [papers/reid:yale:1998](#papers-reid-yale-1998), [papers/reid:yale:2001](#papers-reid-yale-2001), [papers/stephens:micro:2017](#papers-stephens-micro-2017), [papers/woh:micro:2008](#papers-woh-micro-2008)
- Alexander Reinhard: [papers/mantel:pls:2007](#papers-mantel-pls-2007)
- Andrew Reynolds: [papers/barrett:cav:2011](#papers-barrett-cav-2011), [papers/stump:fmsd:2013](#papers-stump-fmsd-2013)
- John C. Reynolds: [papers/reynolds:lics:2002](#papers-reynolds-lics-2002)
- Tamara Rezk: [papers/barthe:csfw:2004](#papers-barthe-csfw-2004), [papers/barthe:mscs:2011](#papers-barthe-mscs-2011)
- Alejandro Rico: [papers/stephens:micro:2017](#papers-stephens-micro-2017)
- Tom Ridge: [papers/sarkar:popl:2009](#papers-sarkar-popl-2009)
- John Rieman: [papers/rieman:chi:1995](#papers-rieman-chi-1995)
- Christine Rizkallah: [papers/amani:asplos:2016](#papers-amani-asplos-2016)
- Martin Roberts: [papers/chu:ieeedtc:1992](#papers-chu-ieeedtc-1992)
- Thomas Roberts: [papers/stewart:difts:2014](#papers-stewart-difts-2014)
- Michael Roe: [papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020), [papers/woodruff:isca:2014](#papers-woodruff-isca-2014)
- Ian Roessle: [papers/roessle:cpp:2019](#papers-roessle-cpp-2019), [papers/verbeek:fmmsd:2019](#papers-verbeek-fmmsd-2019)
- Muriel Roger: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- Michael S. Rogers: [papers/siegel:sc:2015](#papers-siegel-sc-2015)
- Lindsay Rolig: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Jan-Willem Roorda: [papers/claessen:sfm:2006](#papers-claessen-sfm-2006)
- Charles W. Rose: [papers/chu:ieeedtc:1992](#papers-chu-ieeedtc-1992)
- Christopher Rowen: [papers/gross:micro:2016](#papers-gross-micro-2016), [papers/hennessy:micro:1982](#papers-hennessy-micro-1982)
- Colin Runciman: [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999)
- Richard M. Russell: [papers/russell:cacm:1978](#papers-russell-cacm-1978)
- Leonid Ryzhyk: [papers/balasubramanium:hotos:2017](#papers-balasubramanium-hotos-2017), [papers/narayanan:hotos:2019](#papers-narayanan-hotos-2019)
- Philipp Rümmer: [papers/leino:tacas:2010](#papers-leino-tacas-2010)
- Andrei Sabelfeld: [papers/myers:csfw:2004](#papers-myers-csfw-2004), [papers/sabelfield:jcs:2009](#papers-sabelfield-jcs-2009)
- Jorge Luis Sacchini: [papers/becker:fm:2016](#papers-becker-fm-2016)
- Caitlin Sadowski: [papers/sadowski:cacm:2018](#papers-sadowski-cacm-2018), [papers/sadowski:icse-seip:2018](#papers-sadowski-icse-seip-2018), [papers/sadowski:icse:2015](#papers-sadowski-icse-2015)
- Mooly Sagiv: [papers/naik:popl:2012](#papers-naik-popl-2012)
- Yasushi Saito: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Christopher Salls: [papers/shoshitaishvili:sp:2016](#papers-shoshitaishvili-sp-2016), [papers/stephens:ndss:2016](#papers-stephens-ndss-2016)
- Hanan Samet: [papers/samet:ieeetse:1977](#papers-samet-ieeetse-1977), [papers/samet:phd:1975](#papers-samet-phd-1975)
- Richard Samuels: [papers/morrisett:wcsss:1999](#papers-morrisett-wcsss-1999)
- David Sands: [papers/sabelfield:jcs:2009](#papers-sabelfield-jcs-2009)
- Thomas Santen: [papers/leinenbach:fm:2009](#papers-leinenbach-fm-2009)
- Sercan Sari: [papers/deng:hasp:2019](#papers-deng-hasp-2019)
- Susmit Sarkar: [papers/flur:popl:2016](#papers-flur-popl-2016), [papers/gray:micro:2015](#papers-gray-micro-2015), [papers/sarkar:pldi:2011](#papers-sarkar-pldi-2011), [papers/sarkar:popl:2009](#papers-sarkar-popl-2009)
- Jun Sawada: [papers/hunt:micro:1999](#papers-hunt-micro-1999)
- Wayne A. Sawdon: [papers/bershad:cmpcon:1993](#papers-bershad-cmpcon-1993)
- Christian Schallhart: [papers/holzer:cav:2008](#papers-holzer-cav-2008), [papers/holzer:hvc:2010](#papers-holzer-hvc-2010)
- Eric Schkufza: [papers/heule:pldi:2016](#papers-heule-pldi-2016), [papers/sharma:oopsla:2012](#papers-sharma-oopsla-2012)
- Sabine Schmaltz: [papers/schmaltz:vstte:2012](#papers-schmaltz-vstte-2012)
- Oliver Schmidt: [papers/dunkels:enss:2006](#papers-dunkels-enss-2006)
- Alan Schmitt: [papers/bodin:popl:2014](#papers-bodin-popl-2014)
- Fred B. Schneider: [papers/clarkson:jcs:2010](#papers-clarkson-jcs-2010)
- Wolfram Schulte: [papers/barnett:cacm:2011](#papers-barnett-cacm-2011), [papers/barnett:cassis:2004](#papers-barnett-cassis-2004), [papers/barnett:vstte:2005](#papers-barnett-vstte-2005), [papers/cohen:cav:2010](#papers-cohen-cav-2010), [papers/cohen:entcs:2009](#papers-cohen-entcs-2009), [papers/maus:amast:2008](#papers-maus-amast-2008), [papers/tillmann:fse:2005](#papers-tillmann-fse-2005)
- Edward J. Schwartz: [papers/manes:ieeetse:2019](#papers-manes-ieeetse-2019), [papers/schwartz:sp:2010](#papers-schwartz-sp-2010)
- Daniel Schwartz-Narbonne: [papers/chong:icse:2020](#papers-chong-icse-2020)
- Oliver Schwarz: [papers/khakpour:cpp:2013](#papers-khakpour-cpp-2013), [papers/schwarz:sefm:2016](#papers-schwarz-sefm-2016)
- Michael Schwarz: [papers/kocher:arxiv:2018](#papers-kocher-arxiv-2018), [papers/lipp:arxiv:2018](#papers-lipp-arxiv-2018)
- Malte Schwerhoff: [papers/muller:vmcai:2016](#papers-muller-vmcai-2016), [papers/schwerhoff:ecoop:2015](#papers-schwerhoff-ecoop-2015)
- David Seal: [papers/seal:book:2000](#papers-seal-book-2000)
- Sean Seefried: [papers/murray:secpriv:2013](#papers-murray-secpriv-2013)
- Carl-Johan H. Seger: [papers/aagaard:fmcad:2000](#papers-aagaard-fmcad-2000), [papers/segar:fmsd:1995](#papers-segar-fmsd-1995)
- Koushik Sen: [papers/cadar:cacm:2013](#papers-cadar-cacm-2013), [papers/godefroid:pldi:2005](#papers-godefroid-pldi-2005)
- Shane Sendall: [papers/cifuentes:iwpc:1998](#papers-cifuentes-iwpc-1998)
- Sangwon Seo: [papers/woh:micro:2008](#papers-woh-micro-2008)
- Janis Sermulins: [papers/thies:ppopp:2005](#papers-thies-ppopp-2005)
- Arvind Seshadri: [papers/franklin:cmu:2008](#papers-franklin-cmu-2008), [papers/seshadri:sosp:2007](#papers-seshadri-sosp-2007)
- Geet Sethi: [papers/lustig:asplos:2016](#papers-lustig-asplos-2016)
- Simha Sethumadhavan: [papers/tang:sec:2017](#papers-tang-sec-2017)
- Jaroslav Sevcik: [papers/mcilroy:arxiv:2019](#papers-mcilroy-arxiv-2019)
- Thomas Arthur Leck Sewell: [papers/amani:asplos:2016](#papers-amani-asplos-2016), [papers/klein:sosp:2009](#papers-klein-sosp-2009), [papers/sewell:pldi:2013](#papers-sewell-pldi-2013)
- Peter Sewell: [papers/armstrong:arw:2018](#papers-armstrong-arw-2018), [papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019), [papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019), [papers/flur:popl:2016](#papers-flur-popl-2016), [papers/gray:micro:2015](#papers-gray-micro-2015), [papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020), [papers/sarkar:pldi:2011](#papers-sarkar-pldi-2011), [papers/sarkar:popl:2009](#papers-sarkar-popl-2009)
- Ali Sezgin: [papers/flur:popl:2016](#papers-flur-popl-2016)
- Andrey Shadrin: [papers/schmaltz:vstte:2012](#papers-schmaltz-vstte-2012)
- Muzammil Shahbaz: [papers/barr:tse:2015](#papers-barr-tse-2015)
- Zhong Shao: [papers/costanzo:pldi:2016](#papers-costanzo-pldi-2016), [papers/gu:osdi:2016](#papers-gu-osdi-2016)
- Rahul Sharma: [papers/heule:pldi:2016](#papers-heule-pldi-2016), [papers/sharma:oopsla:2012](#papers-sharma-oopsla-2012), [papers/sharma:pls:2013](#papers-sharma-pls-2013)
- Erin Shepherd: [papers/reid:cav:2016](#papers-reid-cav-2016)
- Benjamin Sherman: [papers/choi:icfp:2017](#papers-choi-icfp-2017)
- Timothy Sherwood: [papers/oberg:dac:2010](#papers-oberg-dac-2010), [papers/tiwari:asplos:2009](#papers-tiwari-asplos-2009), [papers/tiwari:isca:2009](#papers-tiwari-isca-2009), [papers/tiwari:isca:2011](#papers-tiwari-isca-2011)
- Xiaomu Shi: [papers/blanqui:rapido:2011](#papers-blanqui-rapido-2011), [papers/shi:phd:2013](#papers-shi-phd-2013)
- Avraham Shinnar: [papers/nanevski:icfp:2008](#papers-nanevski-icfp-2008)
- Yan Shoshitaishvili: [papers/shoshitaishvili:sp:2016](#papers-shoshitaishvili-sp-2016), [papers/stephens:ndss:2016](#papers-stephens-ndss-2016)
- Michael Siegel: [papers/pnueli:tacas:1998](#papers-pnueli-tacas-1998)
- Stephen F. Siegel: [papers/siegel:sc:2015](#papers-siegel-sc-2015)
- David J. Sielaff: [papers/bush:spe:2000](#papers-bush-spe-2000)
- Daniel P. Siewiorek: [papers/barbacci2:computer:1973](#papers-barbacci2-computer-1973), [papers/barbacci:afips:1977](#papers-barbacci-afips-1977), [papers/barbacci:computer:1973](#papers-barbacci-computer-1973), [papers/barbacci:computer:1977](#papers-barbacci-computer-1977), [papers/barbacci:isca:1973](#papers-barbacci-isca-1973)
- Joseph Sifakis: [papers/clarke:cacm:2009](#papers-clarke-cacm-2009)
- Julien Signoles: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- Helgi Sigurbjarnarson: [papers/nelson:sosp:2017](#papers-nelson-sosp-2017), [papers/sigurbjarnarson:osdi:2016](#papers-sigurbjarnarson-osdi-2016), [papers/sigurbjarnarson:osdi:2018](#papers-sigurbjarnarson-osdi-2018)
- Hércules Cardoso da Silva: [papers/silva:sbac:2016](#papers-silva-sbac-2016)
- Eli Singerman: [papers/pnueli:tacas:1998](#papers-pnueli-tacas-1998)
- Satnam Singh: [papers/reid:gfpw:1993](#papers-reid-gfpw-1993)
- Carsten Sinz: [papers/merz:vstte:2012](#papers-merz-vstte-2012)
- Michal Sipko: [papers/sadowski:icse-seip:2018](#papers-sadowski-icse-seip-2018)
- Vilhelm Sjöberg: [papers/gu:osdi:2016](#papers-gu-osdi-2016), [papers/pierce:book:2016](#papers-pierce-book-2016)
- Lau Skorstengaard: [papers/skorstengaard:esop:2018](#papers-skorstengaard-esop-2018), [papers/skorstengaard:popl:2019](#papers-skorstengaard-popl-2019)
- Anna Slobodová: [papers/kaivola:cav:2009](#papers-kaivola-cav-2009), [papers/slobodova:memocode:2011](#papers-slobodova-memocode-2011)
- Stephen Smalley: [papers/spencer:security:1999](#papers-spencer-security-1999)
- Jan Smans: [papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011), [papers/jacobs:vstte:2010](#papers-jacobs-vstte-2010), [papers/leino:fosad:2007](#papers-leino-fosad-2007), [papers/penninckx:nfm:2012](#papers-penninckx-nfm-2012), [papers/philippaerts:scp:2014](#papers-philippaerts-scp-2014), [papers/smans:ecoop:2009](#papers-smans-ecoop-2009), [papers/smans:fmood:2010](#papers-smans-fmood-2010), [papers/vogels:fmoods:2011](#papers-vogels-fmoods-2011)
- Diana K. Smetters: [papers/smetters:nspw:2002](#papers-smetters-nspw-2002)
- Lawrence M. Smith: [papers/albin:cli:1995](#papers-albin-cli-1995)
- Gareth Smith: [papers/bodin:popl:2014](#papers-bodin-popl-2014)
- Eric W. Smith: [papers/hardin:acl2:2006](#papers-hardin-acl2-2006)
- Frederick Smith: [papers/morrisett:wcsss:1999](#papers-morrisett-wcsss-1999), [papers/smith:esop:2000](#papers-smith-esop-2000)
- James E. Smith: [papers/palacharla:micro:1995](#papers-palacharla-micro-1995), [papers/smith:tocs:1984](#papers-smith-tocs-1984)
- Brian Cantwell Smith: [papers/smith:book:1996](#papers-smith-book-1996)
- Geoffrey Smith: [papers/smith:fossacs:2009](#papers-smith-fossacs-2009)
- Bryan So: [papers/miller:cacm:1990](#papers-miller-cacm-1990)
- Dawn Song: [papers/martignoni:asplos:2012](#papers-martignoni-asplos-2012)
- Fu Song: [papers/wang:tase:2018](#papers-wang-tase-2018)
- Tyler Sorensen: [papers/wickerson:popl:2017](#papers-wickerson-popl-2017)
- Antal Spector-Zabusky: [papers/hritcu:icfp:2013](#papers-hritcu-icfp-2013)
- Ray Spencer: [papers/spencer:security:1999](#papers-spencer-security-1999)
- Fausto Spoto: [papers/ernst:icse:2016](#papers-ernst-icse-2016)
- Sudarshan K. Srinivasan: [papers/srinivasan:ieeetoc:2010](#papers-srinivasan-ieeetoc-2010)
- Mark Staples: [papers/andronick:icse:2012](#papers-andronick-icse-2012)
- Ian Stark: [papers/armstrong:arw:2018](#papers-armstrong-arw-2018), [papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019), [papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019), [papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020)
- Shane G. Stephens: [papers/hohmuth:sigops:2002](#papers-hohmuth-sigops-2002)
- Nick Stephens: [papers/shoshitaishvili:sp:2016](#papers-shoshitaishvili-sp-2016), [papers/stephens:ndss:2016](#papers-stephens-ndss-2016)
- Nigel Stephens: [papers/stephens:micro:2017](#papers-stephens-micro-2017)
- Daryl Stewart: [papers/stewart:difts:2014](#papers-stewart-difts-2014)
- James M. Stichnoth: [papers/subhlok:ppopp:1993](#papers-subhlok-ppopp-1993)
- Salvatore Stolfo: [papers/tang:sec:2017](#papers-tang-sec-2017)
- Leigh Stoller: [papers/reid:osdi:2000](#papers-reid-osdi-2000)
- Aaron Stump: [papers/barrett:cade:2000](#papers-barrett-cade-2000), [papers/stump:fmsd:2013](#papers-stump-fmsd-2013)
- Stephen Y. H. Su: [papers/su:computer:1974](#papers-su-computer-1974)
- Jaspal Subhlok: [papers/subhlok:ppopp:1993](#papers-subhlok-ppopp-1993)
- Pramod Subramanyan: [papers/huang:todaes:2019](#papers-huang-todaes-2019)
- G. Edward Suh: [papers/ferraiuolo:asplos:2017](#papers-ferraiuolo-asplos-2017), [papers/ferraiuolo:ccs:2018](#papers-ferraiuolo-ccs-2018), [papers/ferraiuolo:dac:2017](#papers-ferraiuolo-dac-2017), [papers/liu:cpsspc:2018](#papers-liu-cpsspc-2018), [papers/zhang:asplos:2015](#papers-zhang-asplos-2015)
- Alexander J. Summers: [papers/astrauskas:oopsla:2019](#papers-astrauskas-oopsla-2019), [papers/heule:ftfjp:2011](#papers-heule-ftfjp-2011), [papers/heule:vmcai:2013](#papers-heule-vmcai-2013), [papers/muller:vmcai:2016](#papers-muller-vmcai-2016), [papers/schwerhoff:ecoop:2015](#papers-schwerhoff-ecoop-2015)
- Edward H. Sussenguth: [papers/falkoff:ibm:1964](#papers-falkoff-ibm-1964)
- Geoff Sutcliffe: [papers/sutcliffe:ai:2001](#papers-sutcliffe-ai-2001)
- Grégoire Sutre: [papers/henzinger:spin:2003](#papers-henzinger-spin-2003)
- Christian Suttner: [papers/sutcliffe:ai:2001](#papers-sutcliffe-ai-2001)
- Sol Swords: [papers/slobodova:memocode:2011](#papers-slobodova-memocode-2011)
- Jakub Szefer: [papers/deng:hasp:2019](#papers-deng-hasp-2019)
- László Szekeres: [papers/babic:fse:2019](#papers-babic-fse-2019)
- Michal Szymaniak: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Emma Söderberg: [papers/sadowski:icse-seip:2018](#papers-sadowski-icse-seip-2018), [papers/sadowski:icse:2015](#papers-sadowski-icse-2015)
- Amer Tahat: [papers/tahat:fmcad:2019](#papers-tahat-fmcad-2019)
- Ankur Taly: [papers/godefroid:pldi:2012](#papers-godefroid-pldi-2012)
- Yong Kiam Tan: [papers/loow:pldi:2019](#papers-loow-pldi-2019)
- Gang Tan: [papers/morrisett:pldi:2012](#papers-morrisett-pldi-2012)
- Adrian Tang: [papers/tang:sec:2017](#papers-tang-sec-2017)
- Serdar Tasiran: [papers/chong:icse:2020](#papers-chong-icse-2020), [papers/cook:cav:2018](#papers-cook-cav-2018)
- Joseph Tassarotti: [papers/morrisett:pldi:2012](#papers-morrisett-pldi-2012)
- John Van Tassel: [papers/boulton:tpcd:1993](#papers-boulton-tpcd-1993)
- Zachary Tatlock: [papers/weitz:icfp:2017](#papers-weitz-icfp-2017)
- Michael Tautschnig: [papers/alglave:toplas:2014](#papers-alglave-toplas-2014), [papers/chong:icse:2020](#papers-chong-icse-2020), [papers/cook:cav:2018](#papers-cook-cav-2018), [papers/holzer:cav:2008](#papers-holzer-cav-2008), [papers/holzer:hvc:2010](#papers-holzer-hvc-2010)
- Boon Hwa Tay: [papers/ananda:osr:1992](#papers-ananda-osr-1992)
- Christopher Taylor: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013), [papers/kaivola:cav:2009](#papers-kaivola-cav-2009)
- Tobias Tebbi: [papers/mcilroy:arxiv:2019](#papers-mcilroy-arxiv-2019)
- Amber Telfer: [papers/kaivola:cav:2009](#papers-kaivola-cav-2009)
- Hendrik Tews: [papers/becker:fm:2016](#papers-becker-fm-2016), [papers/hohmuth:plos:2005](#papers-hohmuth-plos-2005), [papers/hohmuth:sigops:2002](#papers-hohmuth-sigops-2002)
- Javier Thaine: [papers/ernst:icse:2016](#papers-ernst-icse-2016)
- Chandramohan A. Thekkath: [papers/lie:secpri:2003](#papers-lie-secpri-2003), [papers/lie:sosp:2003](#papers-lie-sosp-2003)
- William Thies: [papers/gordon:asplos:2002](#papers-gordon-asplos-2002), [papers/thies:micro:2007](#papers-thies-micro-2007), [papers/thies:ppopp:2005](#papers-thies-ppopp-2005)
- Xinmin Tian: [papers/wang:pldi:2007](#papers-wang-pldi-2007)
- Nikolai Tillmann: [papers/tillmann:fse:2005](#papers-tillmann-fse-2005)
- Cesare Tinelli: [papers/barrett:cav:2011](#papers-barrett-cav-2011), [papers/barrett:smtlib:2016](#papers-barrett-smtlib-2016), [papers/stump:fmsd:2013](#papers-stump-fmsd-2013)
- Ben L. Titzer: [papers/mcilroy:arxiv:2019](#papers-mcilroy-arxiv-2019)
- Mohit Tiwari: [papers/oberg:dac:2010](#papers-oberg-dac-2010), [papers/tiwari:asplos:2009](#papers-tiwari-asplos-2009), [papers/tiwari:isca:2009](#papers-tiwari-isca-2009), [papers/tiwari:isca:2011](#papers-tiwari-isca-2011)
- Stephan Tobies: [papers/cohen:cav:2010](#papers-cohen-cav-2010), [papers/cohen:entcs:2009](#papers-cohen-entcs-2009)
- Andrew Tolmach: [papers/jones:microsoft:2001](#papers-jones-microsoft-2001)
- John Toman: [papers/toman:ase:2015](#papers-toman-ase-2015)
- Nigel P. Topham: [papers/bird:sc:1993](#papers-bird-sc-1993)
- Emina Torlak: [papers/bornholt:oopsla:2018](#papers-bornholt-oopsla-2018), [papers/nelson:sosp:2017](#papers-nelson-sosp-2017), [papers/nelson:sosp:2019](#papers-nelson-sosp-2019), [papers/sigurbjarnarson:osdi:2016](#papers-sigurbjarnarson-osdi-2016), [papers/sigurbjarnarson:osdi:2018](#papers-sigurbjarnarson-osdi-2018), [papers/toman:ase:2015](#papers-toman-ase-2015), [papers/torlak:onward:2013](#papers-torlak-onward-2013), [papers/torlak:pldi:2014](#papers-torlak-pldi-2014), [papers/weitz:icfp:2017](#papers-weitz-icfp-2017)
- Paolo Traverso: [papers/fuxman:isre:2001](#papers-fuxman-isre-2001)
- Marc Tremblay: [papers/tremblay:micro:1996](#papers-tremblay-micro-1996)
- Caroline Trippel: [papers/zhang:fmcad:2018](#papers-zhang-fmcad-2018)
- Jean-Baptiste Tristan: [papers/morrisett:pldi:2012](#papers-morrisett-pldi-2012)
- Takeshi Tsukada: [papers/matsushita:esop:2020](#papers-matsushita-esop-2020)
- Harvey Tuch: [papers/klein:sosp:2009](#papers-klein-sosp-2009)
- Thomas Tuerk: [papers/becker:fm:2016](#papers-becker-fm-2016), [papers/tuerk:vstte:2010](#papers-tuerk-vstte-2010)
- Dean M. Tullsen: [papers/kumar:isca:2004](#papers-kumar-isca-2004)
- Joseph Tuong: [papers/amani:asplos:2016](#papers-amani-asplos-2016)
- Mark R. Tuttle: [papers/chong:icse:2020](#papers-chong-icse-2020), [papers/cook:cav:2018](#papers-cook-cav-2018)
- Mattias Ulbrich: [papers/weigl:arxiv:2019](#papers-weigl-arxiv-2019)
- Sebastian Ullrich: [papers/ullrich:msc:2016](#papers-ullrich-msc-2016)
- Neil Vachharajani: [papers/bridges:micro:2007](#papers-bridges-micro-2007)
- Jonathan Valamehr: [papers/tiwari:isca:2011](#papers-tiwari-isca-2011)
- Steve VanDeBogart: [papers/efstathopoulos:sosp:2005](#papers-efstathopoulos-sosp-2005)
- Amit Vasudevan: [papers/vasudevan:secpriv:2013](#papers-vasudevan-secpriv-2013), [papers/vasudevan:usenix:2016](#papers-vasudevan-usenix-2016)
- Helmut Veith: [papers/clarke:cav:2000](#papers-clarke-cav-2000), [papers/holzer:cav:2008](#papers-holzer-cav-2008), [papers/holzer:hvc:2010](#papers-holzer-hvc-2010)
- Todd L. Veldhuizen: [papers/veldhuizen:oo:1998](#papers-veldhuizen-oo-1998)
- Miroslav N. Velev: [papers/velev:dac:2000](#papers-velev-dac-2000)
- Herman Venter: [papers/barnett:cacm:2011](#papers-barnett-cacm-2011), [papers/barnett:vstte:2005](#papers-barnett-vstte-2005)
- Freek Verbeek: [papers/roessle:cpp:2019](#papers-roessle-cpp-2019), [papers/verbeek:fmmsd:2019](#papers-verbeek-fmmsd-2019)
- Toon Verwaest: [papers/mcilroy:arxiv:2019](#papers-mcilroy-arxiv-2019)
- Giovanni Vigna: [papers/shoshitaishvili:sp:2016](#papers-shoshitaishvili-sp-2016), [papers/stephens:ndss:2016](#papers-stephens-ndss-2016)
- Muralidaran Vijayaraghavan: [papers/choi:icfp:2017](#papers-choi-icfp-2017)
- Jules Villard: [papers/hobor:popl:2013](#papers-hobor-popl-2013)
- Willem Visser: [papers/visser:tacas:2020](#papers-visser-tacas-2020)
- Yakir Vizel: [papers/huang:todaes:2019](#papers-huang-todaes-2019)
- Birgit Vogel-Heuser: [papers/weigl:arxiv:2019](#papers-weigl-arxiv-2019)
- Frédéric Vogels: [papers/jacobs:nfm:2011](#papers-jacobs-nfm-2011), [papers/vogels:fmoods:2011](#papers-vogels-fmoods-2011)
- Thiemo Voigt: [papers/dunkels:enss:2006](#papers-dunkels-enss-2006)
- Peter Vrabel: [papers/reid:cav:2016](#papers-reid-cav-2016)
- Dimitrios Vytiniotis: [papers/hritcu:icfp:2013](#papers-hritcu-icfp-2013)
- Philip Wadler: [papers/jones:hasklang:1999](#papers-jones-hasklang-1999), [papers/jones:hasklib:1999](#papers-jones-hasklib-1999)
- Jonas Wagner: [papers/wagner:hotos:2013](#papers-wagner-hotos-2013)
- David Walker: [papers/morrisett:wcsss:1999](#papers-morrisett-wcsss-1999), [papers/smith:esop:2000](#papers-smith-esop-2000), [papers/walker:popl:2000](#papers-walker-popl-2000), [papers/walker:tic:2001](#papers-walker-tic-2001)
- Paul Walker: [papers/stephens:micro:2017](#papers-stephens-micro-2017)
- Malcolm Wallace: [papers/chakravarty:haskffi:2003](#papers-chakravarty-haskffi-2003)
- Deborah A. Wallach: [papers/chang:tocs:2012](#papers-chang-tocs-2012), [papers/johnson:osr:1995](#papers-johnson-osr-1995)
- Zhanyong Wan: [papers/wright:icsm:2013](#papers-wright-icsm-2013)
- Mitchell Wand: [papers/wand:lfp:1980](#papers-wand-lfp-1980)
- Wei Wang: [papers/babic:fse:2019](#papers-babic-fse-2019)
- Ruth Wang: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Xi Wang: [papers/fonseca:ecs:2017](#papers-fonseca-ecs-2017), [papers/nelson:sosp:2017](#papers-nelson-sosp-2017), [papers/nelson:sosp:2019](#papers-nelson-sosp-2019), [papers/sigurbjarnarson:osdi:2016](#papers-sigurbjarnarson-osdi-2016), [papers/sigurbjarnarson:osdi:2018](#papers-sigurbjarnarson-osdi-2018)
- Ruoyu Wang: [papers/shoshitaishvili:sp:2016](#papers-shoshitaishvili-sp-2016), [papers/stephens:ndss:2016](#papers-stephens-ndss-2016)
- Perry H. Wang: [papers/wang:pldi:2007](#papers-wang-pldi-2007)
- Hong Wang: [papers/wang:pldi:2007](#papers-wang-pldi-2007)
- Feng Wang: [papers/wang:tase:2018](#papers-wang-tase-2018)
- Yao Wang: [papers/zhang:asplos:2015](#papers-zhang-asplos-2015)
- Hassan M. G. Wassel: [papers/tiwari:asplos:2009](#papers-tiwari-asplos-2009), [papers/tiwari:isca:2009](#papers-tiwari-isca-2009)
- Mark Wassell: [papers/armstrong:arw:2018](#papers-armstrong-arw-2018), [papers/armstrong:popl19:2019](#papers-armstrong-popl19-2019), [papers/armstrong:spisa:2019](#papers-armstrong-spisa-2019)
- Robert N. M. Watson: [papers/nienhuis:secpriv:2020](#papers-nienhuis-secpriv-2020), [papers/woodruff:isca:2014](#papers-woodruff-isca-2014)
- Kirk Webb: [papers/regehr:emsoft:2003](#papers-regehr-emsoft-2003), [papers/regehr:rtss:2003](#papers-regehr-rtss-2003), [papers/regehr:tecs:2005](#papers-regehr-tecs-2005)
- Michael Weber: [papers/chakravarty:haskffi:2003](#papers-chakravarty-haskffi-2003)
- Alexander Weigl: [papers/weigl:arxiv:2019](#papers-weigl-arxiv-2019)
- Westley Weimer: [papers/necula:cc:2002](#papers-necula-cc-2002)
- Charles B. Weinstock: [papers/barbacci:icse:1988](#papers-barbacci-icse-1988)
- Stephanie Weirich: [papers/morrisett:wcsss:1999](#papers-morrisett-wcsss-1999)
- Uri Weiser: [papers/peleg:micro:1996](#papers-peleg-micro-1996)
- Aaron Weiss: [papers/weiss:arxiv:2018](#papers-weiss-arxiv-2018)
- Konstantin Weitz: [papers/weitz:icfp:2017](#papers-weitz-icfp-2017)
- Matt Welsh: [papers/gay:pldi:2003](#papers-gay-pldi-2003)
- Markus Wenzel: [papers/nipkow:book:2002](#papers-nipkow-book-2002)
- Jesse Whittemore: [papers/kaivola:cav:2009](#papers-kaivola-cav-2009)
- John Wickerson: [papers/wickerson:popl:2017](#papers-wickerson-popl-2017)
- Mladen Wilder: [papers/woh:micro:2008](#papers-woh-micro-2008)
- Chris Wilkerson: [papers/kim:isca:2014](#papers-kim-isca-2014)
- Philip Wilkinson: [papers/mavin:isre:2009](#papers-mavin-isre-2009)
- Nicky Williams: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- Derek Williams: [papers/sarkar:pldi:2011](#papers-sarkar-pldi-2011)
- Phillip J. Windley: [papers/windley:ieeetoc:1995](#papers-windley-ieeetoc-1995)
- Jeannette M. Wing: [papers/barbacci:icse:1988](#papers-barbacci-icse-1988)
- Collin Winter: [papers/sadowski:icse:2015](#papers-sadowski-icse-2015)
- Simon Winwood: [papers/klein:sosp:2009](#papers-klein-sosp-2009)
- Mark Woh: [papers/lin:sdr:2006](#papers-lin-sdr-2006), [papers/woh:micro:2008](#papers-woh-micro-2008)
- Pieter van der Wolf: [papers/wolf:codes:2004](#papers-wolf-codes-2004)
- Jeremy Wong: [papers/gordon:asplos:2002](#papers-gordon-asplos-2002)
- Maverick Woo: [papers/manes:ieeetse:2019](#papers-manes-ieeetse-2019)
- Dale Woodford: [papers/corbett:tocs:2013](#papers-corbett-tocs-2013)
- Jonathan Woodruff: [papers/woodruff:isca:2014](#papers-woodruff-isca-2014)
- Hyrum K. Wright: [papers/wright:icsm:2013](#papers-wright-icsm-2013)
- Xiongnan Newman Wu: [papers/gu:osdi:2016](#papers-gu-osdi-2016)
- Valentin Wüstholz: [papers/mansur:arxiv:2020](#papers-mansur-arxiv-2020)
- Hongwei Xi: [papers/xi:icfp:2001](#papers-xi-icfp-2001)
- Yichen Xie: [papers/xie:bugs:2005](#papers-xie-bugs-2005)
- Wenjie Xiong: [papers/deng:hasp:2019](#papers-deng-hasp-2019)
- Rui Xu: [papers/ferraiuolo:asplos:2017](#papers-ferraiuolo-asplos-2017)
- Hui Xue: [papers/mai:asplos:2013](#papers-mai-asplos-2013)
- Boris Yakobowski: [papers/cuoq:sefm:2012](#papers-cuoq-sefm-2012)
- Hongseok Yang: [papers/calcagno:popl:2009](#papers-calcagno-popl-2009), [papers/dinsdale-young:popl:2013](#papers-dinsdale-young-popl-2013), [papers/distefano:tacas:2006](#papers-distefano-tacas-2006), [papers/naik:popl:2012](#papers-naik-popl-2012)
- Xuejun Yang: [papers/regehr:pldi:2012](#papers-regehr-pldi-2012)
- Nick Y. Yang: [papers/wang:pldi:2007](#papers-wang-pldi-2007)
- Jean Yang: [papers/yang:pldi:2010](#papers-yang-pldi-2010)
- Yuval Yarom: [papers/ge:jce:2016](#papers-ge-jce-2016), [papers/kocher:arxiv:2018](#papers-kocher-arxiv-2018), [papers/lipp:arxiv:2018](#papers-lipp-arxiv-2018)
- Alexander Yip: [papers/krohn:sosp:2007](#papers-krohn-sosp-2007)
- Shin Yoo: [papers/barr:tse:2015](#papers-barr-tse-2015)
- Brent Yorgey: [papers/pierce:book:2016](#papers-pierce-book-2016)
- William D. Young: [papers/bevier:jar:1989](#papers-bevier-jar-1989), [papers/hardin:acl2:2006](#papers-hardin-acl2-2006)
- Ali Zaidi: [papers/reid:cav:2016](#papers-reid-cav-2016)
- Cristian Zamfir: [papers/chipounov:hotdep:2009](#papers-chipounov-hotdep-2009)
- Steve Zdancewic: [papers/morrisett:wcsss:1999](#papers-morrisett-wcsss-1999), [papers/myers:csfw:2004](#papers-myers-csfw-2004), [papers/zdancewic:csfw:2001](#papers-zdancewic-csfw-2001), [papers/zdancewic:csfw:2003](#papers-zdancewic-csfw-2003)
- Sherali Zeadally: [papers/pearce:compsurv:2013](#papers-pearce-compsurv-2013)
- Matthew J. Zekauskas: [papers/bershad:cmpcon:1993](#papers-bershad-cmpcon-1993)
- Nickolai Zeldovich: [papers/dabek:sigops:2002](#papers-dabek-sigops-2002), [papers/zeldovich:osdi:2006](#papers-zeldovich-osdi-2006)
- Andreas Zeller: [papers/zeller:bugs:2005](#papers-zeller-bugs-2005)
- He Zhang: [papers/andronick:icse:2012](#papers-andronick-icse-2012)
- Yun Zhang: [papers/bridges:micro:2007](#papers-bridges-micro-2007)
- Danfeng Zhang: [papers/ferraiuolo:asplos:2017](#papers-ferraiuolo-asplos-2017), [papers/hawblitzel:osdi:2014](#papers-hawblitzel-osdi-2014), [papers/zhang:asplos:2015](#papers-zhang-asplos-2015)
- Kaiyuan Zhang: [papers/fonseca:ecs:2017](#papers-fonseca-ecs-2017), [papers/nelson:sosp:2017](#papers-nelson-sosp-2017)
- Hongce Zhang: [papers/huang:todaes:2019](#papers-huang-todaes-2019), [papers/zhang:fmcad:2018](#papers-zhang-fmcad-2018)
- Lintao Zhang: [papers/malik:cacm:2009](#papers-malik-cacm-2009)
- Fuyuan Zhang: [papers/mansur:arxiv:2020](#papers-mansur-arxiv-2020)
- Min Zhang: [papers/wang:tase:2018](#papers-wang-tase-2018)
- Jun Zhang: [papers/wang:tase:2018](#papers-wang-tase-2018)
- Chaoqiang Zhang: [papers/zhang:issta:2014](#papers-zhang-issta-2014)
- Mark Zhao: [papers/ferraiuolo:ccs:2018](#papers-ferraiuolo-ccs-2018)
- Manchun Zheng: [papers/siegel:sc:2015](#papers-siegel-sc-2015)
- Liming Zhu: [papers/andronick:icse:2012](#papers-andronick-icse-2012)
- Yunshan Zhu: [papers/biere:tacas:1999](#papers-biere-tacas-1999)
- Xiaoran Zhu: [papers/wang:tase:2018](#papers-wang-tase-2018)
- David Ziegler: [papers/efstathopoulos:sosp:2005](#papers-efstathopoulos-sosp-2005)
- Brian Zill: [papers/hawblitzel:osdi:2014](#papers-hawblitzel-osdi-2014)
- Timothy K. Zirkel: [papers/siegel:sc:2015](#papers-siegel-sc-2015)
- Vojin Zivojnovic: [papers/zivojnovic:vlsi:1996](#papers-zivojnovic-vlsi-1996)
- Bill Zorn: [papers/zorn:iscawddd:2017](#papers-zorn-iscawddd-2017)
- Susan Zuckerman: [papers/barbacci:afips:1977](#papers-barbacci-afips-1977)
- Emre Özer: [papers/ozer:sbacpad:2007](#papers-ozer-sbacpad-2007)
